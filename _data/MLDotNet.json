{"Data":{"GitHub":{"Issues":[{"Id":"1836532772","IsPullRequest":false,"CreatedAt":"2023-08-04T11:03:01","Actor":"torronen","Number":"6783","RawContent":null,"Title":"Include params in .zip file","State":"open","Body":"**Is your feature request related to a problem? Please describe.**\r\nI may have a model that has been in use for a while. If I was not careful, the params are lost. When updating the model, and retraining, I may accidentally use different parameters or AutoML may arrive at different end result. This can lead to a model with different charasteristics. I think it especially happens when calibrator is used, the distribution on scores seems often very different across models.\r\n\r\n**Describe the solution you'd like**\r\nOption A) save params inside the zip. There is already a text file with the version number, so why not also training paramterers. One could also consider including training data stats, or even dataset name. \r\n\r\nOption B) expose a way to load the model and then read the training parameters, at least those that exists, are readable or can be logically infered (such as how many leafs and trees)\r\n\r\n**Describe alternatives you've considered**\r\nIt is possible to open the contents on the zip file in notepad, and sometimes I can see the params. \r\n\r\n**Additional context**\r\nSaving this information and especially dataset information may cause data leaks. For example a desktop app manufacturer might not want to make it easy to replicate his model. I think this is not big concern in my opinion, but including documentation on what is inside zip file and how to remove it can be useful. However, I do not think many users will extract zip files, perhaps even with .zip removed.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6783","RelatedDescription":"Open issue \"Include params in .zip file\" (#6783)"},{"Id":"1830514689","IsPullRequest":true,"CreatedAt":"2023-08-03T19:24:12","Actor":"zewditu","Number":"6781","RawContent":null,"Title":"Add QA sweepable estimator in AutoML ","State":"closed","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [ ] There's a descriptive title that will make sense to other developers some time from now. \r\n- [ ] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [ ] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6781","RelatedDescription":"Closed or merged PR \"Add QA sweepable estimator in AutoML \" (#6781)"},{"Id":"1831274496","IsPullRequest":true,"CreatedAt":"2023-08-01T13:20:33","Actor":"asmirnov82","Number":"6782","RawContent":null,"Title":"Allow to define CultureInfo for parsing values on reading DataFrame from csv","State":"open","Body":"Fixes #5652 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/6782","RelatedDescription":"Open PR \"Allow to define CultureInfo for parsing values on reading DataFrame from csv\" (#6782)"},{"Id":"1828040573","IsPullRequest":false,"CreatedAt":"2023-07-30T19:17:58","Actor":"80LevelElf","Number":"6780","RawContent":null,"Title":"Ability to express the maximum variance in the specified properties","State":"open","Body":"**Is your feature request related to a problem? Please describe.**\r\nIt is very common approach (at least at our side) when you train classifier or regression model to sort through the parameters of this model to find out the best combination for biggest predict.\r\n\r\nFor example we have some subscription form on our site and we want to maximize subscription conversion.\r\nWe know:\r\n- Current site page info\r\n- Current user info (device and so on)\r\n- Behavior info (session number)\r\n\r\nAlso we can change:\r\n- Form image\r\n- Form CTA text\r\n- Form text\r\n- Discount type\r\n\r\nSo we train binary classification model with site, user and behavior properties + form image, CTA text, form text, discount type properties to understand how different params combination influence on conversion rate.\r\n\r\nWe assume that different properties are related which each other somehow. So if we train 100 models and check weight of used properties we will have different mostly used properties in each model. Because the same variance could be expressed via different properties.\r\n\r\n**Describe the solution you'd like**\r\nIt would be really great to add some option for AutoML experiments to mark properties we mostly prefer to use. Like in this case - form image, CTA text, form text, discount type properties with some specified epsilon of quality we can lose because of that.\r\n\r\n            var settings = new BinaryExperimentSettings()\r\n            {\r\n                OptimizingMetric = BinaryClassificationMetric.AreaUnderRocCurve,\r\n                PreferedPropertiesSettings = new ExperimentPreferedPropertiesSettings \r\n                        {\r\n                                Properties = new [] {\"Prop1\", \"Prop2\"},\r\n                                AcceptableQualityLossInPercent = 5\r\n                        }\r\n            };","Url":"https://github.com/dotnet/machinelearning/issues/6780","RelatedDescription":"Open issue \"Ability to express the maximum variance in the specified properties\" (#6780)"},{"Id":"1827822888","IsPullRequest":false,"CreatedAt":"2023-07-30T06:27:22","Actor":"aarindam10","Number":"6779","RawContent":null,"Title":"Method 'call' in type 'Microsoft.ML.TorchSharp.NasBert.Models.TransformerEncoder' from assembly 'Microsoft.ML.TorchSharp","State":"open","Body":"the bug was reported earlier in following post.\r\nhttps://github.com/dotnet/machinelearning/issues/6665\r\nthough the bug was marked as resolved and closed the thread, but still the issues is there. \r\n\r\nReopening the issue:\r\n----------------------\r\nNow I am using following versions.\r\n PackageReference Include=\"Microsoft.ML\" Version=\"2.0.1\" \r\n PackageReference Include=\"Microsoft.ML.TorchSharp\" Version=\"0.20.1\" \r\n PackageReference Include=\"TorchSharp\" Version=\"0.100.3\" \r\n PackageReference Include=\"TorchSharp-cpu\" Version=\"0.100.3\" \r\n\r\nstill getting following errors\r\n\r\nSystem.TypeLoadException\r\n  HResult=0x80131522\r\n  Message=Method 'call' in type 'Microsoft.ML.TorchSharp.NasBert.Models.TransformerEncoder' from assembly 'Microsoft.ML.TorchSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' does not have an implementation.\r\n  Source=Microsoft.ML.TorchSharp\r\n  StackTrace:\r\n   at Microsoft.ML.TorchSharp.NasBert.NasBertTrainer`2.TrainerBase..ctor(NasBertTrainer`2 parent, IChannel ch, IDataView input)\r\n   at Microsoft.ML.TorchSharp.NasBert.TextClassificationTrainer.Trainer..ctor(NasBertTrainer`2 parent, IChannel ch, IDataView input)\r\n   at Microsoft.ML.TorchSharp.NasBert.TextClassificationTrainer.CreateTrainer(NasBertTrainer`2 parent, IChannel ch, IDataView input)\r\n   at Microsoft.ML.TorchSharp.NasBert.NasBertTrainer`2.Fit(IDataView input)\r\n   at Microsoft.ML.Data.EstimatorChain`1.Fit(IDataView input)\r\n   at Microsoft.ML.Data.EstimatorChain`1.Fit(IDataView input)\r\n   at CustomerReview.CustomerReviewAnalysis.ReviewAnalysis() in F:\\MachineL\\MLNet\\CustomerReviewAnalysis\\CustomerReviewAnalysis.cs:line 80\r\n   at Program.<Main>$(String[] args) in F:\\MachineL\\MLNet\\CustomerReviewAnalysis\\Program.cs:line 6\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6779","RelatedDescription":"Open issue \"Method 'call' in type 'Microsoft.ML.TorchSharp.NasBert.Models.TransformerEncoder' from assembly 'Microsoft.ML.TorchSharp\" (#6779)"},{"Id":"1803340186","IsPullRequest":false,"CreatedAt":"2023-07-28T14:58:04","Actor":"asmirnov82","Number":"6762","RawContent":null,"Title":"Improve DataFrame arithmetic implementation","State":"closed","Body":"The main goals of this Issue are:\r\n\r\n1) To simplify the code related to all Element Wise comparison operations\r\n2) Make consistent return types for all PrimitiveColumnContainer.BinaryOperations\r\n3) To avoid unnecessary memory copying and type conversion \r\n\r\nCurrently all Elementwise comparison operations are defined to have a return type as one of method parameters:\r\n\r\n`void Operation ( ... , PrimitiveColumnContainer<bool> ret);`\r\n\r\nto correctly create this parameter the caller has to the container by himself. In current implementation cloning of the existing column with changing it's type is widely used:\r\n\r\n```\r\nPrimitiveDataFrameColumn<bool> retboolColumn = CloneAsBooleanColumn();\r\n_columnContainer.Operation( ..., retboolColumn._columnContainer);\r\n\r\n```\r\nCloning of column of any type as Boolean Column is error-prone and potentialy may lead to unnecessary memory copying and speed decreasing.\r\n\r\nPossible solution is to  change the signature of all Element Wise internal methods to correctly return required results and to create required objects inside the method, also make consistent retun type of PrimitiveColumnContainer for all PrimitiveColumnContainer.BinaryOperations (currently comparison operations return DataFrameColumn as other operation returns ColumnContainer)\r\n\r\nOnly internal or private method's signatures are proposed to be changed.  Public API should not be affected\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6762","RelatedDescription":"Closed issue \"Improve DataFrame arithmetic implementation\" (#6762)"},{"Id":"1803342928","IsPullRequest":true,"CreatedAt":"2023-07-28T14:58:03","Actor":"asmirnov82","Number":"6763","RawContent":null,"Title":"Improve DataFrame Arithmetics implementation","State":"closed","Body":"Fixes #6762\r\n\r\nFrom the issue:\r\n\r\n> The main goals of this Issue are:\r\n> \r\n> To simplify the code related to all Element Wise comparison operations\r\n> Make consistent return types for all PrimitiveColumnContainer.BinaryOperations\r\n> To avoid unnecessary memory copying and type conversion\r\n> Currently all Elementwise comparison operations are defined to have a return type as one of method parameters:\r\n> \r\n> void Operation ( ... , PrimitiveColumnContainer<bool> ret);\r\n> \r\n> to correctly create this parameter the caller has to the container by himself. In current implementation cloning of the existing column with changing it's type is widely used:\r\n> \r\n> PrimitiveDataFrameColumn<bool> retboolColumn = CloneAsBooleanColumn();\r\n> _columnContainer.Operation( ..., retboolColumn._columnContainer);\r\n> \r\n> Cloning of column of any type as Boolean Column is error-prone and potentialy may lead to unnecessary memory copying and speed decreasing.\r\n> \r\n> Possible solution is to change the signature of all Element Wise internal methods to correctly return required results and to create required objects inside the method, also make consistent retun type of PrimitiveColumnContainer for all PrimitiveColumnContainer.BinaryOperations (currently comparison operations return DataFrameColumn as other operation returns ColumnContainer)\r\n> \r\n> Only internal or private method's signatures are proposed to be changed. Public API should not be affected\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6763","RelatedDescription":"Closed or merged PR \"Improve DataFrame Arithmetics implementation\" (#6763)"},{"Id":"1822764777","IsPullRequest":true,"CreatedAt":"2023-07-28T03:46:14","Actor":"michaelgsharp","Number":"6776","RawContent":null,"Title":"fixed mac build and minor torch sharp changes","State":"closed","Body":"Fixes the mac build issue with the official pipeline.\r\n\r\nAlso adds in specific options classes for SentenceSimilarity and TextClassification so that each can be given their own defaults.","Url":"https://github.com/dotnet/machinelearning/pull/6776","RelatedDescription":"Closed or merged PR \"fixed mac build and minor torch sharp changes\" (#6776)"},{"Id":"1824057406","IsPullRequest":false,"CreatedAt":"2023-07-27T10:12:32","Actor":"TopCat73","Number":"6778","RawContent":null,"Title":" Tensorflow.InvalidArgumentError: Node name contains invalid characters","State":"open","Body":" - OS & Version: [Windows 10] \r\n - ML.NET Version: [ML.NET v2.01]\r\n - .NET Version: [.NET 6.0]\r\n\r\nI have trained a DNN model using TensorFlot.NET (0.110.2) and saved the model to directory on my PC.  I am then attempting to load the saved model using ML.Net.  However, an exception \"Node name contains invalid characters\" is thrown when I attempt to load the saved model using API LoadTensorFlowModel.\r\n\r\nSteps to reproduce :\r\n1. Build a Console App targeting .Net 6.0\r\n2. Using NuGet Package Manager install Microsoft.ML (2.0.1), Microsoft.ML.TensorFlow (2.0.1) and SciSharp.TensorFlow.Redist (2.11.4)\r\n3. Download the attached Zip and extract \r\n4. Call DNNLoader.LoadTensorFlowModel(<filePath>) passing the location of the extracted directory\r\n5. The exception Tensorflow.InvalidArgumentError: 'Node 'dense_2/bias:': Node name contains invalid characters' is thrown\r\n\r\n**Expected **\r\nThe trained model to be loaded\r\n\r\nCode Sample\r\n\r\nusing Microsoft.ML;\r\nusing Microsoft.ML.Data;\r\nusing Microsoft.ML.Transforms;\r\n\r\nnamespace DNNPrediction\r\n{\r\n    internal static class DNNLoader\r\n    {\r\n        internal static void LoadTensorFlowModel(string modelPath)\r\n        {\r\n            MLContext mlContext = new MLContext();\r\n\r\n            TensorFlowModel tensorFlowModel = mlContext.Model.LoadTensorFlowModel(modelPath);\r\n\r\n            DataViewSchema schema = tensorFlowModel.GetModelSchema();\r\n            Console.WriteLine(\" =============== TensorFlow Model Schema =============== \");\r\n            var featuresType = (VectorDataViewType)schema[\"Features\"].Type;\r\n            Console.WriteLine($\"Name: Features, Type: {featuresType.ItemType.RawType}, Size: ({featuresType.Dimensions[0]})\");\r\n            var predictionType = (VectorDataViewType)schema[\"Prediction/Softmax\"].Type;\r\n            Console.WriteLine($\"Name: Prediction/Softmax, Type: {predictionType.ItemType.RawType}, Size: ({predictionType.Dimensions[0]})\");\r\n        }\r\n    }\r\n}\r\n\r\nThe trained model files are here\r\n\r\n[dnn.zip](https://github.com/dotnet/machinelearning/files/12181963/dnn.zip)\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6778","RelatedDescription":"Open issue \" Tensorflow.InvalidArgumentError: Node name contains invalid characters\" (#6778)"},{"Id":"1821469414","IsPullRequest":false,"CreatedAt":"2023-07-27T03:19:15","Actor":"RockNHawk","Number":"6774","RawContent":null,"Title":" IDataView.GetColumn throw exception Splitter/consolidator worker encountered exception while consuming source data","State":"closed","Body":"**System Information (please complete the following information):**\r\n - OS & Version: Windows 10\r\n<PackageReference Include=\"Microsoft.ML\" Version=\"3.0.0-preview.23266.6\" />\r\n<PackageReference Include=\"Microsoft.ML.OnnxRuntime\" Version=\"1.15.1\" />\r\n<PackageReference Include=\"Microsoft.ML.OnnxTransformer\" Version=\"3.0.0-preview.23266.6\" />\r\n\r\n**Describe the bug**\r\nThe single prediction is OK, but multiple predictions throw error when call IDataView.GetColumn<T>().ToArray()\r\n\r\n**Screenshots, Code, Sample Projects**\r\n\r\n    IEnumerable<TextEmbeddingResult> DoBulkGenerateTextEmbedding(IList<StringFragment> texts)\r\n    {\r\n        var tokenizer = _tokenizer.GetTokenizer();\r\n        var bulkSize = texts.Count;\r\n\r\n        var inputs = InputDataArray(texts, tokenizer).ToArray();\r\n        var maxSize = inputs.Max(x => x.InputIds.Length);\r\n        Shape shape = ShapeFactory.CreateShape(batchSize: texts.Count, maxSize);\r\n\r\n\r\n\r\n            BatchSize = batchSize;\r\n            MaxLength = maxLength;\r\n\r\n  \r\n\r\n          var shapeDictionary = new Dictionary<string, int[]>\r\n            {\r\n                { ColumnNames.Input.InputIds,  new[] { 1, maxSize }},\r\n                { ColumnNames.Input.AttentionMask,  new[] { 1, maxSize}},\r\n                { ColumnNames.Output.LastHiddenState,  new[] { 1, maxSize, EmbeddingConst.TokenResultDim }},\r\n            };\r\n\r\n        MLContext context = new MLContext();\r\n        bool useGpu = false;\r\n        OnnxScoringEstimator pipeline = context.Transforms.ApplyOnnxModel(\r\n            modelFile: _modelInfo.ModelPath,\r\n            shapeDictionary: shapeDictionary,\r\n            inputColumnNames: new[] { ColumnNames.Input.InputIds, ColumnNames.Input.AttentionMask, },\r\n            outputColumnNames: new[] { ColumnNames.Output.LastHiddenState, },\r\n            gpuDeviceId: useGpu ? 0 : (int?)null,\r\n            fallbackToCpu: true\r\n        );\r\n\r\n\r\n        var trainingDataView = context.Data.LoadFromEnumerable(inputs);\r\n\r\n        using var transformer = pipeline.Fit(trainingDataView);\r\n\r\n        var predictions = transformer.Transform(trainingDataView);\r\n        // data type (name: last_hidden_state, type: Vector<Single, 2, 29, 768>) in data to the user-defined type, System.Single. (Parameter 'column')\r\n        var outputColumn = predictions.Schema[ColumnNames.Output.LastHiddenState];\r\n\r\n        var output = predictions.GetColumn<Microsoft.ML.Data.VBuffer<float>>(ColumnNames.Output.LastHiddenState);\r\n\r\n        // Convert the VBuffer<float> to a float array\r\n\r\n        /*\r\noutput.ToArray()  throw Exception\r\nSplitter/consolidator worker encountered exception while consuming source data\r\n\r\n.InnerException: System.ArgumentOutOfRangeException:\r\nIndex was out of range. Must be non-negative and less than the size of the collection. (Parameter 'index')\r\nat System.Collections.Generic.List1.set_Item(Int32 index, T value) at Microsoft.ML.Transforms.Onnx.OnnxTransformer.Mapper.NamedOnnxValueGetterVec1.GetNamedOnnxValueUnknownSize()\r\nat Microsoft.ML.Transforms.Onnx.OnnxTransformer.Mapper.NamedOnnxValueGetterVec1.GetNamedOnnxValue() at Microsoft.ML.Transforms.Onnx.OnnxTransformer.Mapper.UpdateCacheIfNeeded(Int64 position, INamedOnnxValueGetter[] srcNamedOnnxValueGetters, List1 activeOutputColNames, OnnxRuntimeOutputCacher outputCache)\r\nat Microsoft.ML.Transforms.Onnx.OnnxTransformer.Mapper.<>c__DisplayClass14_01.<MakeTensorGetter>b__0(VBuffer1& dst)\r\nat Microsoft.ML.Data.DataViewUtils.Splitter.InPipe.Impl`1.Fill()\r\nat Microsoft.ML.Data.DataViewUtils.Splitter.<>c__DisplayClass7_1.b__2()\r\n*/\r\n        var outputVectorGroups = output.ToArray();\r\n\r\n        float[] outputMergedVectors = outputVectorGroups.SelectMany(x => x.DenseValues()).ToArray();\r\n\r\n        var sentenceEmbeddings = SentenceEmbeddingUtility.BulkToSentenceEmbeddings(\r\n            new EmbeddingContext(bulkSize, maxSize, EmbeddingConst.TokenResultDim, outputMergedVectors, _dense)\r\n            //,inputData.AttentionMask\r\n        );\r\n\r\n        int i = 0;\r\n        foreach (var vectors in sentenceEmbeddings)\r\n        {\r\n            var text = texts[i];\r\n            yield return new(text, vectors);\r\n            i++;\r\n        }\r\n    }\r\n\r\n![image](https://github.com/dotnet/machinelearning/assets/3222379/d1addbec-04cc-4ebd-b301-1e16e204ec5e)\r\n\r\n**Additional context**\r\nThe single prediction is OK.\r\n`\r\nusing var predictionEngine = context.Model.CreatePredictionEngine<InputData, OutputData>(transformer, inputSchemaDefinition: inputSchemaDef, outputSchemaDefinition: outputSchemaDef);\r\n\r\nvar prediction = predictionEngine.Predict(inputData);\r\n`\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6774","RelatedDescription":"Closed issue \" IDataView.GetColumn throw exception Splitter/consolidator worker encountered exception while consuming source data\" (#6774)"},{"Id":"1822946818","IsPullRequest":false,"CreatedAt":"2023-07-26T18:29:38","Actor":"luisquintanilla","Number":"6777","RawContent":null,"Title":"Ignore Columns ColumnInference","State":"open","Body":"When using `InferColumns`, there is now way to specify which columns to exclude.\r\n\r\n```csharp\r\n// Define data path\r\nvar dataPath = Path.GetFullPath(@\"../Data/issues_train.tsv\");\r\n\r\n// Infer column information\r\nColumnInferenceResults columnInference =\r\n    ctx.Auto().InferColumns(dataPath, separatorChar: '\\t', labelColumnName: \"Area\", groupColumns: false);\r\n```\r\n\r\nThat means that you have to do it manually.\r\n\r\n```csharp\r\nvar columnsToExclude = new[]{\"ID\",\"Title\"};\r\n\r\ncolumnInference.TextLoaderOptions.Columns = \r\n    columnInference.TextLoaderOptions.Columns\r\n        .Where(col => !columnsToExclude.Contains(col.Name)).ToArray();\r\n\r\ncolumnInference.ColumnInformation.NumericColumnNames.Remove(\"ID\");\r\ncolumnInference.ColumnInformation.TextColumnNames.Remove(\"Title\");\r\n```\r\n\r\nSince the TextLoaderOptions and ColumnInformation are used downstream\r\n\r\n```csharp\r\n// Create text loader\r\nTextLoader loader = ctx.Data.CreateTextLoader(columnInference.TextLoaderOptions);\r\n\r\n// Load data into IDataView\r\nIDataView data = loader.Load(dataPath);\r\n\r\nSweepablePipeline pipeline =\r\n    ctx.Auto().Featurizer(data, columnInformation: columnInference.ColumnInformation)\r\n        .Append(ctx.Transforms.Conversion.MapValueToKey(columnInference.ColumnInformation.LabelColumnName))\r\n        .Append(ctx.Auto().MultiClassification(labelColumnName: columnInference.ColumnInformation.LabelColumnName))\r\n        .Append(ctx.Transforms.Conversion.MapKeyToValue(\"PredictedLabel\"));\r\n```\r\n\r\nIn the InferColumns API, it might be the best place to set this value","Url":"https://github.com/dotnet/machinelearning/issues/6777","RelatedDescription":"Open issue \"Ignore Columns ColumnInference\" (#6777)"},{"Id":"1821740269","IsPullRequest":false,"CreatedAt":"2023-07-26T07:15:43","Actor":"RockNHawk","Number":"6775","RawContent":null,"Title":"Cannot access internal method 'MLContext.CancelExecution()' ","State":"open","Body":"I have a memory leak issue, and find this similar issue, but `CancelExecution` in internal.\r\n\r\n[BestFriend]\r\ninternal void CancelExecution() => ((ICancelable) this._env).CancelExecution();\r\n\r\n\r\nfull code\r\n\r\n        MLContext context = new MLContext();\r\n        bool useGpu = false;\r\n        OnnxScoringEstimator pipeline = context.Transforms.ApplyOnnxModel(\r\n            modelFile: _modelInfo.ModelPath,\r\n            shapeDictionary: shape.ToDictionary(),\r\n            inputColumnNames: new[] { ColumnNames.Input.InputIds, ColumnNames.Input.AttentionMask, },\r\n            outputColumnNames: new[] { ColumnNames.Output.LastHiddenState, },\r\n            gpuDeviceId: useGpu ? 0 : (int?)null,\r\n            fallbackToCpu: true\r\n        );\r\n\r\n        var inputSchemaDef = ToInputSchemaDefinition<InputData>(shape);\r\n        var trainingDataView = context.Data.LoadFromEnumerable(new List<InputData>() { }, inputSchemaDef);\r\n        using var transformer = pipeline.Fit(trainingDataView);\r\n\r\n        var outputSchemaDef = ToOutputSchemaDefinition<OutputData>(shape);\r\n        using var predictionEngine = context.Model.CreatePredictionEngine<InputData, OutputData>(transformer, inputSchemaDefinition: inputSchemaDef, outputSchemaDefinition: outputSchemaDef);\r\n        var predictionResult = predictionEngine.Predict(inputData);\r\n\r\n\r\n@fischja It could be the last trial still running even after automl experiment times out, could you try cancelling context and run again\r\n\r\n```csharp\r\nfor (int i = 0; i < 5; i++)\r\n{\r\n    MLContext ml = new MLContext();\r\n\r\n    List<MyData> trainingDataList = Enumerable.Range(0, 10000).Select(x => new MyData()).ToList();\r\n    IDataView trainingData = ml.Data.LoadFromEnumerable(trainingDataList);\r\n\r\n    var result = ml\r\n        .Auto()\r\n        .CreateRegressionExperiment(maxExperimentTimeInSeconds: 20)\r\n        .Execute(trainData: trainingData, numberOfCVFolds: 3, labelColumnName: \"Y\");\r\n\r\n    ml.CancelExecution();\r\n}\r\n```\r\n\r\n_Originally posted by @LittleLittleCloud in https://github.com/dotnet/machinelearning/issues/6188#issuecomment-1121407624_\r\n            ","Url":"https://github.com/dotnet/machinelearning/issues/6775","RelatedDescription":"Open issue \"Cannot access internal method 'MLContext.CancelExecution()' \" (#6775)"},{"Id":"1819780883","IsPullRequest":false,"CreatedAt":"2023-07-25T08:07:41","Actor":"xpt5","Number":"6773","RawContent":null,"Title":"Dataframe.LoadCsv() throwing exception","State":"open","Body":"**System Information (please complete the following information):**\r\n - OS & Version: Windows 10 Pro \r\n - Microsfot.Data.Analysis: v0.22.1\r\n - .NET Version: .NET 6.0\r\n\r\n**Describe the bug**\r\nI am having the same problem as reported on #5647. The input is the same since I created a csv file with same text and the exception thrown when running the code below is also the same.\r\n\r\n```\r\nSystem.FormatException\r\n  HResult=0x80131537\r\n  Message=Line 1 has less columns than expected\r\n  Source=Microsoft.Data.Analysis\r\n  StackTrace:\r\n   at Microsoft.Data.Analysis.DataFrame.GuessKind(Int32 col, List`1 read)\r\n   at Microsoft.Data.Analysis.DataFrame.ReadCsvLinesIntoDataFrame(WrappedStreamReaderOrStringReader wrappedReader, Char separator, Boolean header, String[] columnNames, Type[] dataTypes, Int64 numberOfRowsToRead, Int32 guessRows, Boolean addIndexColumn)\r\n   at Microsoft.Data.Analysis.DataFrame.LoadCsv(String filename, Char separator, Boolean header, String[] columnNames, Type[] dataTypes, Int32 numRows, Int32 guessRows, Boolean addIndexColumn, Encoding encoding)\r\n   at KeynotesPackagesTest.DataAnalysis.OpenCsvAndExportData(String csvFilePath, String textFile) in C:\\Users\\<user>\\source\\repos\\KeynotesPackagesTest\\KeynotesPackagesTest\\DataAnalysis.cs:line 102\r\n   at Program.<Main>$(String[] args) in C:\\Users\\<user>\\source\\repos\\KeynotesPackagesTest\\KeynotesPackagesTest\\Program.cs:line 35\r\n```\r\n\r\n**Expected behavior**\r\nReading the .csv file without issues\r\n\r\n**Code**\r\n\r\n```\r\n\r\n        public static void OpenCsvAndExportData(string csvFilePath, string textFile)\r\n        {\r\n            var data = DataFrame.LoadCsv(csvFilePath, separator: ',');\r\n```\r\n\r\nAnd then I cal the method from Program.cs\r\nI hope I am not overseeing something basic since I am very new to the c# language.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6773","RelatedDescription":"Open issue \"Dataframe.LoadCsv() throwing exception\" (#6773)"},{"Id":"1812591396","IsPullRequest":true,"CreatedAt":"2023-07-24T22:23:09","Actor":"LittleLittleCloud","Number":"6768","RawContent":null,"Title":"fix issue #2718 from model builder","State":"closed","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [x] There's a descriptive title that will make sense to other developers some time from now. \r\n- [x] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [ ] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\n\r\nfix https://github.com/dotnet/machinelearning-modelbuilder/issues/2718\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6768","RelatedDescription":"Closed or merged PR \"fix issue #2718 from model builder\" (#6768)"},{"Id":"1797020799","IsPullRequest":true,"CreatedAt":"2023-07-24T19:47:24","Actor":"michaelgsharp","Number":"6760","RawContent":null,"Title":"Add NameEntityRecognition and Q&A deep learning tasks.","State":"closed","Body":"This PR adds in 2 new deep learning scenarios, Name Entity Recognition and Q&A.\r\n\r\nThe main files to focus on are NerTrainer.cs and Roberta/QATrainer.cs. Most of the rest are either part of the deep learning model itself or internal implementations of things I had to copy over from runtime for them to work on netstandard.","Url":"https://github.com/dotnet/machinelearning/pull/6760","RelatedDescription":"Closed or merged PR \"Add NameEntityRecognition and Q&A deep learning tasks.\" (#6760)"},{"Id":"1818465370","IsPullRequest":true,"CreatedAt":"2023-07-24T13:46:24","Actor":"asmirnov82","Number":"6772","RawContent":null,"Title":"Fix DataFrame.LoadCsv can not load CSV with duplicate column names","State":"open","Body":"Fixes #6182 \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6772","RelatedDescription":"Open PR \"Fix DataFrame.LoadCsv can not load CSV with duplicate column names\" (#6772)"},{"Id":"1816933459","IsPullRequest":false,"CreatedAt":"2023-07-23T00:15:20","Actor":"MIAIONE","Number":"6771","RawContent":null,"Title":"[feature] some suggestions...","State":"open","Body":"Hello! This is a feature suggestion. \r\n\r\n1. It seems that there are no relevant models for generative AI in ML.NET. It always frustrates me when I try to generate what I want, and I have to load external models through ONNX to achieve my needs. However, this is not perfect. In many cases, I can only use existing models and do not have the conditions to try training a Python ONNX model myself. I hope that ML.NET can provide some necessary generative AI basic algorithms and AUTOML templates, which may not directly achieve the goal, but can indirectly implement upper-level complex functions (such as GAN), which can lay a solid foundation for the subsequent ML.NET community ecology. \r\n\r\n2. It seems that ML.NET's AutoML does not provide model continuation training. When I replace new data with the same input format, retraining will start from scratch, which makes it very easy to lose the existing excellent model without backing up the previous model (I personally think that training models is like opening a blind box). It is particularly important to retain the previous training results. As a backup, renaming by date can be used instead of direct overwriting.","Url":"https://github.com/dotnet/machinelearning/issues/6771","RelatedDescription":"Open issue \"[feature] some suggestions...\" (#6771)"},{"Id":"1813643254","IsPullRequest":true,"CreatedAt":"2023-07-20T10:16:58","Actor":"asmirnov82","Number":"6770","RawContent":null,"Title":"Fix inconsistent null handling in DataFrame Arithmetics","State":"open","Body":"Fixes #5650 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/6770","RelatedDescription":"Open PR \"Fix inconsistent null handling in DataFrame Arithmetics\" (#6770)"},{"Id":"1813484022","IsPullRequest":true,"CreatedAt":"2023-07-20T08:46:15","Actor":"asmirnov82","Number":"6769","RawContent":null,"Title":"Fix issue with addIndexColumn in DataFrame.LoadCsv","State":"open","Body":"Fixes #5968 \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6769","RelatedDescription":"Open PR \"Fix issue with addIndexColumn in DataFrame.LoadCsv\" (#6769)"},{"Id":"1809930285","IsPullRequest":false,"CreatedAt":"2023-07-18T13:22:55","Actor":"superichmann","Number":"6767","RawContent":null,"Title":"IDataView Filtering does not Improve Performence","State":"open","Body":"I am performing 40 regression experiments (`parallel.foreach`) on a database table by filtering with different column values.\r\n\r\nWhen I SELECT the data directly from the database for each experiment the whole process takes 38 seconds.\r\nWhen I take the data from the database one time, cache it and use `SkipRows` and `TakeRows` for filtering each experiment it takes 42 seconds.\r\n\r\nFrom my standpoint the second method should produce better performance but the opposite occurs. can you please instruct me on how to use `SkipRows` and `TakeRows` in a way which will actually improve my overall performance?","Url":"https://github.com/dotnet/machinelearning/issues/6767","RelatedDescription":"Open issue \"IDataView Filtering does not Improve Performence\" (#6767)"},{"Id":"1809795496","IsPullRequest":true,"CreatedAt":"2023-07-18T12:07:48","Actor":"Lehonti","Number":"6766","RawContent":null,"Title":"Modernized some argument checks that still used string literals for parameter names","State":"open","Body":"No changes in behavior, just leveraging more modern syntax","Url":"https://github.com/dotnet/machinelearning/pull/6766","RelatedDescription":"Open PR \"Modernized some argument checks that still used string literals for parameter names\" (#6766)"},{"Id":"1807116516","IsPullRequest":false,"CreatedAt":"2023-07-17T06:57:21","Actor":"Sapana-Khemkar","Number":"6765","RawContent":null,"Title":"testing ML.NET on ppc64le architeecture","State":"open","Body":"I am trying to build ML.NET for ppc64le and run test suite.\r\nI have gone through [this](https://github.com/dotnet/machinelearning/blob/main/docs/building/unix-instructions.md)\r\nI tried first cross build as explained for arm and generated artifacts folder for ppc64le on x86 machine and then moved artifacts folder to ppc64le machine. But I cannot use `./build.sh --test` command to run tests. Hence tried using dotnet test command as below\r\n```\r\ncd bin/Microsoft.ML.Tests/Release/net7.0 \r\ndotnet test Microsoft.ML.Tests.dll\r\n```\r\nBut almost all tests failed with below error:\r\n```\r\nError Message: System.TypeInitializationException : The type initializer for 'Microsoft.ML.TestFramework.BaseTestClass' threw an exception. ---- System.NullReferenceException : Object reference not set to an instance of an object Stack Trace: at Microsoft.ML.RunTests.BaseTestBaseline..ctor(ITestOutputHelper output) in /root/sapana/machinelearning/test/Microsoft.ML.TestFramework/BaseTestBaseline.cs:line 31 at Microsoft.ML.RunTests.TestDataViewBase..ctor(ITestOutputHelper helper) in /root/sapana/machinelearning/test/Microsoft.ML.TestFramework/TestInitialization.cs:line 107 at Microsoft.ML.RunTests.TestDataPipeBase..ctor(ITestOutputHelper helper) in /root/sapana/machinelearning/test/Microsoft.ML.TestFramework/TestInitialization.cs:line 59 at Microsoft.ML.Tests.Transformers.CountTargetEncodingTests..ctor(ITestOutputHelper output) in /root/sapana/machinelearning/test/Microsoft.ML.Tests/Transformers/CountTargetEncodingTests.cs:line 17 at System.Reflection.ConstructorInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr) ----- Inner Stack Trace ----- at Microsoft.ML.TestFrameworkCommon.TestCommon.GetRepoRoot() in /root/sapana/machinelearning/test/Microsoft.ML.TestFrameworkCommon/TestCommon.cs:line 78 at Microsoft.ML.TestFramework.BaseTestClass..cctor() in /root/sapana/machinelearning/test/Microsoft.ML.TestFramework/BaseTestClass.cs:line 40 Failed Microsoft.ML.Tests.Transformers.CountTargetEncodingTests.TestSaveAndLoadExternalCountsMultipleColumns [1 ms]\r\n```\r\n\r\nI have tried to build natively on ppc64le machine with ubuntu 20.04. I have added ppc64le arch in makefile/project files (by referring arm arch). But I am getting warning as below and build failing after that due to code not generated as expected\r\n```\r\nCSC : warning CS8785: Generator 'EstimatorTypeGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'TypeLoadException' with message 'Could not set up parent class, due to: Could not load type of field 'Microsoft.ML.AutoML.SourceGenerator.Template.EstimatorTypeBase:errorsField' (1) due to: Could not load file or assembly 'System.CodeDom, Version=4.0.1.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies.\r\n```\r\nCan someone help me how can I tests machinelearning repo on ppc64le? If cross build is right way then how to run tests on cross built artifacts?\r\n\r\nPlease Note: If I directly add ML.NET package reference and run basic sample on ppc64le machine it works. But I want to run all test cases and list down supported/not supported features.\r\n\r\nThanks in advance.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6765","RelatedDescription":"Open issue \"testing ML.NET on ppc64le architeecture\" (#6765)"},{"Id":"1806413829","IsPullRequest":false,"CreatedAt":"2023-07-16T03:31:54","Actor":"minhthien711","Number":"6764","RawContent":null,"Title":"System.ArgumentOutOfRangeException: 'Could not determine an IDataView type and registered custom types for member Image Parameter name: rawType'","State":"open","Body":"Can you help me ? i can't run code when i update to version 2.0\r\nI use sample download it's : https://github.com/jwood803/MLNET_ObjectDetection_WinForms/tree/main/MLNET_ObjectDetection_WinForms\r\n\r\nDo you help me update sample to ver 2.0 ! \r\n\r\n\r\n.Because row \"var data = context.Data.LoadFromEnumerable(emptyData);\" show issuse \" \"System.ArgumentOutOfRangeException: 'Could not determine an IDataView type and registered custom types for member Image\r\nParameter name: rawType' \"\r\n\r\n\r\n`using Microsoft.ML;\r\nusing Microsoft.ML.Transforms.Image;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Data;\r\nusing System.Drawing;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading.Tasks;\r\nusing System.Windows.Forms;\r\nusing Microsoft.ML.Data;\r\nusing MLNET_ObjectDetection_WinForms.Models;\r\n\r\nnamespace MLNET_ObjectDetection_WinForms\r\n{\r\n    public partial class Form1 : Form\r\n    {\r\n        public const int rowCount = 13, columnCount = 13;\r\n        public const int featuresPerBox = 5;\r\n        private readonly string[] classLabels;\r\n\r\n        private static readonly (float x, float y)[] Anchors = { (0.573f, 0.677f), (1.87f, 2.06f), (3.34f, 5.47f), (7.88f, 3.53f), (9.77f, 9.17f) };\r\n\r\n        private PredictionEngine<ModelInput, ModelOutput> _predictionEngine;\r\n\r\n        string ProjectLocation = Path.GetDirectoryName(Path.GetDirectoryName(System.IO.Directory.GetCurrentDirectory()));\r\n\r\n        public Form1()\r\n        {\r\n            InitializeComponent();\r\n\r\n            picPrediction.Visible = false;\r\n            btnNewPrediction.Visible = false;\r\n\r\n           MLContext context = new MLContext();\r\n            var emptyData = new List<ModelInput>();\r\n\r\n            var data = context.Data.LoadFromEnumerable(emptyData);\r\n\r\n        //   var schema = SchemaDefinition.Create(typeof(ModelInput));\r\n         //   var schemaData = context.Transforms.SelectColumns(nameof(ModelInput.Image)).Transform(data);\r\n\r\n            string pathModel = ProjectLocation + @\"\\MLModel\\model.onnx\";\r\n\r\n            var pipeline = context.Transforms.ResizeImages(resizing: ImageResizingEstimator.ResizingKind.Fill, outputColumnName: \"data\", imageWidth: ImageSettings.imageWidth, imageHeight: ImageSettings.imageHeight, inputColumnName: nameof(ModelInput.Image))\r\n                            .Append(context.Transforms.ExtractPixels(outputColumnName: \"data\"))\r\n                            .Append(context.Transforms.ApplyOnnxModel(modelFile: pathModel, outputColumnName: \"model_outputs0\", inputColumnName: \"data\"));\r\n\r\n            var model = pipeline.Fit(data);\r\n\r\n            _predictionEngine = context.Model.CreatePredictionEngine<ModelInput, ModelOutput>(model);\r\n        }\r\n\r\n        private void btnSelectImage_Click(object sender, EventArgs e)\r\n        {\r\n            string pathText = ProjectLocation + @\"\\MLModel\\labels.txt\";\r\n            if (fileDialog.ShowDialog() == DialogResult.OK)\r\n            {\r\n                var image = (Bitmap)Image.FromFile(fileDialog.FileName);\r\n\r\n                var prediction = _predictionEngine.Predict(new ModelInput { Image = image });\r\n\r\n                var labels = File.ReadAllLines(pathText);\r\n\r\n                var boundingBoxes = ParseOutputs(prediction.WineType, labels);\r\n\r\n                var originalWidth = image.Width;\r\n                var originalHeight = image.Height;\r\n\r\n                if (boundingBoxes.Count > 0)\r\n                {\r\n                    var filteredBoxes = FilterBoundingBoxes(boundingBoxes, 2, 0.5f);\r\n\r\n                    boundingBoxes.Clear();\r\n                    boundingBoxes.AddRange(filteredBoxes);\r\n                }\r\n                else\r\n                {\r\n                    MessageBox.Show(\"Hình ảnh chưa được cung cấp nhận dạng trước trong file model.onnx, vui lòng thêm ảnh vào để nhận dạng!!\");\r\n                    return;\r\n                }\r\n\r\n                foreach (var boundingBox in boundingBoxes)\r\n                {\r\n                    float x = Math.Max(boundingBox.Dimensions.X, 0);\r\n                    float y = Math.Max(boundingBox.Dimensions.Y, 0);\r\n                    float width = Math.Min(originalWidth - x, boundingBox.Dimensions.Width);\r\n                    float height = Math.Min(originalHeight - y, boundingBox.Dimensions.Height);\r\n\r\n                    // fit to current image size\r\n                    x = originalWidth * x / ImageSettings.imageWidth;\r\n                    y = originalHeight * y / ImageSettings.imageHeight;\r\n                    width = originalWidth * width / ImageSettings.imageWidth;\r\n                    height = originalHeight * height / ImageSettings.imageHeight;\r\n\r\n                    using (var graphics = Graphics.FromImage(image))\r\n                    {\r\n                        graphics.DrawRectangle(new Pen(boundingBox.BoxColor, 3), x, y, width, height);\r\n                        graphics.DrawString(boundingBox.Description, new Font(FontFamily.Families[0], 30f), Brushes.Red, x + 5, y + 5);\r\n                    }\r\n                }\r\n\r\n                picPrediction.Image = image;\r\n                picPrediction.SizeMode = PictureBoxSizeMode.StretchImage;\r\n                picPrediction.Visible = true;\r\n                btnSelectImage.Visible = false;\r\n                btnNewPrediction.Visible = true;\r\n            }\r\n        }\r\n\r\n        public static List<BoundingBox> ParseOutputs(float[] modelOutput, string[] labels, float probabilityThreshold = .2f)\r\n        {\r\n            var boxes = new List<BoundingBox>();\r\n\r\n            for (int row = 0; row < rowCount; row++)\r\n            {\r\n                for (int column = 0; column < columnCount; column++)\r\n                {\r\n                    for (int box = 0; box < Anchors.Length; box++)\r\n                    {\r\n                        var channel = box * (labels.Length + featuresPerBox);\r\n\r\n                        var boundingBoxPrediction = ExtractBoundingBoxPrediction(modelOutput, row, column, channel);\r\n\r\n                        var mappedBoundingBox = MapBoundingBoxToCell(row, column, box, boundingBoxPrediction);\r\n\r\n                        if (boundingBoxPrediction.Confidence < probabilityThreshold)\r\n                            continue;\r\n\r\n                        float[] classProbabilities = ExtractClassProbabilities(modelOutput, row, column, channel, boundingBoxPrediction.Confidence, labels);\r\n\r\n                        var (topProbability, topIndex) = classProbabilities.Select((probability, index) => (Score: probability, Index: index)).Max();\r\n\r\n                        if (topProbability < probabilityThreshold)\r\n                            continue;\r\n\r\n                        boxes.Add(new BoundingBox\r\n                        {\r\n                            Dimensions = mappedBoundingBox,\r\n                            Confidence = topProbability,\r\n                            Label = labels[topIndex],\r\n                            BoxColor = BoundingBox.GetColor(topIndex)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return boxes;\r\n        }\r\n\r\n        public List<BoundingBox> FilterBoundingBoxes(List<BoundingBox> boxes, int limit, float iouThreshold)\r\n        {\r\n            var results = new List<BoundingBox>();\r\n            var filteredBoxes = new bool[boxes.Count];\r\n            var sortedBoxes = boxes.OrderByDescending(b => b.Confidence).ToArray();\r\n\r\n            for (int i = 0; i < boxes.Count; i++)\r\n            {\r\n                if (filteredBoxes[i])\r\n                    continue;\r\n\r\n                results.Add(sortedBoxes[i]);\r\n\r\n                if (results.Count >= limit)\r\n                    break;\r\n\r\n                for (var j = i + 1; j < boxes.Count; j++)\r\n                {\r\n                    if (filteredBoxes[j])\r\n                        continue;\r\n\r\n                    if (IntersectionOverUnion(sortedBoxes[i].Rect, sortedBoxes[j].Rect) > iouThreshold)\r\n                        filteredBoxes[j] = true;\r\n\r\n                    if (filteredBoxes.Count(b => b) <= 0)\r\n                        break;\r\n                }\r\n            }\r\n            return results;\r\n        }\r\n\r\n        private static BoundingBoxDimensions MapBoundingBoxToCell(int row, int column, int box, BoundingBoxPrediction boxDimensions)\r\n        {\r\n            const float cellWidth = ImageSettings.imageWidth / columnCount;\r\n            const float cellHeight = ImageSettings.imageHeight / rowCount;\r\n\r\n            var mappedBox = new BoundingBoxDimensions\r\n            {\r\n                X = (row + Sigmoid(boxDimensions.X)) * cellWidth,\r\n                Y = (column + Sigmoid(boxDimensions.Y)) * cellHeight,\r\n                Width = (float)Math.Exp(boxDimensions.Width) * cellWidth * Anchors[box].x,\r\n                Height = (float)Math.Exp(boxDimensions.Height) * cellHeight * Anchors[box].y,\r\n            };\r\n\r\n            // The x,y coordinates from the (mapped) bounding box prediction represent the center\r\n            // of the bounding box. We adjust them here to represent the top left corner.\r\n            mappedBox.X -= mappedBox.Width / 2;\r\n            mappedBox.Y -= mappedBox.Height / 2;\r\n\r\n            return mappedBox;\r\n        }\r\n\r\n        private static BoundingBoxPrediction ExtractBoundingBoxPrediction(float[] modelOutput, int row, int column, int channel)\r\n        {\r\n            return new BoundingBoxPrediction\r\n            {\r\n                X = modelOutput[GetOffset(row, column, channel++)],\r\n                Y = modelOutput[GetOffset(row, column, channel++)],\r\n                Width = modelOutput[GetOffset(row, column, channel++)],\r\n                Height = modelOutput[GetOffset(row, column, channel++)],\r\n                Confidence = Sigmoid(modelOutput[GetOffset(row, column, channel++)])\r\n            };\r\n        }\r\n\r\n        private float IntersectionOverUnion(RectangleF boundingBoxA, RectangleF boundingBoxB)\r\n        {\r\n            var areaA = boundingBoxA.Width * boundingBoxA.Height;\r\n            var areaB = boundingBoxB.Width * boundingBoxB.Height;\r\n\r\n            if (areaA <= 0 || areaB <= 0)\r\n                return 0;\r\n\r\n            var minX = (float)Math.Max(boundingBoxA.Left, boundingBoxB.Left);\r\n            var minY = (float)Math.Max(boundingBoxA.Top, boundingBoxB.Top);\r\n            var maxX = (float)Math.Min(boundingBoxA.Right, boundingBoxB.Right);\r\n            var maxY = (float)Math.Min(boundingBoxA.Bottom, boundingBoxB.Bottom);\r\n            var intersectionArea = (float)Math.Max(maxY - minY, 0) * (float)Math.Max(maxX - minX, 0);\r\n\r\n            return intersectionArea / (areaA + areaB - intersectionArea);\r\n        }\r\n\r\n        public static float[] ExtractClassProbabilities(float[] modelOutput, int row, int column, int channel, float confidence, string[] labels)\r\n        {\r\n            var classProbabilitiesOffset = channel + featuresPerBox;\r\n            float[] classProbabilities = new float[labels.Length];\r\n            for (int classProbability = 0; classProbability < labels.Length; classProbability++)\r\n                classProbabilities[classProbability] = modelOutput[GetOffset(row, column, classProbability + classProbabilitiesOffset)];\r\n            return Softmax(classProbabilities).Select(p => p * confidence).ToArray();\r\n        }\r\n\r\n        private static float Sigmoid(float value)\r\n        {\r\n            var k = (float)Math.Exp(value);\r\n            return k / (0.5f + k);\r\n        }\r\n\r\n        private static float[] Softmax(float[] classProbabilities)\r\n        {\r\n            var max = classProbabilities.Max();\r\n            var exp = classProbabilities.Select(v => Math.Exp(v - max));\r\n            var sum = exp.Sum();\r\n            return exp.Select(v => (float)v / (float)sum).ToArray();\r\n        }\r\n\r\n        private void btnNewPrediction_Click(object sender, EventArgs e)\r\n        {\r\n            btnNewPrediction.Visible = false;\r\n            picPrediction.Visible = false;\r\n            btnSelectImage.Visible = true;\r\n        }\r\n\r\n        private void Form1_Load(object sender, EventArgs e)\r\n        {\r\n            // size 108,37\r\n            // location 383, 106\r\n            btnNewPrediction.Size = new Size(108, 37);\r\n            btnNewPrediction.Location = new Point(383, 106);\r\n            btnNewPrediction.BackColor = Color.LightGreen;\r\n\r\n            btnSelectImage.Size = new Size(108, 37);\r\n            btnSelectImage.Location = new Point(383, 106);\r\n            btnSelectImage.BackColor = Color.LightGreen;\r\n            btnSelectImage.Text = \"Chọn ảnh\";\r\n        }\r\n\r\n        private static int GetOffset(int row, int column, int channel)\r\n        {\r\n            const int channelStride = rowCount * columnCount;\r\n            return (channel * channelStride) + (column * columnCount) + row;\r\n        }\r\n    }\r\n\r\n\r\n    class BoundingBoxPrediction : BoundingBoxDimensions\r\n    {\r\n        public float Confidence { get; set; }\r\n    }\r\n}\r\n\r\n`","Url":"https://github.com/dotnet/machinelearning/issues/6764","RelatedDescription":"Open issue \"System.ArgumentOutOfRangeException: 'Could not determine an IDataView type and registered custom types for member Image Parameter name: rawType'\" (#6764)"},{"Id":"1784870832","IsPullRequest":false,"CreatedAt":"2023-07-11T20:07:59","Actor":"nodakai","Number":"6754","RawContent":null,"Title":"Microsoft.Data.Analysis: meaningless lines of code?","State":"closed","Body":"https://github.com/dotnet/machinelearning/blob/4c799ab1c881de54328fdafbfcfc5352bd727e89/src/Microsoft.Data.Analysis/DataFrame.IO.cs#L132\r\n\r\nThe inner loop seems to be meaningless\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/4c799ab1c881de54328fdafbfcfc5352bd727e89/src/Microsoft.Data.Analysis/PrimitiveColumnContainer.cs#L36\r\n\r\nIsn't the list guaranteed to be empty here within a ctor?","Url":"https://github.com/dotnet/machinelearning/issues/6754","RelatedDescription":"Closed issue \"Microsoft.Data.Analysis: meaningless lines of code?\" (#6754)"},{"Id":"1798653916","IsPullRequest":true,"CreatedAt":"2023-07-11T20:07:58","Actor":"asmirnov82","Number":"6761","RawContent":null,"Title":"Clean DataFrame meaningless code","State":"closed","Body":"Fixes #6754\r\n\r\n1) PrimitiveColumnContainer is internal class, PrimitiveColumnContainer(T[] values) is not used anywhere inside DataFrameProject and there is another constructor that can be used for the same purpose PrimitiveColumnContainer(IEnumerable<T> values). so this unused contructor can be easily removed (taking into account, that it contains errors - seems due to copy-past of code from the append method)\r\n\r\n2) Line \r\n`items[c] = items[c];  `\r\nis redundant, seems to appear after copy pasting from:\r\n\r\n```\r\npublic static async Task<DataFrame> LoadFrom(DbDataReader reader)\r\n...\r\n  for (var c = 0; c < columnsCount; c++)\r\n  {\r\n     items[c] = reader.IsDBNull(c)  ? null : reader[c];\r\n  }\r\n```\r\n\r\nMethod has unit tests. Changes don't affect method behaviour","Url":"https://github.com/dotnet/machinelearning/pull/6761","RelatedDescription":"Closed or merged PR \"Clean DataFrame meaningless code\" (#6761)"},{"Id":"1793000281","IsPullRequest":true,"CreatedAt":"2023-07-07T09:41:50","Actor":"asmirnov82","Number":"6759","RawContent":null,"Title":"Reduce coupling of Data.Analysis.Tests project","State":"closed","Body":"This PR continues work started in https://github.com/dotnet/machinelearning/pull/4346\r\n\r\nThe aim is to eliminate dependency of Microsoft.Data.Analysis.Tests from overal ML infrastructure. Before this PR it's required to build the overal ML solution (including native cpp projects) for running Unit tests for the DataFrame. Actually all these transative dependencies where the results of using Test attributes (like X86, X86X64 and NotArm32). Moving these attributes out of the Microsoft.ML.TestFramework into light Microsoft.ML.TestFrameworkCommon reduce coupling of tests projects.\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6759","RelatedDescription":"Closed or merged PR \"Reduce coupling of Data.Analysis.Tests project\" (#6759)"},{"Id":"1792884100","IsPullRequest":true,"CreatedAt":"2023-07-07T09:39:47","Actor":"asmirnov82","Number":"6758","RawContent":null,"Title":"Run tests that requires more than 2 Gb of memory only on 64-bit env","State":"closed","Body":"Run TestAppend_SizeMoreThanMaxBufferCapacity and TestAppendMany_SizeMoreThanMaxBufferCapacity tests on X64 env\r\n\r\nSee more details in https://github.com/dotnet/machinelearning/pull/6710\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6758","RelatedDescription":"Closed or merged PR \"Run tests that requires more than 2 Gb of memory only on 64-bit env\" (#6758)"},{"Id":"1790058379","IsPullRequest":true,"CreatedAt":"2023-07-06T20:16:02","Actor":"LittleLittleCloud","Number":"6756","RawContent":null,"Title":"AutoML.Net avoid empty dataset in trainValidationDatasetManager","State":"closed","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [x] There's a descriptive title that will make sense to other developers some time from now. \r\n- [x] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [x] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\nhttps://github.com/dotnet/machinelearning-modelbuilder/issues/2734\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6756","RelatedDescription":"Closed or merged PR \"AutoML.Net avoid empty dataset in trainValidationDatasetManager\" (#6756)"},{"Id":"1790624266","IsPullRequest":false,"CreatedAt":"2023-07-06T01:40:25","Actor":"pedoc","Number":"6757","RawContent":null,"Title":"[Feature Request] Create MLImage from SKBitmap instance in ML","State":"open","Body":"**Is your feature request related to a problem? Please describe.**\r\nConsider the following code snippet\r\n```csharp\r\n    MLContext mlContext = new MLContext()\r\n            {\r\n                FallbackToCpu = true,\r\n                GpuDeviceId = 0\r\n            };\r\n\r\n  var pipeline = mlContext.Transforms.ResizeImages(inputColumnName: \"bitmap\", outputColumnName: \"input_1\",\r\n                    imageWidth: 416, imageHeight: 416, resizing: ResizingKind.IsoPad)\r\n                .Append(mlContext.Transforms.ExtractPixels(outputColumnName: \"input_1\", scaleImage: 1f / 255f))\r\n                .Append(mlContext.Transforms.Concatenate(\"image_shape\", \"height\", \"width\"))\r\n                .Append(mlContext.Transforms.ApplyOnnxModel(\r\n                    shapeDictionary: new Dictionary<string, int[]>() { { \"input_1\", new[] { 1, 3, 416, 416 } } },\r\n                    inputColumnNames: new[]\r\n                    {\r\n                        \"input_1\",\r\n                        \"image_shape\"\r\n                    },\r\n                    outputColumnNames: new[]\r\n                    {\r\n                        \"yolonms_layer_1/ExpandDims_1:0\",\r\n                        \"yolonms_layer_1/ExpandDims_3:0\",\r\n                        \"yolonms_layer_1/concat_2:0\"\r\n                    },\r\n                    modelFile: modelPath, recursionLimit: 100));\r\n            var model = pipeline.Fit(mlContext.Data.LoadFromEnumerable(new List<YoloV3BitmapData>()));\r\n            var predictionEngine = mlContext.Model.CreatePredictionEngine<YoloV3BitmapData, YoloV3Prediction>(model);\r\n\r\n\t\t\tusing var bitmap = SKBitmap.Decode(\"C:\\test.jpg\");\r\n\t\t\tvar predict = predictionEngine.Predict(new YoloV3BitmapData()\r\n                    { Image = MLImage.CreateFromFile(\"C:\\test.jpg\") });\r\n            var results = GetResults(predict, classesNames);\r\n\r\n\t\t\t using var canvas = new SKCanvas(bitmap);\r\n                var paint = new SKPaint()\r\n                {\r\n                    Color = new SKColor(Color.Red.R, 0, 0,50),\r\n                    Style = SKPaintStyle.Fill\r\n                };\r\n                foreach (var result in results)\r\n                {\r\n                    var y1 = result.BBox[0];\r\n                    var x1 = result.BBox[1];\r\n                    var y2 = result.BBox[2];\r\n                    var x2 = result.BBox[3];\r\n\r\n                    canvas.DrawRect(x1, y1, x2 - x1, y2 - y1, paint);\r\n\r\n                    var paint2 = new SKPaint()\r\n                    {\r\n                        Color = new SKColor(0xff, 00, 00),\r\n                        Style = SKPaintStyle.Fill,\r\n                        Typeface = SKTypeface.FromFamilyName(\r\n                            \"Arial\",\r\n                            SKFontStyleWeight.Bold,\r\n                            SKFontStyleWidth.Normal,\r\n                            SKFontStyleSlant.Italic),\r\n                        TextSize = 18,\r\n                        IsAntialias = true,\r\n                        TextAlign = SKTextAlign.Center,\r\n                        IsStroke = false\r\n                    };\r\n\r\n                    canvas.DrawText(result.Label + \" \" + result.Confidence.ToString(\"0.00\"), new SKPoint(x1, y1),\r\n                        paint2);\r\n                }\r\n\r\n public class YoloV3BitmapData\r\n    {\r\n        [ColumnName(\"bitmap\")]\r\n        [ImageType(416, 416)]\r\n        public MLImage Image { get; set; }\r\n\r\n        [ColumnName(\"width\")]\r\n        public float ImageWidth => Image.Width;\r\n\r\n        [ColumnName(\"height\")]\r\n        public float ImageHeight => Image.Height;\r\n    }\r\n```\r\nIn the above code, we use ``SKBitmap.Decode`` and ``MLImage.CreateFromFile`` to load the image from the file, which results in 2 IO,\r\nSo if you can directly pass SKBitmap to MLImage, you will save 1 IO.\r\n\r\nSo we can write\r\n```csharp\r\nusing var bitmap = SKBitmap.Decode(\"C:\\test.jpg\");\r\nvar predict = predictionEngine.Predict(new YoloV3BitmapData() { Image = bitmap  });\r\n```\r\nor\r\n```csharp\r\nusing var bitmap = SKBitmap.Decode(\"C:\\test.jpg\");\r\nvar predict = predictionEngine.Predict(new YoloV3BitmapData() { Image = MLImage.CreateFromSKBitmap(bitmap)});\r\n```\r\n\r\n**Describe the solution you'd like**\r\nWe want to be able to simply pass SKBitmap to MLImage.\r\n\r\n**Describe alternatives you've considered**\r\nCurrently it is possible to do something similar with the following code, but it is more redundant and error-prone\r\n\r\n```csharp\r\nusing var fs=File.OpenRead(\"C:\\test.jpg\");\r\nusing var bitmap = SKBitmap.Decode(fs);\r\nvar predict = predictionEngine.Predict(new YoloV3BitmapData() { Image = MLImage.CreateFromStream(fs) });\r\n```\r\n\r\n**Additional context**\r\nIn addition, it would be useful to be able to expose the SKBitmap instance in MLImage, because this allows us to draw the detection results on the SKBitmap after obtaining the model detection results without additional coding.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6757","RelatedDescription":"Open issue \"[Feature Request] Create MLImage from SKBitmap instance in ML\" (#6757)"},{"Id":"1788237627","IsPullRequest":false,"CreatedAt":"2023-07-04T16:56:59","Actor":"torronen","Number":"6755","RawContent":null,"Title":"AutoML 2.0: regression throws The given key 'e4' was not present in the dictionary.","State":"open","Body":"**System Information (please complete the following information):**\r\n - OS & Version: windows 11\r\n - ML.NET Version: ML.NET nightly 4th July 2023\r\n - .NET Version: .NET 7.0\r\n\r\n**Describe the bug**\r\n\r\nWhen running regression experiment I got this error. It seems to appear at \"random\" experiment. I have got it on 2nd, 4th and now not yet for 21 trials.\r\n\r\n```\r\nSystem.Collections.Generic.KeyNotFoundException: The given key 'e4' was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Microsoft.ML.SearchSpace.SearchSpace.MappingToFeatureSpace(Parameter parameter)\r\n   at Microsoft.ML.SearchSpace.SearchSpace.MappingToFeatureSpace(Parameter parameter)\r\n   at Microsoft.ML.AutoML.CsvTrialResultManager.Save()\r\n   at Microsoft.ML.AutoML.AutoMLExperiment.RunAsync(CancellationToken ct)\r\n   at Kwork.MLTrainer2023Regression.Program.TrainRegression(List`1 trainingDataFiles, String LabelColumn, String saveTo, UInt32 trainingTimeSeconds) in C:\\git\\Kwork.MLTrainer2023\\Kwork.MLTrainer2023Regression\\Program.cs:line 422\r\n   at Kwork.MLTrainer2023Regression.Program.Main(String[] args) in C:\\git\\Kwork.MLTrainer2023\\Kwork.MLTrainer2023Regression\\Program.cs:line 190\r\nThe given key 'e4' was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Microsoft.ML.SearchSpace.SearchSpace.MappingToFeatureSpace(Parameter parameter)\r\n   at Microsoft.ML.SearchSpace.SearchSpace.MappingToFeatureSpace(Parameter parameter)\r\n   at Microsoft.ML.AutoML.CsvTrialResultManager.Save()\r\n   at Microsoft.ML.AutoML.AutoMLExperiment.RunAsync(CancellationToken ct)\r\n   at Kwork.MLTrainer2023Regression.Program.TrainRegression(List`1 trainingDataFiles, String LabelColumn, String saveTo, UInt32 trainingTimeSeconds) in C:\\git\\Kwork.MLTrainer2023\\Kwork.MLTrainer2023Regression\\Program.cs:line 422\r\n   at Kwork.MLTrainer2023Regression.Program.Main(String[] args) in C:\\git\\Kwork.MLTrainer2023\\Kwork.MLTrainer2023Regression\\\r\n\r\n```\r\n\r\n\r\n\r\nmy code:\r\n```\r\n                pipeline = ctx.Transforms\r\n               .SelectColumns(columnsToKeep) // Keep only the specified columns\r\n               .Append(ctx.Auto().Featurizer(data, columnInformation: columnInference.ColumnInformation))\r\n               .Append(ctx.Auto().Regression(labelColumnName: columnInference.ColumnInformation.LabelColumnName,\r\n                useFastForest: false, useSdca: false, useLbfgsPoissonRegression: false, useLgbm: false,\r\n               useFastTree: true\r\n               )); //disable slow FastForest, run LightGBM on GPU machine\r\n```\r\n               \r\n      ```\r\n AutoMLExperiment.AutoMLExperimentSettings settings = new AutoMLExperiment.AutoMLExperimentSettings();\r\n            AutoMLExperiment experiment = ctx.Auto().CreateExperiment();\r\n\r\n            // Configure experiment\r\n            experiment\r\n                .SetPipeline(pipeline)\r\n                .SetRegressionMetric(RegressionMetric.RootMeanSquaredError, labelColumn: columnInference.ColumnInformation.LabelColumnName)\r\n                .SetTrainingTimeInSeconds(trainingTimeSeconds)\r\n                .SetDataset(data, fold: NumFolds, samplingKeyColumnName: SamplingKeyColumn)\r\n                .SetEciCostFrugalTuner();\r\n\r\n            var monitor = new AutoMLMonitor(pipeline);\r\n            experiment.SetMonitor(monitor);\r\n\r\n            var cts = new CancellationTokenSource();\r\n            Console.WriteLine(\"Start experiment\");\r\n            TrialResult experimentResults = await experiment.RunAsync(cts.Token);\r\n```\r\n   \r\n   \r\n   ","Url":"https://github.com/dotnet/machinelearning/issues/6755","RelatedDescription":"Open issue \"AutoML 2.0: regression throws The given key 'e4' was not present in the dictionary.\" (#6755)"}],"ResultType":"GitHubIssue"}},"RunOn":"2023-08-05T03:30:20.2720436Z","RunDurationInMilliseconds":583}