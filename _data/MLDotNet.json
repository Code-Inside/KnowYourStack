{"Data":{"GitHub":{"Issues":[{"Id":"382940051","IsPullRequest":true,"CreatedAt":"2018-11-21T03:28:08","Actor":"jignparm","Number":"1694","RawContent":null,"Title":"WIP: Upgrade to ML.Scoring v 1.2.0, with bug fixes and GPU/CUDA  support","State":"open","Body":"Fixes #1514 \r\nFixes #1228 \r\n\r\nUpgraded runtime to Onnx 1.3, with isNan operator.\r\n\r\nBetter exception handling -- clear error messages instead of generic SEH exception.\r\n\r\nGPU support via CUDA 9.2","Url":"https://github.com/dotnet/machinelearning/pull/1694","RelatedDescription":"Open PR \"WIP: Upgrade to ML.Scoring v 1.2.0, with bug fixes and GPU/CUDA  support\" (#1694)"},{"Id":"382919304","IsPullRequest":false,"CreatedAt":"2018-11-21T01:41:01","Actor":"CESARDELATORRE","Number":"1693","RawContent":null,"Title":"QUESTION: The \"pipeline\" is immutable; sometimes a chain of Estimators, sometimes a single Estimator. Easy to understand?","State":"open","Body":"This is just an observation of a possible risk. I'm not saying that my hypothetical proposal below is better, since it is probably less flexible. I just would like to get feedback from the community about our current approach to double-check we're on the right path.\r\n\r\nThe fact that a \"pipeline\" sometimes is a \"chain of estimators\", but sometimes \"it can be\" a single estimator could be confusing for developers. For instance:\r\n\r\nIn this case \"dataProcessPipeline\" is a single Estimator of type `TextFeaturizingEstimator`:\r\n\r\n`var dataProcessPipeline = mlContext.Transforms.Categorical.MapValueToKey(\"Area\", \"Label\")\r\n;`\r\n\r\nIn this other case below, \"dataProcessPipeline\" is a chain of estimators of type `EstimatorChain<TTrans>`, as soon as you call the first `Append()`:\r\n\r\n```\r\nvar dataProcessPipeline = mlContext.Transforms.Categorical.MapValueToKey(\"Area\", \"Label\")\r\n                .Append(mlContext.Transforms.Text.FeaturizeText(\"Title\", \"TitleFeaturized\"))\r\n                .Append(mlContext.Transforms.Text.FeaturizeText(\"Description\", \"DescriptionFeaturized\"))\r\n                .Append(mlContext.Transforms.Concatenate(\"Features\", \"TitleFeaturized\", \"DescriptionFeaturized\"));\r\n```\r\n\r\nAlso, the fact that an EstimatorChain pipeline is created from its first element might also be confusing?\r\n\r\nSimplifying and in comparison, when you create a List or collection in C# you first create the List (the box) then add things/elements  into it. You usually don't create a collection of items from the first item but you create the \"box\" first, then add items. But that is for mutable collections. Not the same! :)\r\n\r\nIn the case of our current EstimatorChain it is using a more advanced pattern based on fluent API and immutable objects. Since each estimator and estimator-chain is immutable, when you append another estimator in reality you are creating a new estimator-chain and returning that new pipeline (estimator-chain).\r\n\r\n**QUESTION: Is this pattern clear or confusing for you?**\r\n\r\nA different approach based on a typical **mutable** collection could be something like the following (This is NOT how ML.NET currently works and might require different types):\r\n\r\n```\r\n//DataView with dataset\r\nIDataView trainingDataView = textLoader.Read(TrainDataPath);\r\n\t\t\r\n// Create an \"empty\" EstimatorChain, the \"box\", which would be mutable, as it'll be growing with items:\r\nvar dataProcessPipeline = MLContext.CreateEstimatorChain();\r\n\r\n// Add Estimators to the same chain/pipeline\r\ndataProcessPipeline.Append(mlContext.Transforms.CopyColumns(\"FareAmount\", \"Label\");\r\ndataProcessPipeline.Append(mlContext.Transforms.Categorical.OneHotEncoding(\"VendorId\", \"VendorIdEncoded\"));\r\ndataProcessPipeline.Append(mlContext.Transforms.Normalize(inputName: \"TripTime\", mode: NormalizerMode.MeanVariance));\r\ndataProcessPipeline.Append(mlContext.Transforms.Concatenate(\"Features\", \"VendorIdEncoded\", \"TripTime\"));\r\n\r\n//... Peek data into the DataView, etc. if you want\r\n\r\n//Optional - Clone the pipeline with data transformations in case you want to reuse the dataProcessPipeline for parallel executions of additional trainers\r\nvar trainingPipeline = dataProcessPipeline.Clone();\r\n\r\n//Add trainer to the training pipeline\r\nvar sdcaTrainer = mlContext.Regression.Trainers.StochasticDualCoordinateAscent(label: \"Label\", features: \"Features\");\r\ntrainingPipeline.Append(sdcaTrainer);\r\n\r\n//Train the model fitting to the dataSet\r\nvar trainedModel = trainingPipeline.Fit(trainingDataView);\r\n```\r\nIn this last code, when you execute dataProcessPipeline.Append(estimator) it is really appending an estimator into that current pipeline. \r\n\r\nIn comparison and shown below, with our current API, when adding a trainer, you have to \"catch\" the returned pipeline, as the estimator/trainer was added only to the returned new pipeline, not to the pipeline owning the method Append() you run.\r\n\r\n```\r\n//Add trainer to the training pipeline\r\nvar sdcaTrainer = mlContext.Regression.Trainers.StochasticDualCoordinateAscent(label: \"Label\", features: \"Features\");\r\nvar trainingPipeline = dataProcessPipeline.Append(sdcaTrainer);\r\n\r\n//Train the model fitting to the dataSet\r\nvar trainedModel = trainingPipeline.Fit(trainingDataView);\r\n```\r\nThat's also why you don't need to clone the pipeline if you want to \"fork\" it, since every time you call Append() you are creating a new pipeline, so you could \"fork\" whenever you call .Append().\r\n\r\nAs summary, in our current API, .Append() is not appending anything into the current pipeline, but creating and returning a new pipeline (EstimatorChain) with that new estimator appended.\r\n\r\nOur current approach is probably more flexible based on immutable EstimatorChains but I'd like to double check if our current approach is clear for anyone learning the API.\r\n\r\n What are your thoughts about it?\r\nCan you provide your feedback? ðŸ‘ \r\nThanks, \r\n \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1693","RelatedDescription":"Open issue \"QUESTION: The \"pipeline\" is immutable; sometimes a chain of Estimators, sometimes a single Estimator. Easy to understand?\" (#1693)"},{"Id":"382908812","IsPullRequest":true,"CreatedAt":"2018-11-21T00:49:04","Actor":"rogancarr","Number":"1692","RawContent":null,"Title":"WIP: Adding documentation for GAM","State":"open","Body":"This PR adds documentation for using the GAM in the Microsoft.ML.Samples project.\r\n\r\nFixes #1645 \r\n\r\nAwaiting PR #1691 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/1692","RelatedDescription":"Open PR \"WIP: Adding documentation for GAM\" (#1692)"},{"Id":"382907770","IsPullRequest":true,"CreatedAt":"2018-11-21T00:44:03","Actor":"rogancarr","Number":"1691","RawContent":null,"Title":"Extend GAM models with methods to return model parameters","State":"open","Body":"This PR updates `GamPredictorBase` to allow all GAM predictors to return the intercept and copies of the bin and weight arrays.\r\n\r\nFixes #1679","Url":"https://github.com/dotnet/machinelearning/pull/1691","RelatedDescription":"Open PR \"Extend GAM models with methods to return model parameters\" (#1691)"},{"Id":"382906847","IsPullRequest":false,"CreatedAt":"2018-11-21T00:39:54","Actor":"CESARDELATORRE","Number":"1690","RawContent":null,"Title":"Rename mlContext.Data.TextReader() to mlContext.Data.CreateTextLoader()","State":"open","Body":"Since the object being created is a \"TextLoader\", I'd recommend the method's name to say so, instead of \"TextReader\" which looks like a different type. \r\n\r\nI mean code like the following feels confusing:\r\n\r\n```\r\n            TextLoader textLoader = mlContext.Data.TextReader(new TextLoader.Arguments()\r\n                                                    {\r\n                                                        Separator = \"tab\",\r\n                                                        HasHeader = true,\r\n                                                        Column = new[]\r\n                                                                    {\r\n                                                                    new TextLoader.Column(\"Label\", DataKind.Bool, 0),\r\n                                                                    new TextLoader.Column(\"Text\", DataKind.Text, 1)\r\n                                                                    }\r\n                                                    });\r\n```\r\n\r\nIn addition to that, methods should have a verb as part of the name, so if what it is doing is to create a TextReader, let's say so, as:\r\n\r\nmlContext.Data.CreateTextLoader()\r\n\r\nWe're not being consistent now when having some methods with a verb but other methods just a noun:\r\n\r\n![image](https://user-images.githubusercontent.com/1712635/48811328-18f0d300-ece2-11e8-8d31-2e2fad81ab60.png)\r\n\r\nIt is also against C# conventions (and most languages). A method's name should have a verb describing the action being performed by that method:\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-type-members#names-of-methods","Url":"https://github.com/dotnet/machinelearning/issues/1690","RelatedDescription":"Open issue \"Rename mlContext.Data.TextReader() to mlContext.Data.CreateTextLoader()\" (#1690)"},{"Id":"382904365","IsPullRequest":false,"CreatedAt":"2018-11-21T00:27:24","Actor":"CESARDELATORRE","Number":"1689","RawContent":null,"Title":"Include the \"save file\" action (.ZIP file) as part of model.SaveFile()","State":"open","Body":"Currently, whenever we are saving a .ZIP model file, you always need to handle the code for the File stream class.\r\n\r\nI think that is repetitive code that could be included in the API.\r\nInstead of:\r\n\r\n```\r\nusing (var fs = new FileStream(ModelPath, FileMode.Create, FileAccess.Write, FileShare.Write))\r\n                mlContext.Model.Save(trainedModel, fs);\r\n```\r\n\r\nWe could have an overridden method so I could simply do the following:\r\n\r\n`mlContext.Model.Save(trainedModel, modelPath);`\r\n\r\nOr even the following, if those methods were part of the model class itself instead of a utility class in the MLContext:\r\n\r\n`model.Save(modelPath);`\r\n\r\nCurrently, this kind of line using the file stream class is something you need to repeat over and over in every/most training app (even when the constructor can be simplified):\r\n\r\n`using (var fs = new FileStream(ModelPath, FileMode.Create, FileAccess.Write, FileShare.Write))`\r\n\r\nHandling a FileStream object might should not be mandatory for the user **but optional**:\r\n\r\nOf course, I would also maintain the current methods because in some cases you might want to just provide an existing stream object, but as opt-in.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1689","RelatedDescription":"Open issue \"Include the \"save file\" action (.ZIP file) as part of model.SaveFile()\" (#1689)"},{"Id":"382070777","IsPullRequest":false,"CreatedAt":"2018-11-20T23:57:38","Actor":"ShinobiWannabe","Number":"1668","RawContent":null,"Title":"14 TB of Hundreds of Thousands of Input Files For Training?","State":"closed","Body":"I am sorry if this was answered, but the closest I could find is this:\r\nhttps://github.com/dotnet/machinelearning/issues/192\r\n\r\nWhich looks to have an answer of specifying all the related files.\r\n`var data = reader.Read(exampleFile1, exampleFile2);`\r\n\r\nThe other tutorials on Microsoft all used a single file.\r\n\r\nI am looking at something to examine about 14 Terabytes worth of data within hundreds of thousands of files across multiple hard drives.  Because of the size there would not really be any way to store that in memory either.  \r\n\r\nCould I use ML.NET for this problem?\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1668","RelatedDescription":"Closed issue \"14 TB of Hundreds of Thousands of Input Files For Training?\" (#1668)"},{"Id":"382878508","IsPullRequest":false,"CreatedAt":"2018-11-20T22:42:46","Actor":"eerhardt","Number":"1688","RawContent":null,"Title":"CpuMath has a bad project reference to ML.Core","State":"open","Body":"See https://github.com/dotnet/machinelearning/pull/1659#discussion_r235195505\r\n\r\nWe recently made CpuMath depend on ML.Core, but this is broken.\r\n\r\nThe `Microsoft.ML` nuget package depends on the `Microsoft.ML.CpuMath` NuGet package.  So having the CpuMath.dll depend on `Microsoft.ML.Core` is backwards.\r\n\r\nSee https://github.com/dotnet/machinelearning/pull/542 for the reasoning why this was done that way.","Url":"https://github.com/dotnet/machinelearning/issues/1688","RelatedDescription":"Open issue \"CpuMath has a bad project reference to ML.Core\" (#1688)"},{"Id":"382820511","IsPullRequest":true,"CreatedAt":"2018-11-20T19:43:56","Actor":"yaeldekel","Number":"1687","RawContent":null,"Title":"Remove adult.train and adult.test and modify all unit tests","State":"open","Body":"\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1687","RelatedDescription":"Open PR \"Remove adult.train and adult.test and modify all unit tests\" (#1687)"},{"Id":"382795373","IsPullRequest":true,"CreatedAt":"2018-11-20T18:32:16","Actor":"wschin","Number":"1686","RawContent":null,"Title":"Obsolete API","State":"open","Body":"We are planning removing classical APIs defined in Microsoft.ML.Legacy. The commits are organized so please read them one-by-one.\r\n\r\nFixes #1684.","Url":"https://github.com/dotnet/machinelearning/pull/1686","RelatedDescription":"Open PR \"Obsolete API\" (#1686)"},{"Id":"382790848","IsPullRequest":false,"CreatedAt":"2018-11-20T18:19:02","Actor":"GalOshri","Number":"1685","RawContent":null,"Title":"MapValueToKey and MapKeyToValue in different catalogs","State":"open","Body":"The `MapValueToKey` transform is currently in the `Categorical` transforms catalog, whereas the `MapKeyToValue` transform is in the `Conversion` transforms catalog. \r\n\r\nWould it be more helpful to have both of these in the same catalog, as the latter transform is often needed to reverse the former? Otherwise a user might not realize that a transform exists to convert back from key to value when they look in the original catalog they used.","Url":"https://github.com/dotnet/machinelearning/issues/1685","RelatedDescription":"Open issue \"MapValueToKey and MapKeyToValue in different catalogs\" (#1685)"},{"Id":"382786531","IsPullRequest":false,"CreatedAt":"2018-11-20T18:06:32","Actor":"Zruty0","Number":"1684","RawContent":null,"Title":"Obsolete the Legacy API","State":"open","Body":"As long planned, we want to obsolete the Legacy API in the 0.8 release.\r\nNamely: \r\n- Mark everything in `Legacy` assembly to be `[Obsolete]`.\r\n- For all our tests that trigger the obsolete warning, suppress the warning.\r\n- For all our code that triggers the obsolete warning, either fix to not rely on `Legacy`, or make obsolete, or remove.","Url":"https://github.com/dotnet/machinelearning/issues/1684","RelatedDescription":"Open issue \"Obsolete the Legacy API\" (#1684)"},{"Id":"382752147","IsPullRequest":true,"CreatedAt":"2018-11-20T16:43:16","Actor":"artidoro","Number":"1683","RawContent":null,"Title":"Conversion of DropSlots, MutualInformationFeatureSelection, and CountFeatureSelection into estimator and transformers","State":"open","Body":"Ongoing work on converting the transformers to estimators (#754). In this PR I convert DropSlots, MutualInformationFeatureSelection, and CountFeatureSelection into estimator and transformers with relative extensions.\r\n\r\nIn particular: \r\n1. DropSlots is converted to a transformer.\r\n2. MutualInformationFeatureSelection and CountFeatureSelection are converted to estimators.\r\n3. For both estimators, I add static extensions, and dynamic extensions to MLContext.\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1683","RelatedDescription":"Open PR \"Conversion of DropSlots, MutualInformationFeatureSelection, and CountFeatureSelection into estimator and transformers\" (#1683)"},{"Id":"382551449","IsPullRequest":true,"CreatedAt":"2018-11-20T08:31:18","Actor":"sfilipi","Number":"1682","RawContent":null,"Title":"[WIP] adding some trainer extensions on the StandartLearners catalog. Correcting namespace, and names","State":"open","Body":"The last PR addressing #1318 ","Url":"https://github.com/dotnet/machinelearning/pull/1682","RelatedDescription":"Open PR \"[WIP] adding some trainer extensions on the StandartLearners catalog. Correcting namespace, and names\" (#1682)"},{"Id":"382536710","IsPullRequest":true,"CreatedAt":"2018-11-20T07:39:38","Actor":"justinormont","Number":"1681","RawContent":null,"Title":"Spelling corrections","State":"open","Body":"Barge of spelling/grammar corrections I've noted over time. Sailing the high seas, enjoying the sun, occasionally noticing the one, the oddity floating where it aught not be.  ","Url":"https://github.com/dotnet/machinelearning/pull/1681","RelatedDescription":"Open PR \"Spelling corrections\" (#1681)"},{"Id":"382479455","IsPullRequest":true,"CreatedAt":"2018-11-20T03:00:58","Actor":"Zruty0","Number":"1680","RawContent":null,"Title":"First round of Schema final polish","State":"open","Body":"Contributes to #1500 \r\n\r\nAdded Schema.DetachedColumn for columns that are not bound to schema\r\nMoved Schema to Data namespace\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1680","RelatedDescription":"Open PR \"First round of Schema final polish\" (#1680)"},{"Id":"382454170","IsPullRequest":false,"CreatedAt":"2018-11-20T00:56:09","Actor":"rogancarr","Number":"1679","RawContent":null,"Title":"Cannot access GAM model parameters from a trained model","State":"open","Body":"When we train a GAM model, we want to inspect the features, just as we do a linear model. Currently, the only way we can do this is through the `SaveSummary()` command, where we pass in a `StringBuilder` object.\r\n\r\nI propose adding public methods to the GAM objects to fetch back the `intercept` (bias / baseline prediction), `feature-indices`, and `feature-index-weights`. This would allow for inspection of the model parameters within the .NET runtime.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/1679","RelatedDescription":"Open issue \"Cannot access GAM model parameters from a trained model\" (#1679)"},{"Id":"382447721","IsPullRequest":true,"CreatedAt":"2018-11-20T00:23:54","Actor":"najeeb-kazmi","Number":"1678","RawContent":null,"Title":"Adding binary saving and loading to MLContext.Data","State":"open","Body":"Fixes #1627 \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1678","RelatedDescription":"Open PR \"Adding binary saving and loading to MLContext.Data\" (#1678)"},{"Id":"382369402","IsPullRequest":true,"CreatedAt":"2018-11-20T00:06:06","Actor":"ganik","Number":"1671","RawContent":null,"Title":"WIP: Adding WhatTheFeature Scorer ","State":"closed","Body":"fixes #1644 ","Url":"https://github.com/dotnet/machinelearning/pull/1671","RelatedDescription":"Closed or merged PR \"WIP: Adding WhatTheFeature Scorer \" (#1671)"},{"Id":"382443866","IsPullRequest":true,"CreatedAt":"2018-11-20T00:05:57","Actor":"ganik","Number":"1677","RawContent":null,"Title":"WIP: Adding WhatTheFeature Scorer","State":"open","Body":"fixes #1644 ","Url":"https://github.com/dotnet/machinelearning/pull/1677","RelatedDescription":"Open PR \"WIP: Adding WhatTheFeature Scorer\" (#1677)"},{"Id":"382434490","IsPullRequest":true,"CreatedAt":"2018-11-19T23:23:52","Actor":"Anipik","Number":"1676","RawContent":null,"Title":"Contracts.Assert statements valid for Debug-Intrinsics","State":"open","Body":"Debuger is currently skipping the Contracts.Assert statements without validating them. for Debug-Intrinsics.\r\n\r\nAfter the change\r\n- If the debugger is attached and the condition is false then the debugger will  break\r\n- If the debugger is not attached, the test will get aborted\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1676","RelatedDescription":"Open PR \"Contracts.Assert statements valid for Debug-Intrinsics\" (#1676)"},{"Id":"382400022","IsPullRequest":false,"CreatedAt":"2018-11-19T23:23:49","Actor":"maxt3r","Number":"1673","RawContent":null,"Title":"How to use LinearSvm?","State":"closed","Body":"Sorry if this is not the place for questions.\r\n\r\nCurrently I'm using FastTree for binary classification, but I would like to give SVM a try and compare metrics.\r\n\r\nAll the docs mention LinearSvm, but I can't find code example anywhere.\r\n\r\n`mlContext.BinaryClassification.Trainers` does not have public SVM trainers. There is `LinearSvm` class and `LinearSvm.TrainLinearSvm` static method, but they seem to be intended for different things.\r\n\r\nWhat am I missing? \r\n\r\n**Version: 0.7**","Url":"https://github.com/dotnet/machinelearning/issues/1673","RelatedDescription":"Closed issue \"How to use LinearSvm?\" (#1673)"},{"Id":"382411517","IsPullRequest":true,"CreatedAt":"2018-11-19T23:20:11","Actor":"eerhardt","Number":"1674","RawContent":null,"Title":"Update macOS Prerequisites","State":"closed","Body":"Updating macOS prerequisites to the latest dependencies\r\n","Url":"https://github.com/dotnet/machinelearning/pull/1674","RelatedDescription":"Closed or merged PR \"Update macOS Prerequisites\" (#1674)"},{"Id":"382432417","IsPullRequest":false,"CreatedAt":"2018-11-19T23:15:22","Actor":"rogancarr","Number":"1675","RawContent":null,"Title":"What the Feature Scorer for FastTree Ranking","State":"open","Body":"Potential bug from a customer: `What-The-Feature scorer` is not computing feature scores for `FastTree Ranking`.\r\n\r\nNeeds to first be reproduced with a sample dataset in ML.NET, then can be triaged as a bug or non-issue.\r\n\r\nReference Issue for WTF: #1644 ","Url":"https://github.com/dotnet/machinelearning/issues/1675","RelatedDescription":"Open issue \"What the Feature Scorer for FastTree Ranking\" (#1675)"},{"Id":"382392863","IsPullRequest":false,"CreatedAt":"2018-11-19T21:06:38","Actor":"justinormont","Number":"1672","RawContent":null,"Title":"Low discrepancy random ","State":"open","Body":"Low discrepancy random sweeper (LDRand) should be moved to the external repo. \r\n\r\nLDRand was held back in the internal repo due to a dependence on the MKL library. This issue has been resolved, and I think we are now able to move this code.","Url":"https://github.com/dotnet/machinelearning/issues/1672","RelatedDescription":"Open issue \"Low discrepancy random \" (#1672)"},{"Id":"382326220","IsPullRequest":true,"CreatedAt":"2018-11-19T17:48:03","Actor":"Ivanidzo4ka","Number":"1670","RawContent":null,"Title":"Fix problem with saving/loading empty vbuffer","State":"open","Body":"Fix #1660 ","Url":"https://github.com/dotnet/machinelearning/pull/1670","RelatedDescription":"Open PR \"Fix problem with saving/loading empty vbuffer\" (#1670)"},{"Id":"382315922","IsPullRequest":false,"CreatedAt":"2018-11-19T17:19:21","Actor":"wschin","Number":"1669","RawContent":null,"Title":"Float v.s float","State":"open","Body":"In ML.NET codebase, one can see two different names for 32-bit float type. Recent PR uses `float` while [old places](https://github.com/dotnet/machinelearning/blob/e0906608ca0d37ad0c10ba647e83b45990afde43/src/Microsoft.ML.Sweeper/ISweeper.cs#L5) have `Float`. It'd be nice to have only one of the two styles.","Url":"https://github.com/dotnet/machinelearning/issues/1669","RelatedDescription":"Open issue \"Float v.s float\" (#1669)"},{"Id":"382070208","IsPullRequest":false,"CreatedAt":"2018-11-19T06:09:09","Actor":"daholste","Number":"1667","RawContent":null,"Title":"Crash in OnlineGradientDescentRegressor","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: Windows 10\r\n- **.NET Version (eg., dotnet --info)**: .NET Core 2.1\r\n\r\n### Issue\r\n\r\n- **What did you do?**\r\nRan AutoML\r\n- **What happened?**\r\nException below\r\n\r\n### Source code / logs\r\n\r\nException:\r\n```\r\nTrainers.OnlineGradientDescentRegressor{LearningRate:1, DecreaseLearningRate:True, L2RegularizerWeight:0.3115694, NumIterations:7, InitWtsDiameter:0.537725, Shuffle:True} Crashed System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.InvalidOperationException: The weights/bias contain invalid values (NaN or Infinite). Potential causes: high learning rates, no normalization, high initial weights, etc.\r\n   at Microsoft.ML.Runtime.Contracts.Check(IExceptionContext ctx, Boolean f, String msg) in C:\\MLDotNet\\src\\Microsoft.ML.Core\\Utilities\\Contracts.cs:line 501\r\n   at Microsoft.ML.Trainers.Online.OnlineLinearTrainer`2.TrainModelCore(TrainContext context) in C:\\MLDotNet\\src\\Microsoft.ML.StandardLearners\\Standard\\Online\\OnlineLinear.cs:line 275\r\n   at Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2.Train(TrainContext context) in C:\\MLDotNet\\src\\Microsoft.ML.Data\\Training\\TrainerEstimatorBase.cs:line 93\r\n   at Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2.Microsoft.ML.Runtime.ITrainer.Train(TrainContext context) in C:\\MLDotNet\\src\\Microsoft.ML.Data\\Training\\TrainerEstimatorBase.cs:line 159\r\n   at Microsoft.ML.Runtime.Data.TrainUtils.TrainCore(IHostEnvironment env, IChannel ch, RoleMappedData data, ITrainer trainer, RoleMappedData validData, IComponentFactory`1 calibrator, Int32 maxCalibrationExamples, Nullable`1 cacheData, IPredictor inputPredictor, RoleMappedData testData) in C:\\MLDotNet\\src\\Microsoft.ML.Data\\Commands\\TrainCommand.cs:line 276\r\n   at Microsoft.ML.Runtime.Data.TrainUtils.Train(IHostEnvironment env, IChannel ch, RoleMappedData data, ITrainer trainer, IComponentFactory`1 calibrator, Int32 maxCalibrationExamples) in C:\\MLDotNet\\src\\Microsoft.ML.Data\\Commands\\TrainCommand.cs:line 245\r\n   at Microsoft.ML.Runtime.EntryPoints.LearnerEntryPointsUtils.Train[TArg,TOut](IHost host, TArg input, Func`1 createTrainer, Func`1 getLabel, Func`1 getWeight, Func`1 getGroup, Func`1 getName, Func`1 getCustom, ICalibratorTrainerFactory calibrator, Int32 maxCalibrationExamples) in C:\\MLDotNet\\src\\Microsoft.ML.Data\\EntryPoints\\InputBase.cs:line 189\r\n   at Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer.TrainRegression(IHostEnvironment env, Arguments input) in C:\\MLDotNet\\src\\Microsoft.ML.StandardLearners\\Standard\\Online\\OnlineGradientDescent.cs:line 178\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Object[] arguments, Signature sig, Boolean constructor, Boolean wrapExceptions)\r\n   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n   at System.Reflection.MethodBase.Invoke(Object obj, Object[] parameters)\r\n   at Microsoft.ML.Runtime.EntryPoints.EntryPointNode.Run() in C:\\MLDotNet\\src\\Microsoft.ML.Data\\EntryPoints\\EntryPointNode.cs:line 826\r\n   at Microsoft.ML.Runtime.EntryPoints.EntryPointGraph.RunNode(EntryPointNode node) in C:\\MLDotNet\\src\\Microsoft.ML.Data\\EntryPoints\\EntryPointNode.cs:line 1022\r\n   at Microsoft.ML.Runtime.EntryPoints.JsonUtils.GraphRunner.RunAllNonMacros() in C:\\MLDotNet\\src\\Microsoft.ML.Legacy\\Runtime\\EntryPoints\\JsonUtils\\GraphRunner.cs:line 67\r\n   at Microsoft.ML.Runtime.EntryPoints.JsonUtils.GraphRunner.RunAll() in C:\\MLDotNet\\src\\Microsoft.ML.Legacy\\Runtime\\EntryPoints\\JsonUtils\\GraphRunner.cs:line 55\r\n   at Microsoft.ML.Runtime.Experiment.Run() in C:\\MLDotNet\\src\\Microsoft.ML.Legacy\\Runtime\\Experiment\\Experiment.cs:line 130\r\n   at Microsoft.ML.Runtime.PipelineInference.PipelinePattern.RunTrainTestExperiment(IDataView trainData, IDataView testData, SupportedMetric metric, TrainerKinds trainerKind, Double& testMetricValue, Double& trainMetricValue) in C:\\MLDotNet\\src\\Microsoft.ML.PipelineInference\\PipelinePattern.cs:line 212\r\n   at Microsoft.ML.Runtime.PipelineInference.AutoInference.AutoMlMlState.ProcessPipeline(SweeperProbabilityUtils utils, Stopwatch stopwatch, PipelinePattern candidate, Int32 numOfTrainingRows) in C:\\MLDotNet\\src\\Microsoft.ML.PipelineInference\\AutoInference.cs:line 251\r\n   at Microsoft.ML.Runtime.PipelineInference.AutoInference.AutoMlMlState.MainLearningLoop(Int32 batchSize, Int32 numOfTrainingRows) in C:\\MLDotNet\\src\\Microsoft.ML.PipelineInference\\AutoInference.cs:line 224\r\n```","Url":"https://github.com/dotnet/machinelearning/issues/1667","RelatedDescription":"Open issue \"Crash in OnlineGradientDescentRegressor\" (#1667)"},{"Id":"382069907","IsPullRequest":false,"CreatedAt":"2018-11-19T06:07:39","Actor":"daholste","Number":"1666","RawContent":null,"Title":"Exception in AutoML Hyperparam Sweeper","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: Windows 10\r\n- **.NET Version (eg., dotnet --info)**: .NET Core 2.1\r\n\r\n### Source code / logs\r\n```\r\nSystem.InvalidOperationException: Value not in correct range\r\n   at Microsoft.ML.Runtime.Contracts.Check(Boolean f, String msg) in C:\\MLDotNet\\src\\Microsoft.ML.Core\\Utilities\\Contracts.cs:line 496\r\n   at Microsoft.ML.Runtime.Sweeper.FloatValueGenerator.NormalizeValue(IParameterValue value) in C:\\MLDotNet\\src\\Microsoft.ML.Sweeper\\Parameters.cs:line 442\r\n   at Microsoft.ML.Runtime.Sweeper.Algorithms.SweeperProbabilityUtils.ParameterSetAsFloatArray(IHost host, IValueGenerator[] sweepParams, ParameterSet ps, Boolean expandCategoricals) in C:\\MLDotNet\\src\\Microsoft.ML.Sweeper\\Algorithms\\SweeperProbabilityUtils.cs:line 207\r\n   at Microsoft.ML.Runtime.Sweeper.Algorithms.KdoSweeper.SampleChild(ParameterSet parent, Double fitness, Int32 n, IRunResult[] previousRuns, Double rMean, Double rVar, Boolean isMetricMaximizing) in C:\\MLDotNet\\src\\Microsoft.ML.Sweeper\\Algorithms\\KdoSweeper.cs:line 206\r\n   at Microsoft.ML.Runtime.Sweeper.Algorithms.KdoSweeper.GenerateChildConfigurations(IRunResult[] history, Int32[] parentIndicies, Double[] weights, IRunResult[] previousRuns, Double rMean, Double rVar) in C:\\MLDotNet\\src\\Microsoft.ML.Sweeper\\Algorithms\\KdoSweeper.cs:line 187\r\n   at Microsoft.ML.Runtime.Sweeper.Algorithms.KdoSweeper.GenerateCandidateConfigurations(Int32 numOfCandidates, IRunResult[] previousRuns) in C:\\MLDotNet\\src\\Microsoft.ML.Sweeper\\Algorithms\\KdoSweeper.cs:line 176\r\n   at Microsoft.ML.Runtime.Sweeper.Algorithms.KdoSweeper.ProposeSweeps(Int32 maxSweeps, IEnumerable`1 previousRuns) in C:\\MLDotNet\\src\\Microsoft.ML.Sweeper\\Algorithms\\KdoSweeper.cs:line 153\r\n   at Microsoft.ML.Runtime.PipelineInference.PipelineOptimizerBase.SampleHyperparameters(SuggestedLearner learner, ISweeper sweeper, Boolean isMaximizingMetric, PipelinePattern[] history) in C:\\MLDotNet\\src\\Microsoft.ML.PipelineInference\\Interfaces\\IPipelineOptimizer.cs:line 143\r\n   at Microsoft.ML.Runtime.PipelineInference.RocketEngine.SampleHyperparameters(SuggestedLearner learner, PipelinePattern[] history) in C:\\MLDotNet\\src\\Microsoft.ML.PipelineInference\\AutoMlEngines\\RocketEngine.cs:line 128\r\n   at Microsoft.ML.Runtime.PipelineInference.RocketEngine.NextCandidates(PipelinePattern[] history, Int32 numCandidates, Boolean defaultHyperParams, Boolean uniformRandomTransforms) in C:\\MLDotNet\\src\\Microsoft.ML.PipelineInference\\AutoMlEngines\\RocketEngine.cs:line 309\r\n   at Microsoft.ML.Runtime.PipelineInference.RocketEngine.GetNextCandidates(IEnumerable`1 history, Int32 numCandidates, RoleMappedData dataRoles) in C:\\MLDotNet\\src\\Microsoft.ML.PipelineInference\\AutoMlEngines\\RocketEngine.cs:line 266\r\n   at Microsoft.ML.Runtime.PipelineInference.AutoInference.AutoMlMlState.MainLearningLoop(Int32 batchSize, Int32 numOfTrainingRows) in C:\\MLDotNet\\src\\Microsoft.ML.PipelineInference\\AutoInference.cs:line 213\r\n```","Url":"https://github.com/dotnet/machinelearning/issues/1666","RelatedDescription":"Open issue \"Exception in AutoML Hyperparam Sweeper\" (#1666)"},{"Id":"382069406","IsPullRequest":false,"CreatedAt":"2018-11-19T06:05:22","Actor":"daholste","Number":"1665","RawContent":null,"Title":"AutoML seeks to minimize RSquared, instead of maximize it","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: Windows 10\r\n- **.NET Version (eg., dotnet --info)**: .NET Core 2.1\r\n\r\n### Issue\r\n\r\nAutoML seeks to minimize RSquared, instead of maximize it --\r\nhttps://github.com/dotnet/machinelearning/blob/e0906608ca0d37ad0c10ba647e83b45990afde43/src/Microsoft.ML.PipelineInference/PipelineSweeperSupportedMetrics.cs#L84","Url":"https://github.com/dotnet/machinelearning/issues/1665","RelatedDescription":"Open issue \"AutoML seeks to minimize RSquared, instead of maximize it\" (#1665)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-11-21T05:30:35.7551492Z","RunDurationInMilliseconds":1337}