{"Data":{"GitHub":{"Issues":[{"Id":"333468693","IsPullRequest":false,"CreatedAt":"2018-06-18T23:25:16","Actor":"ganik","Number":"373","RawContent":null,"Title":"Add LightLDA transform","State":"open","Body":"**LightLDA: Big Topic Models on Modest Compute Clusters**\r\n- Current implementations of LDA ( Latent Dirichlet Allocation ) such as SparseLDA or AliasLDA allow to achieve massive data and model scales, for example models with tens of billions of parameters to be inferred from billions of documents. However this requires using cluster up to thousands of machines with all ensuing costs to setup and maintain. \r\n- LightLDA solves this problem in a more cost-effective manner by providing an implementation that is efﬁcient enough for modest clusters with at most tens of machines...\r\n\r\nFor more details please see LightLDA paper:\r\n  http://arxiv.org/abs/1412.1576 \r\n  http://www.www2015.it/documents/proceedings/proceedings/p1351.pdf\r\nand open source implementation:\r\n  https://github.com/Microsoft/LightLDA ","Url":"https://github.com/dotnet/machinelearning/issues/373","RelatedDescription":"Open issue \"Add LightLDA transform\" (#373)"},{"Id":"333440735","IsPullRequest":true,"CreatedAt":"2018-06-18T21:25:47","Actor":"jwood803","Number":"372","RawContent":null,"Title":"Update fast tree argument help text","State":"open","Body":"Proposed update for issue #223.","Url":"https://github.com/dotnet/machinelearning/pull/372","RelatedDescription":"Open PR \"Update fast tree argument help text\" (#372)"},{"Id":"332350860","IsPullRequest":true,"CreatedAt":"2018-06-18T21:19:26","Actor":"jwood803","Number":"358","RawContent":null,"Title":"[WIP] Update ProposeSweeps to have unique entries","State":"closed","Body":"Proposed fix for issue #215.\r\n\r\nUpdated the `ProposeSweeps` virtual and override methods to not add to the collection if it already exists to prevent duplicates.\r\n\r\nPut this as a work in progress PR since I'm sure I'll need some guidance as to if this solution is even a good one and how it can be further improved.\r\n\r\nIf anything else is needed, I'll be glad to update this PR.","Url":"https://github.com/dotnet/machinelearning/pull/358","RelatedDescription":"Closed or merged PR \"[WIP] Update ProposeSweeps to have unique entries\" (#358)"},{"Id":"332962253","IsPullRequest":true,"CreatedAt":"2018-06-18T21:02:05","Actor":"Nepomuceno","Number":"365","RawContent":null,"Title":"Propose sweep","State":"closed","Body":"This pr it is to solve #215 \r\n\r\nThis guarantees that ProposeSweeps will generate just distinct values. Also there were tests created to guarantee that this is the case.\r\n\r\nThanks to @ross-p-smith that also wored in this pr.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/365","RelatedDescription":"Closed or merged PR \"Propose sweep\" (#365)"},{"Id":"333350671","IsPullRequest":true,"CreatedAt":"2018-06-18T19:43:11","Actor":"TomFinley","Number":"369","RawContent":null,"Title":"`Stream` subclasses now have `Close` call `base.Close` to ensure disposal.","State":"closed","Body":"Fixes #367.\r\n\r\nAlso while I was at it C# 7.x-ified the file.","Url":"https://github.com/dotnet/machinelearning/pull/369","RelatedDescription":"Closed or merged PR \"`Stream` subclasses now have `Close` call `base.Close` to ensure disposal.\" (#369)"},{"Id":"333103042","IsPullRequest":false,"CreatedAt":"2018-06-18T19:43:11","Actor":"mjmckp","Number":"367","RawContent":null,"Title":"Temporary file created by HybridMemoryStream in Transposer not deleted","State":"closed","Body":"The `HybridMemoryStream` created in the `Transposer` https://github.com/dotnet/machinelearning/blob/c023727b76970ab913ec1ce38276508835c17bcf/src/Microsoft.ML.Data/DataView/Transposer.cs#L173\r\nis closed, but never disposed.  This is because the `Dispose` implementation of the `BinaryLoader` here\r\nhttps://github.com/dotnet/machinelearning/blob/c023727b76970ab913ec1ce38276508835c17bcf/src/Microsoft.ML.Data/DataLoadSave/Binary/BinaryLoader.cs#L1184\r\nonly calls `Dispose` on the `System.IO.BinaryReader` it contains, which in turn only calls `Close` on `HybridMemoryStream`, but **not** `Dispose` (see https://referencesource.microsoft.com/#mscorlib/system/io/binaryreader.cs,91).  Therefore, the deletion of the temporary file here\r\nhttps://github.com/dotnet/machinelearning/blob/c023727b76970ab913ec1ce38276508835c17bcf/src/Microsoft.ML.Core/Utilities/HybridMemoryStream.cs#L127\r\nis never reached.\r\n\r\nThis is causing the temporary directory on my PC to fill up all the available space on the disk.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/367","RelatedDescription":"Closed issue \"Temporary file created by HybridMemoryStream in Transposer not deleted\" (#367)"},{"Id":"333390478","IsPullRequest":false,"CreatedAt":"2018-06-18T18:46:58","Actor":"TomFinley","Number":"371","RawContent":null,"Title":"Proposal for Major Change in API","State":"open","Body":"In this issue we describe a proposal to change the API. The core of the\r\nproposal is, instead of working via the entry-point runtime abstraction lying\r\non top of the implementing code, we encourage people to use the implementing\r\ncode directly.\r\n\r\n# Current State\r\n\r\nWithin ML.NET, for a component to be exposed in the \"public\" API, a component\r\nauthor follows the following steps (from an extremely high level):\r\n\r\n1. The author writes a component, implementing some sort of central interface.\r\n   Often this is something like `IDataLoader`, `IDataTransform`, `ITrainer,`\r\n   or some other such type of object.\r\n2. An \"entry-point\" wrapping object is created for that component. This is a\r\n   purely functional view of components as having inputs (as fields in some\r\n   sort of input class) and outputs (as fields in some sort of output class).\r\n   This is decorated with attributes, to allow the dependency injection\r\n   framework to do its work.\r\n3. A JSON \"manifest\" describing all such components is created, through some\r\n   process involving a scan of all `.dll`s and the aforementioned attributes.\r\n4. Some other code reads this JSON \"manifest\" and out of it generates a number\r\n   of C# classes. (This process being the code in `CSharpApiGenerator.cs`, the\r\n   artifact of which is described in `CSharpApi.cs`.)\r\n\r\nA user then works with this component in the following fashion.\r\n\r\n1. The user constructs a `LearningPipeline` object.\r\n2. They adds implementations of `ILearningPipelineItem`, which are sort of\r\n   configuration objects. (These are some of the objects that were code\r\n   generated.)\r\n3. Through some process that is probably too complex to describe here, these\r\n   `ILearningPipelineItem` are transmuted into a sort of abstract \"graph\"\r\n   structure comprised of inputs and outputs. (This is an \"entry-point\"\r\n   experiment graph.)\r\n4. This graph structure is then serialized to JSON, de-serialized back out of\r\n   JSON, then the actual underlying code that implements the operations is\r\n   loaded using dependency injection.\r\n5. Once loaded, the associated \"settings\" objects (which are actual types\r\n   explicitly written in ML.NET) have their fields populated from values in\r\n   this JSON.\r\n6. There is some higher level runtime coordinating this process of graph nodes\r\n   (the entry-point graph runner). This is a sort of runtime for the nodes,\r\n   and handles job scheduling, variable setting, and whatnot.\r\n\r\nThe way this process works is via something called entry-points. Entry-points\r\nwere conceived as a mechanism to enable a \"regular\" way to invoke ML.NET\r\ncomponents from native code, that was more expressive and powerful than the\r\ncommand line. Essentially: they are a command-line on steroids, that instead\r\nof inventing a new DSL utilizes JSON. This is effective at alleviating the\r\nburden of writing \"bridges\" from R and Python into ML.NET. It also has\r\nadvantages in situations where you need to send a sequence of commands \"over\r\nthe wire\" in some complex fashion. While a few types would need to be handled\r\n(e.g., standard numeric types, `IDataView`, `IFileHandle`, and some others),\r\nso long as the entry-points used *only* those supported types, composing an\r\nexperiment in those non-.NET environments would be possible.\r\n\r\n# Possible Alternate State\r\n\r\nInstead of working indirectly with ML.NET components through the entry-point\r\nabstraction, you could just instantiate and use the existing classes directly.\r\nThat is, the aforementioned `IDataLoader`, `IDataTransform`, `ITrainer,` and\r\nso forth would be instantiated and operated on directly.\r\n\r\nWhile entry-points would still be necessary for any components we wished to\r\nexpose through R or Python, we would constrain our usage to those applications\r\nwhere the added level of abstraction served some purpose.\r\n\r\nThis alternate pattern of usage is already well tested, as it actually\r\nreflects how ML.NET itself is written.\r\n\r\n# Changes for ML.NET\r\n\r\nIn order to move towards this state, a few high level adjustments will be\r\nnecessary.\r\n\r\n* Low level API is based direct instantiations of `IDataViews`/`ITrainer` and\r\n  other fundamental types and utilities already used within ML.NET code.\r\n* We will work to actively identify and improve that low level API from the\r\n  point of view of usage. See the sequel for more in depth discussion of this\r\n  point.\r\n* Writing higher level abstractions to make things easier should be\r\n  encouraged, however always with the aim of making them non-opaque. That is,\r\n  in edge cases when the abstraction fails, integrating what *can* be done\r\n  with the abstraction with the lower level explicit API should be possible.\r\n  Generally: Easy things should be easy and hard things should be possible.\r\n* To clarify: We are not getting rid of entry-points, because it remains the\r\n  mechanism by which interop from non-.NET programming environments into TLC\r\n  will continue to happen, and is therefore important. The shift is: the lower\r\n  level C# API will not use entry-points. For the purpose of servicing\r\n  GUI/Python/non-.NET bindings, we will continue in our own code to provide\r\n  entry points, while allowing user code to work by implementing the core\r\n  interfaces directly.\r\n\r\n# Examples of Potential Improvements in \"Direct Access\" API\r\n\r\nWe give the following concrete examples of areas that probably need\r\nimprovement. The examples are meant to be illustrative only. That is: the list\r\nis not exhaustive, nor are specific \"solutions\" to problems meant to convey\r\nthat something *must* be done in a particular way.\r\n\r\n* Instantiation of late binding components was previously always done via\r\n  dependency injection. Therefore, all components have constructors or static\r\n  create methods that have had *identical* signatures (e.g., for transforms,\r\n  `IHostEnvironment env, Arguments args, IDataView input`). Direct\r\n  instantiation by the user *could* use that, but would doubtless be better\r\n  served by a more contextually appropriate constructor that reflects common\r\n  use-cases. For example, this:\r\n\r\n  ```csharp\r\n  IDataTransform trans = new ConcatTransform(env, new ConcatTransform.Arguments()\r\n  {\r\n      Column = new[] {\r\n      new ConcatTransform.Column()\r\n      {\r\n          Name = \"NumericalFeatures\",\r\n          Source = new[] { \"SqftLiving\", \"SqftLot\", \"SqftAbove\",   \"SqftBasement\",\r\n              \"Lat\", \"Long\", \"SqftLiving15\", \"SqftLot15\" }\r\n      }}\r\n  }, loader);\r\n  ```\r\n\r\n  may become this:\r\n\r\n  ```csharp\r\n  IDataTransform trans = new ConcatTransform(env, loader, \"NumericalFeatures\",\r\n      \"SqftLiving\", \"SqftLot\", \"SqftAbove\", \"SqftBasement\", \"Lat\", \"Long\",\r\n      \"SqftLiving15\", \"SqftLot15\");\r\n  ```\r\n\r\n  This can work both ways: if these objects are directly instantiated, the\r\n  objects could provide richer information than merely being an\r\n  `IDataTransform`, or what have you. Due to working via the command line,\r\n  entry-points, or a GUI, it is considered almost useless for a component to\r\n  have any purely programmatic access. So for example: we could have had the\r\n  `AffineNormalizer` expose its slope and intercept, but we instead expose it\r\n  by metadata instead. A direct accessor in ML.NET may be appropriate if we\r\n  directly use these components.\r\n\r\n* Creating a transform and loader feels similar. However, creating a trainer,\r\n  using it to provide a predictor, and then ultimately parameterizing a scorer\r\n  transform with that predictor. Where possible we can try to harmonize the\r\n  interfaces to make them seem more consistent. (Obviously not always possible\r\n  since the underlying abstraction may in fact be genuinely different.)\r\n\r\n* Some parts of the current library introduce needless complexity: `Train`\r\n  method on trainer is `void`, always followed by `CreatePredictor`. Other\r\n  incidents of needless complexity may be less easy to resolve.\r\n\r\n* Some parts of the current library introduce *needful* complexity, but could\r\n  probably be improved somehow. `RoleMappedData` creation and usage, while\r\n  providing an essential service (\"use this column for this purpose\"), is\r\n  incredibly difficult to use. When it was just an \"internal\" structure we\r\n  just sort of dealt with it, but we would like to improve it. (In some cases\r\n  we can hide its creation into auxillary helper methods, for example.)\r\n\r\n* Simple things like improving naming of things may just help a lot. For\r\n  example: `ScoreUtils.GetScorer` returns a transform with the predictor's\r\n  scores applied to data. `ScoreUtils.GetScoredData` or something may be a\r\n  better name.\r\n\r\n* Our so-called \"internal\" methods do not always direct people towards pits of\r\n  success. For example: some pipeline components should probably apply only\r\n  during training (e.g., filtering, sampling, caching). Some distinction or\r\n  other engineering nicety (e.g., have the utilities for saving models throw\r\n  by default) may help warn people off this common misuse case.\r\n\r\n* Components of the existing API that deal with\r\n  late-binding/dependency-injection stuff could potentially use delegates or\r\n  something like entry-point style factory interfaces instead. This means\r\n  among other things lifting out things like `SubComponent` from most code.\r\n  Whether these delegates happen to be composed from the command line parser\r\n  calling `SubComponent.CreateInstance`, or some entry-point \"subgraph\"\r\n  generating a delegate out of its own graph, is the business of the command\r\n  line parser and entry-point engine, not the component code itself. (Maybe\r\n  the delegate just calls Run graph or something then binds the values.)\r\n\r\n  So for example what is currently this:\r\n\r\n```csharp\r\nnew Ova(env, new Ova.Argumnets() { Trainer = new SubComponent(\"sdcaR\") );\r\n```\r\n\r\nmight become this:\r\n\r\n```csharp\r\nnew Ova(env, host => new SdcaRegression(host));\r\n```\r\n\r\nNote that many of these enhancements will serve not only users, but component\r\nauthors (including us), and so improve the whole platform.\r\n\r\n# Miscellaneous Details\r\n\r\nNote that C# code generation from entry-point graphs will still be possible:\r\nall entry-point invocations come down to (1) defining input objects, (2)\r\ncalling a static method and (3) doing something with the output object.\r\nHowever it will probably not be possible to make it seem \"natural\" any more\r\nthan an attempt to do code-generation from a `mml` command line would seem\r\n\"natural.\"\r\n\r\nWhen we decided to make the public facing API entry-points based, this\r\nnecessarily required shifting related infrastructure (e.g., `GraphRunner`,\r\n`JsonManifestUtils`) into more central assemblies. Once that \"idiom\" is\r\ndeconstructed, this infrastructure should resume its prior state of being in\r\nan isolated assembly.\r\n\r\nAlong similar lines of isolation, once we shift the components to not use\r\n`SubComponent` directly, we can \"uplift\" what is currently the command line\r\nparsing code out into a separate assembly.","Url":"https://github.com/dotnet/machinelearning/issues/371","RelatedDescription":"Open issue \"Proposal for Major Change in API\" (#371)"},{"Id":"333367907","IsPullRequest":true,"CreatedAt":"2018-06-18T18:33:06","Actor":"eerhardt","Number":"370","RawContent":null,"Title":"Move the NuGet package build files into a TFM specific directory.","State":"closed","Body":"When installing Microsoft.ML on an unsupported framework (like net452), it is currently getting installed successfully. However, users should be getting an error stating that net452 is not supported by this package.\r\n\r\nThe cause is the build files exist for any TFM, which NuGet interprets as this package supports any TFM. Moving the build files to be consistent with the 'lib' folder support.\r\n\r\nFix #357","Url":"https://github.com/dotnet/machinelearning/pull/370","RelatedDescription":"Closed or merged PR \"Move the NuGet package build files into a TFM specific directory.\" (#370)"},{"Id":"332239075","IsPullRequest":false,"CreatedAt":"2018-06-18T18:33:05","Actor":"mairaw","Number":"357","RawContent":null,"Title":"Using ML.Net in Classic Windows Console or WPF App","State":"closed","Body":"@Dirkster99 commented on [Wed Jun 13 2018](https://github.com/dotnet/docs/issues/5937)\n\nI am currently evaluating the ML.Net library and get it to run with .Net Core:\r\nhttps://github.com/Dirkster99/ML\r\n\r\nbut I would like to also run it within a classic Windows console or WPF app (eg .Net 4.5.2).\r\n\r\nIs it possible to do this with the current Nuget?\r\nMy problem is that when I try to install the ML.Net Nuget package - the package manager says its installed (see output below). But the ML.Net package never shows up in the references section and I find it, thus, hard to use it in this context.\r\n\r\nIs this a current limitation of VS or an issue with the ML.Net nuget package? Is there a workaround solution?\r\n\r\n\r\nPackage Manager output log:\r\nAttempting to gather dependency information for package 'Microsoft.ML.0.2.0' with respect to project 'Classifier', targeting '.NETFramework,Version=v4.5.2'\r\nGathering dependency information took 70.64 ms\r\nAttempting to resolve dependencies for package 'Microsoft.ML.0.2.0' with DependencyBehavior 'Lowest'\r\nResolving dependency information took 0 ms\r\nResolving actions to install package 'Microsoft.ML.0.2.0'\r\nResolved actions to install package 'Microsoft.ML.0.2.0'\r\nRetrieving package 'Microsoft.ML 0.2.0' from 'nuget.org'.\r\nAdding package 'Microsoft.ML.0.2.0' to folder 'C:\\Users\\NOP\\Desktop\\Classifier\\packages'\r\nAdded package 'Microsoft.ML.0.2.0' to folder 'C:\\Users\\NOP\\Desktop\\Classifier\\packages'\r\nAdded package 'Microsoft.ML.0.2.0' to 'packages.config'\r\nSuccessfully installed 'Microsoft.ML 0.2.0' to Classifier\r\nExecuting nuget actions took 1.05 sec\r\nTime Elapsed: 00:00:01.3016144\r\n========== Finished ==========\r\n![screenshot](https://user-images.githubusercontent.com/2129700/41371517-e0e3db16-6f4a-11e8-975e-ca96a9390ee4.png)\r\n\n\n","Url":"https://github.com/dotnet/machinelearning/issues/357","RelatedDescription":"Closed issue \"Using ML.Net in Classic Windows Console or WPF App\" (#357)"},{"Id":"332197383","IsPullRequest":true,"CreatedAt":"2018-06-18T16:00:05","Actor":"TomFinley","Number":"356","RawContent":null,"Title":"Use HideEnumValueAttribute for both manifest and C# API generation.","State":"closed","Body":"Fixes #341, so that `HideEnumValueAttribute` is used not only in command line help usage but also the other late binding scheme depending on arguments, entry-points. This PR will also allow a more natural solution to #293 to be engineered.","Url":"https://github.com/dotnet/machinelearning/pull/356","RelatedDescription":"Closed or merged PR \"Use HideEnumValueAttribute for both manifest and C# API generation.\" (#356)"},{"Id":"333254627","IsPullRequest":true,"CreatedAt":"2018-06-18T12:47:22","Actor":"ross-p-smith","Number":"368","RawContent":null,"Title":"Return distinct array of ParameterSet when ProposeSweep is called","State":"open","Body":"This is associated with #215 \r\n\r\nThe ProposeSweep method built a List<ParameterSet> to return, I have changed this to a HashSet<ParameterSet> so that duplicates could not be added. I have also ensured that ParameterSet implements GetHashCode so that equality is calculated properly\r\n\r\nTests have been added to the solution. \r\n\r\nThanks to @Nepomuceno for working on this with me and this could be seen as a duplicate of #365 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/368","RelatedDescription":"Open PR \"Return distinct array of ParameterSet when ProposeSweep is called\" (#368)"},{"Id":"333102248","IsPullRequest":false,"CreatedAt":"2018-06-17T23:41:13","Actor":"SharPiy","Number":"366","RawContent":null,"Title":".NET Framework 4.6.1 - ML.NET package does't show up in references, thus can't use its assembly references. ","State":"open","Body":"### System information\r\n\r\n- Windows 7/ 64 bit OS\r\n- .NET Framework 4.6.1 \r\n\r\n### Issue\r\n\r\n- I created a console App to use Microsoft.ML. I tried to install ML.NET package -  the package manager successfully installed it but it never shows up in references. \r\n- I am not able to use ML.NET libraries, as even after successfully installing it the using statements gives me red lines to show missing assembly reference error.\r\n![capture](https://user-images.githubusercontent.com/39928473/41513174-d9a50140-724c-11e8-9ec4-8a297304b014.PNG)\r\n![image](https://user-images.githubusercontent.com/39928473/41513187-084c47e2-724d-11e8-8b42-1d248c98ad7b.png)\r\n![image](https://user-images.githubusercontent.com/39928473/41513204-3986b1ee-724d-11e8-9435-c1bb66003d72.png)\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/366","RelatedDescription":"Open issue \".NET Framework 4.6.1 - ML.NET package does't show up in references, thus can't use its assembly references. \" (#366)"},{"Id":"332859834","IsPullRequest":true,"CreatedAt":"2018-06-15T17:39:09","Actor":"yaeldekel","Number":"364","RawContent":null,"Title":"Combine multiple tree ensemble models into a single tree ensemble","State":"open","Body":"Create a single tree ensemble, by dividing the leaf outputs by the number of ensembles being combined, and multiplying by the calibration parameter if it exists.","Url":"https://github.com/dotnet/machinelearning/pull/364","RelatedDescription":"Open PR \"Combine multiple tree ensemble models into a single tree ensemble\" (#364)"},{"Id":"332537019","IsPullRequest":true,"CreatedAt":"2018-06-14T19:38:44","Actor":"Ivanidzo4ka","Number":"363","RawContent":null,"Title":"add pipelineitem for Ova","State":"open","Body":"Address #34.\r\nThis PR add wrapper on top of OVA to make it pipeline friendly.","Url":"https://github.com/dotnet/machinelearning/pull/363","RelatedDescription":"Open PR \"add pipelineitem for Ova\" (#363)"},{"Id":"332465037","IsPullRequest":true,"CreatedAt":"2018-06-14T15:58:46","Actor":"Nepomuceno","Number":"362","RawContent":null,"Title":"Removing non source files from solution","State":"open","Body":"According to the discussion on the issue #322 I am proposing removing all non source files from the solution file in order to keep consistency and to keep the solution clean.\r\n","Url":"https://github.com/dotnet/machinelearning/pull/362","RelatedDescription":"Open PR \"Removing non source files from solution\" (#362)"},{"Id":"332453998","IsPullRequest":true,"CreatedAt":"2018-06-14T15:30:52","Actor":"Nepomuceno","Number":"361","RawContent":null,"Title":"Correcting error messages according to the instructions on ","State":"open","Body":"#258 \r\n\r\nCorrecting error messages to reflect the issues page. ","Url":"https://github.com/dotnet/machinelearning/pull/361","RelatedDescription":"Open PR \"Correcting error messages according to the instructions on \" (#361)"},{"Id":"332411141","IsPullRequest":false,"CreatedAt":"2018-06-14T13:48:15","Actor":"nsulikowski","Number":"360","RawContent":null,"Title":"Problem with ColumnCopier","State":"open","Body":"I wrapped ML.NET as Excel functions using ExcelDNA.\r\nEverything works except ColumnCopier (for some strange reason).\r\nMay be ColumnCopier tries to emit code which might now work in that context?\r\nIt'll take me too long to create a replication example... but hopefully this general comment is enough to find the problem.","Url":"https://github.com/dotnet/machinelearning/issues/360","RelatedDescription":"Open issue \"Problem with ColumnCopier\" (#360)"},{"Id":"332374252","IsPullRequest":true,"CreatedAt":"2018-06-14T12:09:29","Actor":"jwood803","Number":"359","RawContent":null,"Title":"Update error messages to point to GitHub issues instead of support group","State":"open","Body":"Fix for issue #258 by replacing `tlcsupp` with a link to https://aka.ms/MLNetIssue.\r\n\r\nDue to my lacking git skills, some commits from #358 got in, but I believe that can get cleaned up if/when it gets merged.","Url":"https://github.com/dotnet/machinelearning/pull/359","RelatedDescription":"Open PR \"Update error messages to point to GitHub issues instead of support group\" (#359)"},{"Id":"332076809","IsPullRequest":true,"CreatedAt":"2018-06-13T21:33:45","Actor":"danmosemsft","Number":"355","RawContent":null,"Title":"Add link to samples","State":"closed","Body":"","Url":"https://github.com/dotnet/machinelearning/pull/355","RelatedDescription":"Closed or merged PR \"Add link to samples\" (#355)"},{"Id":"331752523","IsPullRequest":false,"CreatedAt":"2018-06-13T19:37:58","Actor":"Ivanidzo4ka","Number":"350","RawContent":null,"Title":"We no longer need dependency on System.ValueTuple","State":"closed","Body":"No point to drag additional dependency for package which we no longer consume.","Url":"https://github.com/dotnet/machinelearning/issues/350","RelatedDescription":"Closed issue \"We no longer need dependency on System.ValueTuple\" (#350)"},{"Id":"331752651","IsPullRequest":true,"CreatedAt":"2018-06-13T19:37:52","Actor":"Ivanidzo4ka","Number":"351","RawContent":null,"Title":"Remove reference and dependency on System.ValueTuple","State":"closed","Body":"address #350 ","Url":"https://github.com/dotnet/machinelearning/pull/351","RelatedDescription":"Closed or merged PR \"Remove reference and dependency on System.ValueTuple\" (#351)"},{"Id":"332074884","IsPullRequest":false,"CreatedAt":"2018-06-13T16:37:48","Actor":"jfcarr","Number":"354","RawContent":null,"Title":"TextLoader CreateFrom useHeader usage is confusing","State":"open","Body":"Example:\r\n\r\n`pipeline.Add(new TextLoader(_datapath).CreateFrom<SampleModel>(useHeader: true, separator: ','));`\r\n\r\nThe usage of the useHeader argument is not intuitive, based on the name.  The name \"useHeader\" implies that a value of **true** will cause the header line to be included when loading the model.  In reality, setting useHeader to **true** causes the header line to be skipped.  Perhaps something like \"excludeHeader\", or \"ignoreHeader\", instead?  Or, if you'd prefer something that simply indicates the presence of a header line, versus an action to be taken, maybe \"containsHeader\"?\r\n\r\nUsing ML version 0.2.0 in a .NET Core 2 console app.","Url":"https://github.com/dotnet/machinelearning/issues/354","RelatedDescription":"Open issue \"TextLoader CreateFrom useHeader usage is confusing\" (#354)"},{"Id":"332030298","IsPullRequest":false,"CreatedAt":"2018-06-13T14:49:44","Actor":"atotalnoob","Number":"353","RawContent":null,"Title":"Need better support for using JSON files as a training dataset","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: Windows 10\r\n- **.NET Version (eg., dotnet --info)**: Version 2.1.200 \r\n\r\n### Issue\r\n\r\n- **What did you do?** I want to use a JSON file as my training data. \r\n- **What happened?** Throws error `System.ArgumentOutOfRangeException: 'Could not determine an IDataView type for member Patterns'`\r\n- **What did you expect?** To be able to use my json file to train a ML model. \r\n\r\n### Source code / logs\r\n\r\nJSON File (Abbreviated here for brevity, but its all the same):\r\n```\r\n[\r\n    {\r\n      \"Label\": \"greeting\",\r\n      \"Patterns\": [ \"Hi\", \"How are you\", \"Is anyone there?\", \"Hello\", \"Good day\" ]\r\n    },\r\n    {\r\n      \"Label\": \"goodbye\",\r\n      \"Patterns\": [ \"Bye\", \"See you later\", \"Goodbye\" ]\r\n    }\r\n]\r\n\r\n```\r\n\r\nClass I am deserializing into: \r\n\r\n```\r\n  public class Intent\r\n    {\r\n        [Column(\"0\")]\r\n        [ColumnName(\"Label\")]\r\n        public string Label;\r\n        [Column(\"1\")]\r\n        public List<string> Patterns = new List<string>();\r\n    }\r\n```\r\n\r\nLoading in the data using:\r\n```\r\n    public static class IntentLoader\r\n    {\r\n\r\n        public static List<Intent> LoadIntentData()\r\n        {\r\n            var fileContents = System.IO.File.ReadAllText(\"intents.json\");\r\n\r\n            try\r\n            {\r\n               var intents = JsonConvert.DeserializeObject<List<Intent>>(fileContents);\r\n                return intents;\r\n            }\r\n            catch (Exception e)\r\n            {\r\n\r\n                throw e;\r\n            }\r\n            \r\n        }\r\n    }\r\n```\r\npipeline:\r\n```\r\n public LearningPipeline GetPipeline()\r\n        {\r\n            var intents = IntentLoader.LoadIntentData();\r\n            var collection = CollectionDataSource.Create(intents);\r\n            var pipeline = new LearningPipeline();\r\n            pipeline.Add(collection);\r\n            pipeline.Add(new ColumnConcatenator(outputColumn: \"Features\", \"Patterns\"));\r\n            pipeline.Add(new Dictionarizer(\"Label\"));\r\n            pipeline.Add(new StochasticDualCoordinateAscentClassifier());\r\n            pipeline.Add(new PredictedLabelColumnOriginalValueConverter() { PredictedLabelColumn = \"PredictedLabel\" });\r\n\r\n            return pipeline;\r\n        }\r\n```\r\nModel training (exception happens here):\r\n```\r\n public PredictionModel<Intent, IntentPrediction> Train()\r\n        {\r\n            var pipeline = GetPipeline();\r\n            var model = pipeline.Train<Intent, IntentPrediction>(); //exception thrown here\r\n            return model;\r\n        }\r\n```\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/353","RelatedDescription":"Open issue \"Need better support for using JSON files as a training dataset\" (#353)"},{"Id":"332027543","IsPullRequest":false,"CreatedAt":"2018-06-13T14:43:44","Actor":"atotalnoob","Number":"352","RawContent":null,"Title":"Can't use getter/setters in objects ","State":"open","Body":"### System information\r\n\r\n- **OS version/distro**: Windows 10\r\n- **.NET Version (eg., dotnet --info)**: 2.1.200\r\n\r\n### Issue\r\n\r\n- **What did you do?** Trying to use a JSON object that has been deserialized into C# classes\r\n- **What happened?** Using getter/setters causes errors with trying to decorate the columns. \r\nOkay:\r\n[Column(\"0\")]\r\npublic string Label;\r\nNot okay:\r\n[Column(\"0\")]\r\npublic string Label { get; set; }\r\n\r\n- **What did you expect?** To be able to use getter/setters. Without them, it makes everything a PITA\r\n\r\n### Source code / logs\r\n\r\nPlease paste or attach the code or logs or traces that would be helpful to diagnose the issue you are reporting.\r\n\r\nClass I am using to deserialize: \r\n\r\n```\r\n    public class Intent\r\n    {\r\n        [Column(\"0\")]\r\n        [ColumnName(\"Label\")]\r\n        public string Label;\r\n        [Column(\"1\")]\r\n        public List<string> Patterns = new List<string>();\r\n    }\r\n\r\n```\r\n\r\nLoading in intent data with this:\r\n\r\n```\r\n public static class IntentLoader\r\n    {\r\n\r\n        public static List<Intent> LoadIntentData()\r\n        {\r\n            var fileContents = System.IO.File.ReadAllText(\"intents.json\");\r\n\r\n            try\r\n            {\r\n               var intents = JsonConvert.DeserializeObject<List<Intent>>(fileContents);\r\n                return intents;\r\n            }\r\n            catch (Exception e)\r\n            {\r\n\r\n                throw e;\r\n            }\r\n            \r\n        }\r\n    }\r\n```\r\n","Url":"https://github.com/dotnet/machinelearning/issues/352","RelatedDescription":"Open issue \"Can't use getter/setters in objects \" (#352)"},{"Id":"331484059","IsPullRequest":true,"CreatedAt":"2018-06-12T23:22:43","Actor":"justinormont","Number":"348","RawContent":null,"Title":"Minor formatting in CollectionDataSourceTests.cs","State":"closed","Body":"Corrects misplaced spaces in CollectionDataSourceTests.cs","Url":"https://github.com/dotnet/machinelearning/pull/348","RelatedDescription":"Closed or merged PR \"Minor formatting in CollectionDataSourceTests.cs\" (#348)"},{"Id":"331705127","IsPullRequest":false,"CreatedAt":"2018-06-12T18:36:29","Actor":"rogancarr","Number":"349","RawContent":null,"Title":"Enable fault tolerance in FastTree for distributed learning","State":"open","Body":"As we plan to add distributed training to ML.NET, we have to consider Fault Tolerance of the individual worker nodes. In the case of FastTree, fault tolerance for individual workers has two requirements:\r\n- Failed FastTree workers must be restarted in the current state of the calculation\r\n- Non-failing workers must respond to failures in the IParallelTraining components*\r\n\r\n*This response depends on the implementation of fault tolerance.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/349","RelatedDescription":"Open issue \"Enable fault tolerance in FastTree for distributed learning\" (#349)"},{"Id":"331285976","IsPullRequest":false,"CreatedAt":"2018-06-12T17:20:49","Actor":"zeahmed","Number":"345","RawContent":null,"Title":"CSharpApiGenerator.cs does not generate compile-able code...","State":"closed","Body":"CSharpApiGenerator.cs does not generate compile-able code. Some types have been moved around in different namespaces which are causing error during compilation.\r\n\r\nThis happened after the PR #61 was merged. \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/345","RelatedDescription":"Closed issue \"CSharpApiGenerator.cs does not generate compile-able code...\" (#345)"},{"Id":"331043393","IsPullRequest":true,"CreatedAt":"2018-06-12T03:17:49","Actor":"BeanHsiang","Number":"344","RawContent":null,"Title":"enabled developer naming their column same as valid v…","State":"closed","Body":"fiexed for #318，enabled developer naming their column same as valid variable name","Url":"https://github.com/dotnet/machinelearning/pull/344","RelatedDescription":"Closed or merged PR \"enabled developer naming their column same as valid v…\" (#344)"},{"Id":"331369471","IsPullRequest":false,"CreatedAt":"2018-06-11T22:14:20","Actor":"zeahmed","Number":"347","RawContent":null,"Title":"Use schema from trained model instead of inferring it again from type when creating prediction engine.","State":"open","Body":"### System information\r\n\r\n- **Windows/Linux/MacOS**:\r\n- **.NET Version: 2.1.200**: \r\n\r\n### Issue\r\n\r\n- **Defining custom schema using TextLoaderArguments in TextLoader?**\r\n- **Training failed when creating prediction engine?**\r\n- **Expect that `CreateBatchPredictionEngine` should use schema from trained model instead of inferring schema again from input type?**\r\n\r\n### Source code / logs\r\n\r\n``` C#\r\npublic class IrisData\r\n{\r\n    public float Label;\r\n\r\n    public float[] Features;\r\n}\r\n\r\npublic class IrisPrediction\r\n{\r\n    [ColumnName(\"Score\")]\r\n    public float[] PredictedLabels;\r\n}\r\n        \r\npublic void SampleTest()\r\n{\r\n    string dataPath = GetDataPath(\"iris.txt\");\r\n\r\n    var pipeline = new LearningPipeline(seed: 1, conc: 1);\r\n\r\n    pipeline.Add(new TextLoader(dataPath)\r\n    {\r\n        Arguments = new TextLoaderArguments\r\n        {\r\n            Separator = new[] { '\\t' },\r\n            HasHeader = true,\r\n            Column = new[]\r\n            {\r\n                new TextLoaderColumn()\r\n                {\r\n                    Name = \"Label\",\r\n                    Source = new [] { new TextLoaderRange(0) },\r\n                    Type = Runtime.Data.DataKind.Num\r\n                },\r\n\r\n                new TextLoaderColumn()\r\n                {\r\n                    Name = \"Features\",\r\n                    Source = new [] { new TextLoaderRange(1,4) },\r\n                    Type = Runtime.Data.DataKind.Num\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    pipeline.Add(new StochasticDualCoordinateAscentClassifier()\r\n    {\r\n        NormalizeFeatures = NormalizeOption.No\r\n    });\r\n\r\n    PredictionModel<IrisData, IrisPrediction> model = pipeline.Train<IrisData, IrisPrediction>();\r\n\r\n    IrisPrediction prediction = model.Predict(new IrisData()\r\n    {\r\n        Features = new[] { 3.3f, 1.6f, 0.2f, 5.1f }\r\n    });\r\n\r\n    Assert.Equal(1, prediction.PredictedLabels[0], 2);\r\n    Assert.Equal(0, prediction.PredictedLabels[1], 2);\r\n    Assert.Equal(0, prediction.PredictedLabels[2], 2);\r\n}\r\n```\r\n","Url":"https://github.com/dotnet/machinelearning/issues/347","RelatedDescription":"Open issue \"Use schema from trained model instead of inferring it again from type when creating prediction engine.\" (#347)"},{"Id":"331310502","IsPullRequest":false,"CreatedAt":"2018-06-11T19:01:13","Actor":"helloguo","Number":"346","RawContent":null,"Title":"ParallelTraining API","State":"open","Body":"Can anyone explain what `ParallelTraining` is and how to use it? And what's the difference between `ParallelTraining` and `SingleParallelTraining`?\r\n","Url":"https://github.com/dotnet/machinelearning/issues/346","RelatedDescription":"Open issue \"ParallelTraining API\" (#346)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-06-19T05:30:36.9320437Z","RunDurationInMilliseconds":998}