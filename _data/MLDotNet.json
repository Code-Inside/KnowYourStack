{"Data":{"GitHub":{"Issues":[{"Id":"335070811","IsPullRequest":false,"CreatedAt":"2018-06-23T05:31:51","Actor":"sarthakmalik","Number":"399","RawContent":null,"Title":"Passing CollectionDataSource w/ SQL dependency throws \"System.ArgumentOutOfRangeException: Source column not found\"","State":"open","Body":"### Issue\r\nPassing a `CollectionDataSource.Create<T>(data: var)` to `pipeline.Add(var)` returns null values when referencing SQL Db via EF Core as the data source. Note that the latest version of ML.Net (0.20) is currently indicated as a dependency in the .csproj.\r\n\r\nInspecting the object indicates a valid state of data returned from the table but loaded as null into the pipeline however, I am not clear if the bug is attributable to the dataloader or its use. Any guidelines or help on the corrected implementation of parsing data from SQL Server is much appreciated.\r\n\r\n\r\n### Implementation\r\n\r\n**genericClass.cs**\r\n```\r\npublic partial class GenericClass {\r\n    public int CustomerId { get; set; }\r\n    public float PurchaseAmt { get; set; }\r\n    public string OrderType { get; set; }\r\n}\r\n\r\npublic partial class GenericPredictionClass {\r\n    [ColumnName(\"Score\")]\r\n    public float PredictedAmt;\r\n}\r\n```\r\n\r\n**sampleController.cs**\r\n```\r\npublic async Task<IActionResult> ShowOutput() {\r\n    PredictionModel<GenericClass, GenericPredictionClass> model = await TrainAsync();\r\n    \r\n    return View();\r\n}\r\n\r\nprivate Task<List<GenericClass> LoadDataFromSql() {\r\n    var sqlTblOutput = _context.Table1\r\n        .Take(1000);\r\n\r\n    return Task.Run(function: () => sqlTblOutput.ToList());\r\n}\r\n\r\nprivate async Task<PredictionModel<GenericClass, GenericPredictionClass>> TrainAsync() {\r\n    var pipeline = new LearningPipeline();\r\n    List<GenericClass> parseData = await LoadDataFromSql();\r\n    var dataReference = CollectionDataSource.Create<GenericClass>(data: parseData);\r\n\r\n    pipeline.Add(dataReference);\r\n    pipeline.Add(new CategoricalOneHotVectorizer(\"OrderType\"));\r\n   \r\n    ...\r\n\r\n    return model;\r\n}\r\n```\r\n\r\n\r\n\r\n### Locals\r\n\r\n```\r\npipeline: {Microsoft.ML.LearningPipeline}\r\n    Rows [PipelineItemDebugRow[]]: {Microsoft.ML.PipelineItemDebugRow[10]}\r\n        [0] [PipelineItemDebugRow]: \"\"\r\n            Values [string]: \"\"\r\n\r\n\r\nparseData [List]: Count = 1000\r\n    [0]: {Namespace.Models.GenericClass}\r\n        CustomerId: 1234\r\n        PurchaseAmt: 40.99\r\n        OrderType [string]: \"Test Order\"\r\n\r\n\r\ndataReference [ILearningPipelineLoader]: {Microsoft.ML.Data.CollectionDataSource.ListDataSource<Namespace.Models.GenericClass>}\r\n    Non-Public members\r\n        _dataView [IDataView]: null\r\n        _dataViewEntryPoint [DataViewReference]: null\r\n        _listCollection [IList]: Count = 1000\r\n            [0]: {Namespace.Models.GenericClass}\r\n                CustomerId: 1234\r\n                PurchaseAmt: 40.99\r\n                OrderType [string]: \"Test Order\"\r\n```\r\n\r\n\r\n### Log\r\n\r\n`\r\n\"System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.ArgumentOutOfRangeException: Source column OrderType not found\\nParameter name: Source\\n   at Microsoft.ML.Runtime.Data.OneToOneTransformBase.Bindings.Create(OneToOneTransformBase parent, OneToOneColumn[] column, ISchema input, ITransposeSchema transInput, Func2 testType)\\n   at Microsoft.ML.Runtime.Data.OneToOneTransformBase..ctor(IHostEnvironment env, String name, OneToOneColumn[] column, IDataView input, Func2 testType)\\n   at Microsoft.ML.Runtime.Data.TermTransform..ctor(ArgumentsBase args, ColumnBase[] column, IHostEnvironment env, IDataView input)\\n   at Microsoft.ML.Runtime.Data.CategoricalTransform.Create(IHostEnvironment env, Arguments args, IDataView input)\\n   at Microsoft.ML.Runtime.Data.Categorical.CatTransformDict(IHostEnvironment env, Arguments input)\\n   --- End of inner exception stack trace ---\\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Object[] arguments, Signature sig, Boolean constructor, Boolean wrapExceptions)\\n   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\\n   at Microsoft.ML.Runtime.EntryPoints.EntryPointNode.Run()\\n   at Microsoft.ML.Runtime.EntryPoints.EntryPointGraph.RunNode(EntryPointNode node)\\n   at Microsoft.ML.Runtime.EntryPoints.JsonUtils.GraphRunner.RunAllNonMacros()\\n   at Microsoft.ML.Runtime.EntryPoints.JsonUtils.GraphRunner.RunAll()\\n   at Microsoft.ML.LearningPipeline.Execute(IHostEnvironment environment)\\n   at Microsoft.ML.LearningPipelineDebugProxy.ExecutePipeline()\"\r\n`\r\n\r\n### System information\r\n\r\n- **Distro**: Fedora 28 (latest)\r\n- **.NET Version**:  2.1.301\r\n- **ML.NET Package version**: 0.2.0","Url":"https://github.com/dotnet/machinelearning/issues/399","RelatedDescription":"Open issue \"Passing CollectionDataSource w/ SQL dependency throws \"System.ArgumentOutOfRangeException: Source column not found\"\" (#399)"},{"Id":"334571015","IsPullRequest":false,"CreatedAt":"2018-06-22T23:23:12","Actor":"sfilipi","Number":"390","RawContent":null,"Title":"Add documentation about Entry Points","State":"closed","Body":"Add initial documentation about what entry points, entry points manifests are, and what classes related to them. \r\n","Url":"https://github.com/dotnet/machinelearning/issues/390","RelatedDescription":"Closed issue \"Add documentation about Entry Points\" (#390)"},{"Id":"335020532","IsPullRequest":false,"CreatedAt":"2018-06-22T21:11:54","Actor":"glebuk","Number":"398","RawContent":null,"Title":"Expose Microsoft.ML.Core NuGet for component authors.","State":"open","Body":"Currently there is a single NuGet package \"Microsoft.ML\"  that contains both algorithms and the common framework.\r\n\r\nThere are two major usages for the ML.NET: \r\n1. Author end-user applications that use ML.NET for training and inference\r\n2. Author new ML.NET Components, such as trainers, loaders or transforms.\r\n\r\nThe needs of two use cases are different.  For the former, we need everything that is currently included in Microsoft.ML.  For the latter, only the base, common interfaces and utilities are needed, such as IDataView.\r\n\r\nProposal:\r\n- Define additional NuGet package Microsoft.ML.Core that only contains  core, math and related common utils.\r\n- Modify Microsoft.ML to depend on  Microsoft.ML.Core.","Url":"https://github.com/dotnet/machinelearning/issues/398","RelatedDescription":"Open issue \"Expose Microsoft.ML.Core NuGet for component authors.\" (#398)"},{"Id":"335017929","IsPullRequest":true,"CreatedAt":"2018-06-22T21:01:35","Actor":"yaeldekel","Number":"397","RawContent":null,"Title":"Create a shorter temp file name for model loading.","State":"open","Body":"Fixes #396\r\n","Url":"https://github.com/dotnet/machinelearning/pull/397","RelatedDescription":"Open PR \"Create a shorter temp file name for model loading.\" (#397)"},{"Id":"335017738","IsPullRequest":false,"CreatedAt":"2018-06-22T21:00:57","Actor":"yaeldekel","Number":"396","RawContent":null,"Title":"Temp path created for model loading is too long","State":"open","Body":"We should create a shorter file name in case the path is long.","Url":"https://github.com/dotnet/machinelearning/issues/396","RelatedDescription":"Open issue \"Temp path created for model loading is too long\" (#396)"},{"Id":"335012603","IsPullRequest":false,"CreatedAt":"2018-06-22T20:41:23","Actor":"yaeldekel","Number":"395","RawContent":null,"Title":"EvaluatorUtils should handle key label columns with non-text key values","State":"open","Body":"When CV needs to concatenate the per-instance data views, it needs to reconcile the key values from the different folds, even if the key values are not text.","Url":"https://github.com/dotnet/machinelearning/issues/395","RelatedDescription":"Open issue \"EvaluatorUtils should handle key label columns with non-text key values\" (#395)"},{"Id":"335011922","IsPullRequest":true,"CreatedAt":"2018-06-22T20:38:42","Actor":"yaeldekel","Number":"394","RawContent":null,"Title":"EvaluatorUtils to handle label column of type key without text key values","State":"open","Body":"If the label column is a key converted from something other than text, \r\nFixes #395 ","Url":"https://github.com/dotnet/machinelearning/pull/394","RelatedDescription":"Open PR \"EvaluatorUtils to handle label column of type key without text key values\" (#394)"},{"Id":"334959553","IsPullRequest":true,"CreatedAt":"2018-06-22T17:29:20","Actor":"sfilipi","Number":"393","RawContent":null,"Title":"Adding xml style documentation for trainers","State":"open","Body":"Adding xml style documentation for trainers, to improve what's currently on docs.microsoft.com. \r\n\r\nAdresses #388 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/393","RelatedDescription":"Open PR \"Adding xml style documentation for trainers\" (#393)"},{"Id":"334771594","IsPullRequest":true,"CreatedAt":"2018-06-22T07:17:40","Actor":"codemzs","Number":"392","RawContent":null,"Title":"LightGBM ","State":"open","Body":"LightGBM integration. This change adds API for LightGBM binary and multiclass classifier.\r\n\r\nfixes #391 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/392","RelatedDescription":"Open PR \"LightGBM \" (#392)"},{"Id":"334770266","IsPullRequest":false,"CreatedAt":"2018-06-22T07:12:05","Actor":"codemzs","Number":"391","RawContent":null,"Title":"Port LightGBM ","State":"open","Body":"Integration for LightGBM for binary and multiclass classification problems.","Url":"https://github.com/dotnet/machinelearning/issues/391","RelatedDescription":"Open issue \"Port LightGBM \" (#391)"},{"Id":"334529439","IsPullRequest":false,"CreatedAt":"2018-06-21T14:49:19","Actor":"sfilipi","Number":"389","RawContent":null,"Title":"Improve the documentation on the transform classes","State":"open","Body":"Documentation on the transform classes at [docs.microsoft.com](https://docs.microsoft.com) needs to be expanded. ","Url":"https://github.com/dotnet/machinelearning/issues/389","RelatedDescription":"Open issue \"Improve the documentation on the transform classes\" (#389)"},{"Id":"334528569","IsPullRequest":false,"CreatedAt":"2018-06-21T14:47:20","Actor":"sfilipi","Number":"388","RawContent":null,"Title":"Improve the documentation on the trainer classes. ","State":"open","Body":"The documentation describing the trainers on [docs.microsoft.com ](https://docs.microsoft.com) needs to be expanded. \r\n","Url":"https://github.com/dotnet/machinelearning/issues/388","RelatedDescription":"Open issue \"Improve the documentation on the trainer classes. \" (#388)"},{"Id":"334256239","IsPullRequest":false,"CreatedAt":"2018-06-21T08:27:39","Actor":"codemzs","Number":"387","RawContent":null,"Title":"Example on converting ML.NET model to ONNX.","State":"closed","Body":"Add a link to an example for Convert to ONNX API.","Url":"https://github.com/dotnet/machinelearning/issues/387","RelatedDescription":"Closed issue \"Example on converting ML.NET model to ONNX.\" (#387)"},{"Id":"334255079","IsPullRequest":true,"CreatedAt":"2018-06-21T08:27:39","Actor":"codemzs","Number":"386","RawContent":null,"Title":"Link to an example on using converting ML.NET model to ONNX.","State":"closed","Body":"fixes #387 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/386","RelatedDescription":"Closed or merged PR \"Link to an example on using converting ML.NET model to ONNX.\" (#386)"},{"Id":"334221807","IsPullRequest":true,"CreatedAt":"2018-06-20T20:59:31","Actor":"yaeldekel","Number":"385","RawContent":null,"Title":"Fix CV macro to output the warnings data view properly.","State":"closed","Body":"Fixes #384 .","Url":"https://github.com/dotnet/machinelearning/pull/385","RelatedDescription":"Closed or merged PR \"Fix CV macro to output the warnings data view properly.\" (#385)"},{"Id":"334221002","IsPullRequest":false,"CreatedAt":"2018-06-20T20:59:31","Actor":"yaeldekel","Number":"384","RawContent":null,"Title":"The warnings data view in CV macro is always null","State":"closed","Body":"The inputs and outputs are not being wired correctly in the macro, resulting in a null for the warnings data view.","Url":"https://github.com/dotnet/machinelearning/issues/384","RelatedDescription":"Closed issue \"The warnings data view in CV macro is always null\" (#384)"},{"Id":"334156657","IsPullRequest":true,"CreatedAt":"2018-06-20T16:28:28","Actor":"sfilipi","Number":"383","RawContent":null,"Title":"Adding Factorization Machines ","State":"open","Body":"Adding FactorizationMachines and a test for it. \r\nAddresses #381 \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/383","RelatedDescription":"Open PR \"Adding Factorization Machines \" (#383)"},{"Id":"334137577","IsPullRequest":false,"CreatedAt":"2018-06-20T15:41:23","Actor":"justinormont","Number":"382","RawContent":null,"Title":"Roadmap can be read as saying we don't support text","State":"open","Body":"In a recent StackOverflow answer, our [Roadmap ](https://github.com/dotnet/machinelearning/blob/c023727b76970ab913ec1ce38276508835c17bcf/ROADMAP.md#featurization-improvements) was seemingly interpreted it to say that text/NLP is a purely future work item. \r\n\r\nThe roadmap currently says:\r\n> ### Featurization Improvements\r\n> * Text  (*)\r\n>   * Natural language text preprocessing such as tokenization, part-of-speech tagging, and sentence > breaking\r\n>   * Pre-trained text models that can be used for extracting of semantic or sentiment features from text\r\n> * Image  (*)\r\n>   * Image preprocessing such as loading, resizing, and normalization if images\r\n>   * Image featurization, including industry-standard pre-trained ImageNet neural models, such as ResNet and AlexNet\r\n\r\n\r\n\r\nWe should change the roadmap to indicate that further text/NLP techniques like pre-trained WordEmbedding models, _improvements_ to tokenization, etc. are on the roadmap, whereas text handling, in the form of n-grams, already exists.","Url":"https://github.com/dotnet/machinelearning/issues/382","RelatedDescription":"Open issue \"Roadmap can be read as saying we don't support text\" (#382)"},{"Id":"334122701","IsPullRequest":false,"CreatedAt":"2018-06-20T15:06:13","Actor":"sfilipi","Number":"381","RawContent":null,"Title":"Add Factorization Machines to ML.NET","State":"open","Body":"Add the train a field-aware factorization machine algorithm to ML.NET as described in the following papers:\r\n[1] http://jmlr.org/papers/volume12/duchi11a/duchi11a.pdf\r\n[2] http://www.csie.ntu.edu.tw/~cjlin/papers/ffm.pdf\r\n[3] https://github.com/wschin/fast-ffm\r\n","Url":"https://github.com/dotnet/machinelearning/issues/381","RelatedDescription":"Open issue \"Add Factorization Machines to ML.NET\" (#381)"},{"Id":"333882804","IsPullRequest":false,"CreatedAt":"2018-06-20T00:20:42","Actor":"zeahmed","Number":"380","RawContent":null,"Title":"Create convenience constructor for the Transforms (workitem related to #371)","State":"open","Body":"This work item is related to the new API proposal #371 \r\n\r\nFollowing is the initial list of transforms that will be implemented to gather feedback.\r\n- BootstrapSampleTransform\r\n- CategoricalHashTransform\r\n- CategoricalTransform\r\n- ConcatTransform\r\n- CopyColumnsTransform\r\n- CountFeatureSelection\r\n- DropColumnsTransform\r\n- LpNormNormalizerTransform\r\n- NAFilter\r\n- NormalizeTransform\r\n\r\nThere are different ways to create a public facing API for these transforms based on their class definition.\r\n\r\n### Add `Convenience` constructor directly to the transform class.\r\n\r\n It is only possible for following type of transforms. \r\n\r\n   - BootstrapSampleTransform\r\n   - ConcatTransform\r\n   - NAFilter\r\n\r\n### Add `Create` method (a helper method) for transforms that have `Create` method already implemented. \r\n\r\nThis is possible for following transforms.\r\n\r\n   - CategoricalHashTransform\r\n   - CategoricalTransform\r\n   - CopyColumnsTransform\r\n   - CountFeatureSelection\r\n\r\n### Add `CreateX` method (a helper method) for all possible use case of a transform where `X` is the name of the operation.\r\n\r\nThis is because one transform can instantiated for multiple purpose based on the argument e.g. \r\n   - DropColumnTransform (can be instantiated for dropping or keeping columns)\r\n   - LpNormNormalizerTransform (can be instantiated for LpNorm or GCNorm)\r\n   - NormalizerTransform (can be instantiated for MinMax, Mean-Var, LogMean etc.)\r\n","Url":"https://github.com/dotnet/machinelearning/issues/380","RelatedDescription":"Open issue \"Create convenience constructor for the Transforms (workitem related to #371)\" (#380)"},{"Id":"333872000","IsPullRequest":true,"CreatedAt":"2018-06-19T23:18:50","Actor":"Ivanidzo4ka","Number":"379","RawContent":null,"Title":"Bring ensembles into codebase","State":"open","Body":"Address #378","Url":"https://github.com/dotnet/machinelearning/pull/379","RelatedDescription":"Open PR \"Bring ensembles into codebase\" (#379)"},{"Id":"333870365","IsPullRequest":false,"CreatedAt":"2018-06-19T23:10:00","Actor":"Ivanidzo4ka","Number":"378","RawContent":null,"Title":"Would be nice to bring ensembles into ML.Net","State":"open","Body":"An Ensemble is a set of models, each trained on a sample of the training set. In some cases, training an ensemble instead of a single model is used to boost the accuracy of a given algorithm. Parallel Ensemble is an umbrella word to denote all types of ensembles where the models are independent and can run in parallel.","Url":"https://github.com/dotnet/machinelearning/issues/378","RelatedDescription":"Open issue \"Would be nice to bring ensembles into ML.Net\" (#378)"},{"Id":"333870349","IsPullRequest":true,"CreatedAt":"2018-06-19T23:09:55","Actor":"ganik","Number":"377","RawContent":null,"Title":"Adding LDA Transform","State":"open","Body":"issue #373 ","Url":"https://github.com/dotnet/machinelearning/pull/377","RelatedDescription":"Open PR \"Adding LDA Transform\" (#377)"},{"Id":"333849904","IsPullRequest":false,"CreatedAt":"2018-06-19T21:42:59","Actor":"pkulikov","Number":"376","RawContent":null,"Title":"Question about predictor output: Score and PredictedLabel columns","State":"open","Body":"Current two tutorials in the docs use different columns to get a predicted value out of the pipeline into an instance of the user-defined prediction type:\r\n- Regression [taxi fare tutorial](https://docs.microsoft.com/en-us/dotnet/machine-learning/tutorials/taxi-fare#create-classes-and-define-paths) uses the **Score** column\r\n- Binary classification [sentiment analysis tutorial](https://docs.microsoft.com/en-us/dotnet/machine-learning/tutorials/sentiment-analysis#create-classes-and-define-paths) uses the **PredictedLabel** column\r\n\r\nHow does one know which column to use to populate instances of the prediction type? Especially given that, in case of the (binary) classification solution, the **Score** column is also available (I guess, then it contains the probabilities of being in a certain class).\r\n\r\nAs for the trainer inputs, rules are more or less clear: \r\n- Use the **Label** column for labels (or specify another column name through the `LabelColumn` property)\r\n- Use the **Features** column for features (or specify another column name through the `FeatureColumn` property)\r\n\r\nCan the setup of the predictor output be done in similar way:\r\n- Use the column with the same name across all the predictors for the predictor output. I guess that might require to extend regression `IDataView` with the **PredictedLabel** column that would be a copy of the **Score** column.\r\n- Be able to setup the name of the output column. (That seems the [PredictedLabelColumnOriginalValueConverter](https://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.transforms.predictedlabelcolumnoriginalvalueconverter?view=ml-dotnet) can be used for that; or I'm wrong and that class is intended for use in tandem with the [Dictionarizer](https://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.transforms.dictionarizer?view=ml-dotnet)?)\r\n\r\nBy the way, the mere explanation of the **Score** and **PredictedLabel** columns here would be appreciated as well. Then, at least, I'll update the docs to make story clearer.","Url":"https://github.com/dotnet/machinelearning/issues/376","RelatedDescription":"Open issue \"Question about predictor output: Score and PredictedLabel columns\" (#376)"},{"Id":"333440735","IsPullRequest":true,"CreatedAt":"2018-06-19T19:16:53","Actor":"jwood803","Number":"372","RawContent":null,"Title":"Update fast tree argument help text","State":"closed","Body":"Proposed update for issue #223.","Url":"https://github.com/dotnet/machinelearning/pull/372","RelatedDescription":"Closed or merged PR \"Update fast tree argument help text\" (#372)"},{"Id":"333768666","IsPullRequest":false,"CreatedAt":"2018-06-19T17:30:58","Actor":"korzh","Number":"375","RawContent":null,"Title":"\"The following inputs are missing...\" error message","State":"open","Body":"### Issue\r\n\r\n\r\n\r\nI changed my testing application from loading training data from file (using TextLoader) to loading them from the data objects in memory using CollectionDataSource.    \r\nAt the very first attempt I forgot to include my training collection to the pipeline (`pipline.Add(collection)` were missed) and got a very strange error message:\r\n```\r\nSystem.InvalidOperationException: 'The following inputs are missing: Var_b9ec7864fc3943e9b9ab9d9b38020e3c'\r\n```\r\n\r\nI guess the error message must be more understandable. Like \"No training collection\" or something similar.","Url":"https://github.com/dotnet/machinelearning/issues/375","RelatedDescription":"Open issue \"\"The following inputs are missing...\" error message\" (#375)"},{"Id":"333670293","IsPullRequest":false,"CreatedAt":"2018-06-19T13:24:51","Actor":"bs6523","Number":"374","RawContent":null,"Title":"StochasticDualCoordinateAscentClassifier","State":"open","Body":"anyone know how is \"StochasticDualCoordinateAscentClassifier()\" working? is there any explanation for that? I cant understand how it's working in the background.\r\nIs it a neural net model or some other model?","Url":"https://github.com/dotnet/machinelearning/issues/374","RelatedDescription":"Open issue \"StochasticDualCoordinateAscentClassifier\" (#374)"},{"Id":"333468693","IsPullRequest":false,"CreatedAt":"2018-06-18T23:25:16","Actor":"ganik","Number":"373","RawContent":null,"Title":"Add LightLDA transform","State":"open","Body":"**LightLDA: Big Topic Models on Modest Compute Clusters**\r\n- Current implementations of LDA ( Latent Dirichlet Allocation ) such as SparseLDA or AliasLDA allow to achieve massive data and model scales, for example models with tens of billions of parameters to be inferred from billions of documents. However this requires using cluster up to thousands of machines with all ensuing costs to setup and maintain. \r\n- LightLDA solves this problem in a more cost-effective manner by providing an implementation that is efï¬cient enough for modest clusters with at most tens of machines...\r\n\r\nFor more details please see LightLDA paper:\r\n  http://arxiv.org/abs/1412.1576 \r\n  http://www.www2015.it/documents/proceedings/proceedings/p1351.pdf\r\nand open source implementation:\r\n  https://github.com/Microsoft/LightLDA ","Url":"https://github.com/dotnet/machinelearning/issues/373","RelatedDescription":"Open issue \"Add LightLDA transform\" (#373)"},{"Id":"333390478","IsPullRequest":false,"CreatedAt":"2018-06-18T18:46:58","Actor":"TomFinley","Number":"371","RawContent":null,"Title":"Proposal for Major Change in API","State":"open","Body":"In this issue we describe a proposal to change the API. The core of the\r\nproposal is, instead of working via the entry-point runtime abstraction lying\r\non top of the implementing code, we encourage people to use the implementing\r\ncode directly.\r\n\r\n# Current State\r\n\r\nWithin ML.NET, for a component to be exposed in the \"public\" API, a component\r\nauthor follows the following steps (from an extremely high level):\r\n\r\n1. The author writes a component, implementing some sort of central interface.\r\n   Often this is something like `IDataLoader`, `IDataTransform`, `ITrainer,`\r\n   or some other such type of object.\r\n2. An \"entry-point\" wrapping object is created for that component. This is a\r\n   purely functional view of components as having inputs (as fields in some\r\n   sort of input class) and outputs (as fields in some sort of output class).\r\n   This is decorated with attributes, to allow the dependency injection\r\n   framework to do its work.\r\n3. A JSON \"manifest\" describing all such components is created, through some\r\n   process involving a scan of all `.dll`s and the aforementioned attributes.\r\n4. Some other code reads this JSON \"manifest\" and out of it generates a number\r\n   of C# classes. (This process being the code in `CSharpApiGenerator.cs`, the\r\n   artifact of which is described in `CSharpApi.cs`.)\r\n\r\nA user then works with this component in the following fashion.\r\n\r\n1. The user constructs a `LearningPipeline` object.\r\n2. They adds implementations of `ILearningPipelineItem`, which are sort of\r\n   configuration objects. (These are some of the objects that were code\r\n   generated.)\r\n3. Through some process that is probably too complex to describe here, these\r\n   `ILearningPipelineItem` are transmuted into a sort of abstract \"graph\"\r\n   structure comprised of inputs and outputs. (This is an \"entry-point\"\r\n   experiment graph.)\r\n4. This graph structure is then serialized to JSON, de-serialized back out of\r\n   JSON, then the actual underlying code that implements the operations is\r\n   loaded using dependency injection.\r\n5. Once loaded, the associated \"settings\" objects (which are actual types\r\n   explicitly written in ML.NET) have their fields populated from values in\r\n   this JSON.\r\n6. There is some higher level runtime coordinating this process of graph nodes\r\n   (the entry-point graph runner). This is a sort of runtime for the nodes,\r\n   and handles job scheduling, variable setting, and whatnot.\r\n\r\nThe way this process works is via something called entry-points. Entry-points\r\nwere conceived as a mechanism to enable a \"regular\" way to invoke ML.NET\r\ncomponents from native code, that was more expressive and powerful than the\r\ncommand line. Essentially: they are a command-line on steroids, that instead\r\nof inventing a new DSL utilizes JSON. This is effective at alleviating the\r\nburden of writing \"bridges\" from R and Python into ML.NET. It also has\r\nadvantages in situations where you need to send a sequence of commands \"over\r\nthe wire\" in some complex fashion. While a few types would need to be handled\r\n(e.g., standard numeric types, `IDataView`, `IFileHandle`, and some others),\r\nso long as the entry-points used *only* those supported types, composing an\r\nexperiment in those non-.NET environments would be possible.\r\n\r\n# Possible Alternate State\r\n\r\nInstead of working indirectly with ML.NET components through the entry-point\r\nabstraction, you could just instantiate and use the existing classes directly.\r\nThat is, the aforementioned `IDataLoader`, `IDataTransform`, `ITrainer,` and\r\nso forth would be instantiated and operated on directly.\r\n\r\nWhile entry-points would still be necessary for any components we wished to\r\nexpose through R or Python, we would constrain our usage to those applications\r\nwhere the added level of abstraction served some purpose.\r\n\r\nThis alternate pattern of usage is already well tested, as it actually\r\nreflects how ML.NET itself is written.\r\n\r\n# Changes for ML.NET\r\n\r\nIn order to move towards this state, a few high level adjustments will be\r\nnecessary.\r\n\r\n* Low level API is based direct instantiations of `IDataViews`/`ITrainer` and\r\n  other fundamental types and utilities already used within ML.NET code.\r\n* We will work to actively identify and improve that low level API from the\r\n  point of view of usage. See the sequel for more in depth discussion of this\r\n  point.\r\n* Writing higher level abstractions to make things easier should be\r\n  encouraged, however always with the aim of making them non-opaque. That is,\r\n  in edge cases when the abstraction fails, integrating what *can* be done\r\n  with the abstraction with the lower level explicit API should be possible.\r\n  Generally: Easy things should be easy and hard things should be possible.\r\n* To clarify: We are not getting rid of entry-points, because it remains the\r\n  mechanism by which interop from non-.NET programming environments into TLC\r\n  will continue to happen, and is therefore important. The shift is: the lower\r\n  level C# API will not use entry-points. For the purpose of servicing\r\n  GUI/Python/non-.NET bindings, we will continue in our own code to provide\r\n  entry points, while allowing user code to work by implementing the core\r\n  interfaces directly.\r\n\r\n# Examples of Potential Improvements in \"Direct Access\" API\r\n\r\nWe give the following concrete examples of areas that probably need\r\nimprovement. The examples are meant to be illustrative only. That is: the list\r\nis not exhaustive, nor are specific \"solutions\" to problems meant to convey\r\nthat something *must* be done in a particular way.\r\n\r\n* Instantiation of late binding components was previously always done via\r\n  dependency injection. Therefore, all components have constructors or static\r\n  create methods that have had *identical* signatures (e.g., for transforms,\r\n  `IHostEnvironment env, Arguments args, IDataView input`). Direct\r\n  instantiation by the user *could* use that, but would doubtless be better\r\n  served by a more contextually appropriate constructor that reflects common\r\n  use-cases. For example, this:\r\n\r\n  ```csharp\r\n  IDataTransform trans = new ConcatTransform(env, new ConcatTransform.Arguments()\r\n  {\r\n      Column = new[] {\r\n      new ConcatTransform.Column()\r\n      {\r\n          Name = \"NumericalFeatures\",\r\n          Source = new[] { \"SqftLiving\", \"SqftLot\", \"SqftAbove\",   \"SqftBasement\",\r\n              \"Lat\", \"Long\", \"SqftLiving15\", \"SqftLot15\" }\r\n      }}\r\n  }, loader);\r\n  ```\r\n\r\n  may become this:\r\n\r\n  ```csharp\r\n  IDataTransform trans = new ConcatTransform(env, loader, \"NumericalFeatures\",\r\n      \"SqftLiving\", \"SqftLot\", \"SqftAbove\", \"SqftBasement\", \"Lat\", \"Long\",\r\n      \"SqftLiving15\", \"SqftLot15\");\r\n  ```\r\n\r\n  This can work both ways: if these objects are directly instantiated, the\r\n  objects could provide richer information than merely being an\r\n  `IDataTransform`, or what have you. Due to working via the command line,\r\n  entry-points, or a GUI, it is considered almost useless for a component to\r\n  have any purely programmatic access. So for example: we could have had the\r\n  `AffineNormalizer` expose its slope and intercept, but we instead expose it\r\n  by metadata instead. A direct accessor in ML.NET may be appropriate if we\r\n  directly use these components.\r\n\r\n* Creating a transform and loader feels similar. However, creating a trainer,\r\n  using it to provide a predictor, and then ultimately parameterizing a scorer\r\n  transform with that predictor. Where possible we can try to harmonize the\r\n  interfaces to make them seem more consistent. (Obviously not always possible\r\n  since the underlying abstraction may in fact be genuinely different.)\r\n\r\n* Some parts of the current library introduce needless complexity: `Train`\r\n  method on trainer is `void`, always followed by `CreatePredictor`. Other\r\n  incidents of needless complexity may be less easy to resolve.\r\n\r\n* Some parts of the current library introduce *needful* complexity, but could\r\n  probably be improved somehow. `RoleMappedData` creation and usage, while\r\n  providing an essential service (\"use this column for this purpose\"), is\r\n  incredibly difficult to use. When it was just an \"internal\" structure we\r\n  just sort of dealt with it, but we would like to improve it. (In some cases\r\n  we can hide its creation into auxillary helper methods, for example.)\r\n\r\n* Simple things like improving naming of things may just help a lot. For\r\n  example: `ScoreUtils.GetScorer` returns a transform with the predictor's\r\n  scores applied to data. `ScoreUtils.GetScoredData` or something may be a\r\n  better name.\r\n\r\n* Our so-called \"internal\" methods do not always direct people towards pits of\r\n  success. For example: some pipeline components should probably apply only\r\n  during training (e.g., filtering, sampling, caching). Some distinction or\r\n  other engineering nicety (e.g., have the utilities for saving models throw\r\n  by default) may help warn people off this common misuse case.\r\n\r\n* Components of the existing API that deal with\r\n  late-binding/dependency-injection stuff could potentially use delegates or\r\n  something like entry-point style factory interfaces instead. This means\r\n  among other things lifting out things like `SubComponent` from most code.\r\n  Whether these delegates happen to be composed from the command line parser\r\n  calling `SubComponent.CreateInstance`, or some entry-point \"subgraph\"\r\n  generating a delegate out of its own graph, is the business of the command\r\n  line parser and entry-point engine, not the component code itself. (Maybe\r\n  the delegate just calls Run graph or something then binds the values.)\r\n\r\n  So for example what is currently this:\r\n\r\n  ```csharp\r\n  new Ova(env, new Ova.Argumnets() { Trainer = new SubComponent(\"sdcaR\") );\r\n  ```\r\n\r\n  might become this:\r\n\r\n  ```csharp\r\n  new Ova(env, host => new SdcaRegression(host));\r\n  ```\r\n\r\n* When we think about transform chains and pipelines, both the existing and suggested systems have a need for an intermediate object capable of representing a pipeline *before* it is instantiated. That intermediate form must be something you can reason over, both to pre-verify pipelines, as well as for certain applications like suggested transforms/auto-ML. One example is issue #267.\r\n\r\n  Entry-points were *an* intermediate object, but being logically only `JObject`s you could not get rich information about what or how they would operate. (Given a pipeline in entry-points you could tell that something might be outputting *a* `IDataView`, for example, but have no information about what columns were actually in that output.)\r\n\r\n  This suggests that the API will want something *like* `LearningPipeline`, though I am quite confident `LearningPipeline` is an incorrect level of abstraction. (See the previous point about opaque abstractions, among other points.)\r\n\r\nNote that many of these enhancements will serve not only users, but component\r\nauthors (including us), and so improve the whole platform.\r\n\r\n# Miscellaneous Details\r\n\r\nNote that C# code generation from entry-point graphs will still be possible:\r\nall entry-point invocations come down to (1) defining input objects, (2)\r\ncalling a static method and (3) doing something with the output object.\r\nHowever it will probably not be possible to make it seem \"natural\" any more\r\nthan an attempt to do code-generation from a `mml` command line would seem\r\n\"natural.\"\r\n\r\nWhen we decided to make the public facing API entry-points based, this\r\nnecessarily required shifting related infrastructure (e.g., `GraphRunner`,\r\n`JsonManifestUtils`) into more central assemblies. Once that \"idiom\" is\r\ndeconstructed, this infrastructure should resume its prior state of being in\r\nan isolated assembly.\r\n\r\nAlong similar lines of isolation, once we shift the components to not use\r\n`SubComponent` directly, we can \"uplift\" what is currently the command line\r\nparsing code out into a separate assembly.","Url":"https://github.com/dotnet/machinelearning/issues/371","RelatedDescription":"Open issue \"Proposal for Major Change in API\" (#371)"},{"Id":"333367907","IsPullRequest":true,"CreatedAt":"2018-06-18T18:33:06","Actor":"eerhardt","Number":"370","RawContent":null,"Title":"Move the NuGet package build files into a TFM specific directory.","State":"closed","Body":"When installing Microsoft.ML on an unsupported framework (like net452), it is currently getting installed successfully. However, users should be getting an error stating that net452 is not supported by this package.\r\n\r\nThe cause is the build files exist for any TFM, which NuGet interprets as this package supports any TFM. Moving the build files to be consistent with the 'lib' folder support.\r\n\r\nFix #357","Url":"https://github.com/dotnet/machinelearning/pull/370","RelatedDescription":"Closed or merged PR \"Move the NuGet package build files into a TFM specific directory.\" (#370)"}],"ResultType":"GitHubIssue"}},"RunOn":"2018-06-24T05:30:39.2347857Z","RunDurationInMilliseconds":1020}