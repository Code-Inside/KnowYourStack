{"Data":{"GitHub":{"Issues":[{"Id":"1821469414","IsPullRequest":false,"CreatedAt":"2023-07-27T03:19:15","Actor":"RockNHawk","Number":"6774","RawContent":null,"Title":" IDataView.GetColumn throw exception Splitter/consolidator worker encountered exception while consuming source data","State":"closed","Body":"**System Information (please complete the following information):**\r\n - OS & Version: Windows 10\r\n<PackageReference Include=\"Microsoft.ML\" Version=\"3.0.0-preview.23266.6\" />\r\n<PackageReference Include=\"Microsoft.ML.OnnxRuntime\" Version=\"1.15.1\" />\r\n<PackageReference Include=\"Microsoft.ML.OnnxTransformer\" Version=\"3.0.0-preview.23266.6\" />\r\n\r\n**Describe the bug**\r\nThe single prediction is OK, but multiple predictions throw error when call IDataView.GetColumn<T>().ToArray()\r\n\r\n**Screenshots, Code, Sample Projects**\r\n\r\n    IEnumerable<TextEmbeddingResult> DoBulkGenerateTextEmbedding(IList<StringFragment> texts)\r\n    {\r\n        var tokenizer = _tokenizer.GetTokenizer();\r\n        var bulkSize = texts.Count;\r\n\r\n        var inputs = InputDataArray(texts, tokenizer).ToArray();\r\n        var maxSize = inputs.Max(x => x.InputIds.Length);\r\n        Shape shape = ShapeFactory.CreateShape(batchSize: texts.Count, maxSize);\r\n\r\n\r\n\r\n            BatchSize = batchSize;\r\n            MaxLength = maxLength;\r\n\r\n  \r\n\r\n          var shapeDictionary = new Dictionary<string, int[]>\r\n            {\r\n                { ColumnNames.Input.InputIds,  new[] { 1, maxSize }},\r\n                { ColumnNames.Input.AttentionMask,  new[] { 1, maxSize}},\r\n                { ColumnNames.Output.LastHiddenState,  new[] { 1, maxSize, EmbeddingConst.TokenResultDim }},\r\n            };\r\n\r\n        MLContext context = new MLContext();\r\n        bool useGpu = false;\r\n        OnnxScoringEstimator pipeline = context.Transforms.ApplyOnnxModel(\r\n            modelFile: _modelInfo.ModelPath,\r\n            shapeDictionary: shapeDictionary,\r\n            inputColumnNames: new[] { ColumnNames.Input.InputIds, ColumnNames.Input.AttentionMask, },\r\n            outputColumnNames: new[] { ColumnNames.Output.LastHiddenState, },\r\n            gpuDeviceId: useGpu ? 0 : (int?)null,\r\n            fallbackToCpu: true\r\n        );\r\n\r\n\r\n        var trainingDataView = context.Data.LoadFromEnumerable(inputs);\r\n\r\n        using var transformer = pipeline.Fit(trainingDataView);\r\n\r\n        var predictions = transformer.Transform(trainingDataView);\r\n        // data type (name: last_hidden_state, type: Vector<Single, 2, 29, 768>) in data to the user-defined type, System.Single. (Parameter 'column')\r\n        var outputColumn = predictions.Schema[ColumnNames.Output.LastHiddenState];\r\n\r\n        var output = predictions.GetColumn<Microsoft.ML.Data.VBuffer<float>>(ColumnNames.Output.LastHiddenState);\r\n\r\n        // Convert the VBuffer<float> to a float array\r\n\r\n        /*\r\noutput.ToArray()  throw Exception\r\nSplitter/consolidator worker encountered exception while consuming source data\r\n\r\n.InnerException: System.ArgumentOutOfRangeException:\r\nIndex was out of range. Must be non-negative and less than the size of the collection. (Parameter 'index')\r\nat System.Collections.Generic.List1.set_Item(Int32 index, T value) at Microsoft.ML.Transforms.Onnx.OnnxTransformer.Mapper.NamedOnnxValueGetterVec1.GetNamedOnnxValueUnknownSize()\r\nat Microsoft.ML.Transforms.Onnx.OnnxTransformer.Mapper.NamedOnnxValueGetterVec1.GetNamedOnnxValue() at Microsoft.ML.Transforms.Onnx.OnnxTransformer.Mapper.UpdateCacheIfNeeded(Int64 position, INamedOnnxValueGetter[] srcNamedOnnxValueGetters, List1 activeOutputColNames, OnnxRuntimeOutputCacher outputCache)\r\nat Microsoft.ML.Transforms.Onnx.OnnxTransformer.Mapper.<>c__DisplayClass14_01.<MakeTensorGetter>b__0(VBuffer1& dst)\r\nat Microsoft.ML.Data.DataViewUtils.Splitter.InPipe.Impl`1.Fill()\r\nat Microsoft.ML.Data.DataViewUtils.Splitter.<>c__DisplayClass7_1.b__2()\r\n*/\r\n        var outputVectorGroups = output.ToArray();\r\n\r\n        float[] outputMergedVectors = outputVectorGroups.SelectMany(x => x.DenseValues()).ToArray();\r\n\r\n        var sentenceEmbeddings = SentenceEmbeddingUtility.BulkToSentenceEmbeddings(\r\n            new EmbeddingContext(bulkSize, maxSize, EmbeddingConst.TokenResultDim, outputMergedVectors, _dense)\r\n            //,inputData.AttentionMask\r\n        );\r\n\r\n        int i = 0;\r\n        foreach (var vectors in sentenceEmbeddings)\r\n        {\r\n            var text = texts[i];\r\n            yield return new(text, vectors);\r\n            i++;\r\n        }\r\n    }\r\n\r\n![image](https://github.com/dotnet/machinelearning/assets/3222379/d1addbec-04cc-4ebd-b301-1e16e204ec5e)\r\n\r\n**Additional context**\r\nThe single prediction is OK.\r\n`\r\nusing var predictionEngine = context.Model.CreatePredictionEngine<InputData, OutputData>(transformer, inputSchemaDefinition: inputSchemaDef, outputSchemaDefinition: outputSchemaDef);\r\n\r\nvar prediction = predictionEngine.Predict(inputData);\r\n`\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6774","RelatedDescription":"Closed issue \" IDataView.GetColumn throw exception Splitter/consolidator worker encountered exception while consuming source data\" (#6774)"},{"Id":"1822946818","IsPullRequest":false,"CreatedAt":"2023-07-26T18:29:38","Actor":"luisquintanilla","Number":"6777","RawContent":null,"Title":"Ignore Columns ColumnInference","State":"open","Body":"When using `InferColumns`, there is now way to specify which columns to exclude.\r\n\r\n```csharp\r\n// Define data path\r\nvar dataPath = Path.GetFullPath(@\"../Data/issues_train.tsv\");\r\n\r\n// Infer column information\r\nColumnInferenceResults columnInference =\r\n    ctx.Auto().InferColumns(dataPath, separatorChar: '\\t', labelColumnName: \"Area\", groupColumns: false);\r\n```\r\n\r\nThat means that you have to do it manually.\r\n\r\n```csharp\r\nvar columnsToExclude = new[]{\"ID\",\"Title\"};\r\n\r\ncolumnInference.TextLoaderOptions.Columns = \r\n    columnInference.TextLoaderOptions.Columns\r\n        .Where(col => !columnsToExclude.Contains(col.Name)).ToArray();\r\n\r\ncolumnInference.ColumnInformation.NumericColumnNames.Remove(\"ID\");\r\ncolumnInference.ColumnInformation.TextColumnNames.Remove(\"Title\");\r\n```\r\n\r\nSince the TextLoaderOptions and ColumnInformation are used downstream\r\n\r\n```csharp\r\n// Create text loader\r\nTextLoader loader = ctx.Data.CreateTextLoader(columnInference.TextLoaderOptions);\r\n\r\n// Load data into IDataView\r\nIDataView data = loader.Load(dataPath);\r\n\r\nSweepablePipeline pipeline =\r\n    ctx.Auto().Featurizer(data, columnInformation: columnInference.ColumnInformation)\r\n        .Append(ctx.Transforms.Conversion.MapValueToKey(columnInference.ColumnInformation.LabelColumnName))\r\n        .Append(ctx.Auto().MultiClassification(labelColumnName: columnInference.ColumnInformation.LabelColumnName))\r\n        .Append(ctx.Transforms.Conversion.MapKeyToValue(\"PredictedLabel\"));\r\n```\r\n\r\nIn the InferColumns API, it might be the best place to set this value","Url":"https://github.com/dotnet/machinelearning/issues/6777","RelatedDescription":"Open issue \"Ignore Columns ColumnInference\" (#6777)"},{"Id":"1822764777","IsPullRequest":true,"CreatedAt":"2023-07-26T16:23:52","Actor":"michaelgsharp","Number":"6776","RawContent":null,"Title":"fixed mac build and minor torch sharp changes","State":"open","Body":"Fixes the mac build issue with the official pipeline.\r\n\r\nAlso adds in specific options classes for SentenceSimilarity and TextClassification so that each can be given their own defaults.","Url":"https://github.com/dotnet/machinelearning/pull/6776","RelatedDescription":"Open PR \"fixed mac build and minor torch sharp changes\" (#6776)"},{"Id":"1821740269","IsPullRequest":false,"CreatedAt":"2023-07-26T07:15:43","Actor":"RockNHawk","Number":"6775","RawContent":null,"Title":"Cannot access internal method 'MLContext.CancelExecution()' ","State":"open","Body":"I have a memory leak issue, and find this similar issue, but `CancelExecution` in internal.\r\n\r\n[BestFriend]\r\ninternal void CancelExecution() => ((ICancelable) this._env).CancelExecution();\r\n\r\n\r\nfull code\r\n\r\n        MLContext context = new MLContext();\r\n        bool useGpu = false;\r\n        OnnxScoringEstimator pipeline = context.Transforms.ApplyOnnxModel(\r\n            modelFile: _modelInfo.ModelPath,\r\n            shapeDictionary: shape.ToDictionary(),\r\n            inputColumnNames: new[] { ColumnNames.Input.InputIds, ColumnNames.Input.AttentionMask, },\r\n            outputColumnNames: new[] { ColumnNames.Output.LastHiddenState, },\r\n            gpuDeviceId: useGpu ? 0 : (int?)null,\r\n            fallbackToCpu: true\r\n        );\r\n\r\n        var inputSchemaDef = ToInputSchemaDefinition<InputData>(shape);\r\n        var trainingDataView = context.Data.LoadFromEnumerable(new List<InputData>() { }, inputSchemaDef);\r\n        using var transformer = pipeline.Fit(trainingDataView);\r\n\r\n        var outputSchemaDef = ToOutputSchemaDefinition<OutputData>(shape);\r\n        using var predictionEngine = context.Model.CreatePredictionEngine<InputData, OutputData>(transformer, inputSchemaDefinition: inputSchemaDef, outputSchemaDefinition: outputSchemaDef);\r\n        var predictionResult = predictionEngine.Predict(inputData);\r\n\r\n\r\n@fischja It could be the last trial still running even after automl experiment times out, could you try cancelling context and run again\r\n\r\n```csharp\r\nfor (int i = 0; i < 5; i++)\r\n{\r\n    MLContext ml = new MLContext();\r\n\r\n    List<MyData> trainingDataList = Enumerable.Range(0, 10000).Select(x => new MyData()).ToList();\r\n    IDataView trainingData = ml.Data.LoadFromEnumerable(trainingDataList);\r\n\r\n    var result = ml\r\n        .Auto()\r\n        .CreateRegressionExperiment(maxExperimentTimeInSeconds: 20)\r\n        .Execute(trainData: trainingData, numberOfCVFolds: 3, labelColumnName: \"Y\");\r\n\r\n    ml.CancelExecution();\r\n}\r\n```\r\n\r\n_Originally posted by @LittleLittleCloud in https://github.com/dotnet/machinelearning/issues/6188#issuecomment-1121407624_\r\n            ","Url":"https://github.com/dotnet/machinelearning/issues/6775","RelatedDescription":"Open issue \"Cannot access internal method 'MLContext.CancelExecution()' \" (#6775)"},{"Id":"1819780883","IsPullRequest":false,"CreatedAt":"2023-07-25T08:07:41","Actor":"xpt5","Number":"6773","RawContent":null,"Title":"Dataframe.LoadCsv() throwing exception","State":"open","Body":"**System Information (please complete the following information):**\r\n - OS & Version: Windows 10 Pro \r\n - Microsfot.Data.Analysis: v0.22.1\r\n - .NET Version: .NET 6.0\r\n\r\n**Describe the bug**\r\nI am having the same problem as reported on #5647. The input is the same since I created a csv file with same text and the exception thrown when running the code below is also the same.\r\n\r\n```\r\nSystem.FormatException\r\n  HResult=0x80131537\r\n  Message=Line 1 has less columns than expected\r\n  Source=Microsoft.Data.Analysis\r\n  StackTrace:\r\n   at Microsoft.Data.Analysis.DataFrame.GuessKind(Int32 col, List`1 read)\r\n   at Microsoft.Data.Analysis.DataFrame.ReadCsvLinesIntoDataFrame(WrappedStreamReaderOrStringReader wrappedReader, Char separator, Boolean header, String[] columnNames, Type[] dataTypes, Int64 numberOfRowsToRead, Int32 guessRows, Boolean addIndexColumn)\r\n   at Microsoft.Data.Analysis.DataFrame.LoadCsv(String filename, Char separator, Boolean header, String[] columnNames, Type[] dataTypes, Int32 numRows, Int32 guessRows, Boolean addIndexColumn, Encoding encoding)\r\n   at KeynotesPackagesTest.DataAnalysis.OpenCsvAndExportData(String csvFilePath, String textFile) in C:\\Users\\<user>\\source\\repos\\KeynotesPackagesTest\\KeynotesPackagesTest\\DataAnalysis.cs:line 102\r\n   at Program.<Main>$(String[] args) in C:\\Users\\<user>\\source\\repos\\KeynotesPackagesTest\\KeynotesPackagesTest\\Program.cs:line 35\r\n```\r\n\r\n**Expected behavior**\r\nReading the .csv file without issues\r\n\r\n**Code**\r\n\r\n```\r\n\r\n        public static void OpenCsvAndExportData(string csvFilePath, string textFile)\r\n        {\r\n            var data = DataFrame.LoadCsv(csvFilePath, separator: ',');\r\n```\r\n\r\nAnd then I cal the method from Program.cs\r\nI hope I am not overseeing something basic since I am very new to the c# language.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6773","RelatedDescription":"Open issue \"Dataframe.LoadCsv() throwing exception\" (#6773)"},{"Id":"1812591396","IsPullRequest":true,"CreatedAt":"2023-07-24T22:23:09","Actor":"LittleLittleCloud","Number":"6768","RawContent":null,"Title":"fix issue #2718 from model builder","State":"closed","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [x] There's a descriptive title that will make sense to other developers some time from now. \r\n- [x] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [ ] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\n\r\nfix https://github.com/dotnet/machinelearning-modelbuilder/issues/2718\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6768","RelatedDescription":"Closed or merged PR \"fix issue #2718 from model builder\" (#6768)"},{"Id":"1797020799","IsPullRequest":true,"CreatedAt":"2023-07-24T19:47:24","Actor":"michaelgsharp","Number":"6760","RawContent":null,"Title":"Add NameEntityRecognition and Q&A deep learning tasks.","State":"closed","Body":"This PR adds in 2 new deep learning scenarios, Name Entity Recognition and Q&A.\r\n\r\nThe main files to focus on are NerTrainer.cs and Roberta/QATrainer.cs. Most of the rest are either part of the deep learning model itself or internal implementations of things I had to copy over from runtime for them to work on netstandard.","Url":"https://github.com/dotnet/machinelearning/pull/6760","RelatedDescription":"Closed or merged PR \"Add NameEntityRecognition and Q&A deep learning tasks.\" (#6760)"},{"Id":"1818465370","IsPullRequest":true,"CreatedAt":"2023-07-24T13:46:24","Actor":"asmirnov82","Number":"6772","RawContent":null,"Title":"Fix DataFrame.LoadCsv can not load CSV with duplicate column names","State":"open","Body":"Fixes #6182 \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6772","RelatedDescription":"Open PR \"Fix DataFrame.LoadCsv can not load CSV with duplicate column names\" (#6772)"},{"Id":"1816933459","IsPullRequest":false,"CreatedAt":"2023-07-23T00:15:20","Actor":"MIAIONE","Number":"6771","RawContent":null,"Title":"[feature] some suggestions...","State":"open","Body":"Hello! This is a feature suggestion. \r\n\r\n1. It seems that there are no relevant models for generative AI in ML.NET. It always frustrates me when I try to generate what I want, and I have to load external models through ONNX to achieve my needs. However, this is not perfect. In many cases, I can only use existing models and do not have the conditions to try training a Python ONNX model myself. I hope that ML.NET can provide some necessary generative AI basic algorithms and AUTOML templates, which may not directly achieve the goal, but can indirectly implement upper-level complex functions (such as GAN), which can lay a solid foundation for the subsequent ML.NET community ecology. \r\n\r\n2. It seems that ML.NET's AutoML does not provide model continuation training. When I replace new data with the same input format, retraining will start from scratch, which makes it very easy to lose the existing excellent model without backing up the previous model (I personally think that training models is like opening a blind box). It is particularly important to retain the previous training results. As a backup, renaming by date can be used instead of direct overwriting.","Url":"https://github.com/dotnet/machinelearning/issues/6771","RelatedDescription":"Open issue \"[feature] some suggestions...\" (#6771)"},{"Id":"1813643254","IsPullRequest":true,"CreatedAt":"2023-07-20T10:16:58","Actor":"asmirnov82","Number":"6770","RawContent":null,"Title":"Fix inconsistent null handling in DataFrame Arithmetics","State":"open","Body":"Fixes #5650 \r\n","Url":"https://github.com/dotnet/machinelearning/pull/6770","RelatedDescription":"Open PR \"Fix inconsistent null handling in DataFrame Arithmetics\" (#6770)"},{"Id":"1813484022","IsPullRequest":true,"CreatedAt":"2023-07-20T08:46:15","Actor":"asmirnov82","Number":"6769","RawContent":null,"Title":"Fix issue with addIndexColumn in DataFrame.LoadCsv","State":"open","Body":"Fixes #5968 \r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6769","RelatedDescription":"Open PR \"Fix issue with addIndexColumn in DataFrame.LoadCsv\" (#6769)"},{"Id":"1809930285","IsPullRequest":false,"CreatedAt":"2023-07-18T13:22:55","Actor":"superichmann","Number":"6767","RawContent":null,"Title":"IDataView Filtering does not Improve Performence","State":"open","Body":"I am performing 40 regression experiments (`parallel.foreach`) on a database table by filtering with different column values.\r\n\r\nWhen I SELECT the data directly from the database for each experiment the whole process takes 38 seconds.\r\nWhen I take the data from the database one time, cache it and use `SkipRows` and `TakeRows` for filtering each experiment it takes 42 seconds.\r\n\r\nFrom my standpoint the second method should produce better performance but the opposite occurs. can you please instruct me on how to use `SkipRows` and `TakeRows` in a way which will actually improve my overall performance?","Url":"https://github.com/dotnet/machinelearning/issues/6767","RelatedDescription":"Open issue \"IDataView Filtering does not Improve Performence\" (#6767)"},{"Id":"1809795496","IsPullRequest":true,"CreatedAt":"2023-07-18T12:07:48","Actor":"Lehonti","Number":"6766","RawContent":null,"Title":"Modernized some argument checks that still used string literals for parameter names","State":"open","Body":"No changes in behavior, just leveraging more modern syntax","Url":"https://github.com/dotnet/machinelearning/pull/6766","RelatedDescription":"Open PR \"Modernized some argument checks that still used string literals for parameter names\" (#6766)"},{"Id":"1807116516","IsPullRequest":false,"CreatedAt":"2023-07-17T06:57:21","Actor":"Sapana-Khemkar","Number":"6765","RawContent":null,"Title":"testing ML.NET on ppc64le architeecture","State":"open","Body":"I am trying to build ML.NET for ppc64le and run test suite.\r\nI have gone through [this](https://github.com/dotnet/machinelearning/blob/main/docs/building/unix-instructions.md)\r\nI tried first cross build as explained for arm and generated artifacts folder for ppc64le on x86 machine and then moved artifacts folder to ppc64le machine. But I cannot use `./build.sh --test` command to run tests. Hence tried using dotnet test command as below\r\n```\r\ncd bin/Microsoft.ML.Tests/Release/net7.0 \r\ndotnet test Microsoft.ML.Tests.dll\r\n```\r\nBut almost all tests failed with below error:\r\n```\r\nError Message: System.TypeInitializationException : The type initializer for 'Microsoft.ML.TestFramework.BaseTestClass' threw an exception. ---- System.NullReferenceException : Object reference not set to an instance of an object Stack Trace: at Microsoft.ML.RunTests.BaseTestBaseline..ctor(ITestOutputHelper output) in /root/sapana/machinelearning/test/Microsoft.ML.TestFramework/BaseTestBaseline.cs:line 31 at Microsoft.ML.RunTests.TestDataViewBase..ctor(ITestOutputHelper helper) in /root/sapana/machinelearning/test/Microsoft.ML.TestFramework/TestInitialization.cs:line 107 at Microsoft.ML.RunTests.TestDataPipeBase..ctor(ITestOutputHelper helper) in /root/sapana/machinelearning/test/Microsoft.ML.TestFramework/TestInitialization.cs:line 59 at Microsoft.ML.Tests.Transformers.CountTargetEncodingTests..ctor(ITestOutputHelper output) in /root/sapana/machinelearning/test/Microsoft.ML.Tests/Transformers/CountTargetEncodingTests.cs:line 17 at System.Reflection.ConstructorInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr) ----- Inner Stack Trace ----- at Microsoft.ML.TestFrameworkCommon.TestCommon.GetRepoRoot() in /root/sapana/machinelearning/test/Microsoft.ML.TestFrameworkCommon/TestCommon.cs:line 78 at Microsoft.ML.TestFramework.BaseTestClass..cctor() in /root/sapana/machinelearning/test/Microsoft.ML.TestFramework/BaseTestClass.cs:line 40 Failed Microsoft.ML.Tests.Transformers.CountTargetEncodingTests.TestSaveAndLoadExternalCountsMultipleColumns [1 ms]\r\n```\r\n\r\nI have tried to build natively on ppc64le machine with ubuntu 20.04. I have added ppc64le arch in makefile/project files (by referring arm arch). But I am getting warning as below and build failing after that due to code not generated as expected\r\n```\r\nCSC : warning CS8785: Generator 'EstimatorTypeGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'TypeLoadException' with message 'Could not set up parent class, due to: Could not load type of field 'Microsoft.ML.AutoML.SourceGenerator.Template.EstimatorTypeBase:errorsField' (1) due to: Could not load file or assembly 'System.CodeDom, Version=4.0.1.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies.\r\n```\r\nCan someone help me how can I tests machinelearning repo on ppc64le? If cross build is right way then how to run tests on cross built artifacts?\r\n\r\nPlease Note: If I directly add ML.NET package reference and run basic sample on ppc64le machine it works. But I want to run all test cases and list down supported/not supported features.\r\n\r\nThanks in advance.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6765","RelatedDescription":"Open issue \"testing ML.NET on ppc64le architeecture\" (#6765)"},{"Id":"1806413829","IsPullRequest":false,"CreatedAt":"2023-07-16T03:31:54","Actor":"minhthien711","Number":"6764","RawContent":null,"Title":"System.ArgumentOutOfRangeException: 'Could not determine an IDataView type and registered custom types for member Image Parameter name: rawType'","State":"open","Body":"Can you help me ? i can't run code when i update to version 2.0\r\nI use sample download it's : https://github.com/jwood803/MLNET_ObjectDetection_WinForms/tree/main/MLNET_ObjectDetection_WinForms\r\n\r\nDo you help me update sample to ver 2.0 ! \r\n\r\n\r\n.Because row \"var data = context.Data.LoadFromEnumerable(emptyData);\" show issuse \" \"System.ArgumentOutOfRangeException: 'Could not determine an IDataView type and registered custom types for member Image\r\nParameter name: rawType' \"\r\n\r\n\r\n`using Microsoft.ML;\r\nusing Microsoft.ML.Transforms.Image;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Data;\r\nusing System.Drawing;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading.Tasks;\r\nusing System.Windows.Forms;\r\nusing Microsoft.ML.Data;\r\nusing MLNET_ObjectDetection_WinForms.Models;\r\n\r\nnamespace MLNET_ObjectDetection_WinForms\r\n{\r\n    public partial class Form1 : Form\r\n    {\r\n        public const int rowCount = 13, columnCount = 13;\r\n        public const int featuresPerBox = 5;\r\n        private readonly string[] classLabels;\r\n\r\n        private static readonly (float x, float y)[] Anchors = { (0.573f, 0.677f), (1.87f, 2.06f), (3.34f, 5.47f), (7.88f, 3.53f), (9.77f, 9.17f) };\r\n\r\n        private PredictionEngine<ModelInput, ModelOutput> _predictionEngine;\r\n\r\n        string ProjectLocation = Path.GetDirectoryName(Path.GetDirectoryName(System.IO.Directory.GetCurrentDirectory()));\r\n\r\n        public Form1()\r\n        {\r\n            InitializeComponent();\r\n\r\n            picPrediction.Visible = false;\r\n            btnNewPrediction.Visible = false;\r\n\r\n           MLContext context = new MLContext();\r\n            var emptyData = new List<ModelInput>();\r\n\r\n            var data = context.Data.LoadFromEnumerable(emptyData);\r\n\r\n        //   var schema = SchemaDefinition.Create(typeof(ModelInput));\r\n         //   var schemaData = context.Transforms.SelectColumns(nameof(ModelInput.Image)).Transform(data);\r\n\r\n            string pathModel = ProjectLocation + @\"\\MLModel\\model.onnx\";\r\n\r\n            var pipeline = context.Transforms.ResizeImages(resizing: ImageResizingEstimator.ResizingKind.Fill, outputColumnName: \"data\", imageWidth: ImageSettings.imageWidth, imageHeight: ImageSettings.imageHeight, inputColumnName: nameof(ModelInput.Image))\r\n                            .Append(context.Transforms.ExtractPixels(outputColumnName: \"data\"))\r\n                            .Append(context.Transforms.ApplyOnnxModel(modelFile: pathModel, outputColumnName: \"model_outputs0\", inputColumnName: \"data\"));\r\n\r\n            var model = pipeline.Fit(data);\r\n\r\n            _predictionEngine = context.Model.CreatePredictionEngine<ModelInput, ModelOutput>(model);\r\n        }\r\n\r\n        private void btnSelectImage_Click(object sender, EventArgs e)\r\n        {\r\n            string pathText = ProjectLocation + @\"\\MLModel\\labels.txt\";\r\n            if (fileDialog.ShowDialog() == DialogResult.OK)\r\n            {\r\n                var image = (Bitmap)Image.FromFile(fileDialog.FileName);\r\n\r\n                var prediction = _predictionEngine.Predict(new ModelInput { Image = image });\r\n\r\n                var labels = File.ReadAllLines(pathText);\r\n\r\n                var boundingBoxes = ParseOutputs(prediction.WineType, labels);\r\n\r\n                var originalWidth = image.Width;\r\n                var originalHeight = image.Height;\r\n\r\n                if (boundingBoxes.Count > 0)\r\n                {\r\n                    var filteredBoxes = FilterBoundingBoxes(boundingBoxes, 2, 0.5f);\r\n\r\n                    boundingBoxes.Clear();\r\n                    boundingBoxes.AddRange(filteredBoxes);\r\n                }\r\n                else\r\n                {\r\n                    MessageBox.Show(\"Hình ảnh chưa được cung cấp nhận dạng trước trong file model.onnx, vui lòng thêm ảnh vào để nhận dạng!!\");\r\n                    return;\r\n                }\r\n\r\n                foreach (var boundingBox in boundingBoxes)\r\n                {\r\n                    float x = Math.Max(boundingBox.Dimensions.X, 0);\r\n                    float y = Math.Max(boundingBox.Dimensions.Y, 0);\r\n                    float width = Math.Min(originalWidth - x, boundingBox.Dimensions.Width);\r\n                    float height = Math.Min(originalHeight - y, boundingBox.Dimensions.Height);\r\n\r\n                    // fit to current image size\r\n                    x = originalWidth * x / ImageSettings.imageWidth;\r\n                    y = originalHeight * y / ImageSettings.imageHeight;\r\n                    width = originalWidth * width / ImageSettings.imageWidth;\r\n                    height = originalHeight * height / ImageSettings.imageHeight;\r\n\r\n                    using (var graphics = Graphics.FromImage(image))\r\n                    {\r\n                        graphics.DrawRectangle(new Pen(boundingBox.BoxColor, 3), x, y, width, height);\r\n                        graphics.DrawString(boundingBox.Description, new Font(FontFamily.Families[0], 30f), Brushes.Red, x + 5, y + 5);\r\n                    }\r\n                }\r\n\r\n                picPrediction.Image = image;\r\n                picPrediction.SizeMode = PictureBoxSizeMode.StretchImage;\r\n                picPrediction.Visible = true;\r\n                btnSelectImage.Visible = false;\r\n                btnNewPrediction.Visible = true;\r\n            }\r\n        }\r\n\r\n        public static List<BoundingBox> ParseOutputs(float[] modelOutput, string[] labels, float probabilityThreshold = .2f)\r\n        {\r\n            var boxes = new List<BoundingBox>();\r\n\r\n            for (int row = 0; row < rowCount; row++)\r\n            {\r\n                for (int column = 0; column < columnCount; column++)\r\n                {\r\n                    for (int box = 0; box < Anchors.Length; box++)\r\n                    {\r\n                        var channel = box * (labels.Length + featuresPerBox);\r\n\r\n                        var boundingBoxPrediction = ExtractBoundingBoxPrediction(modelOutput, row, column, channel);\r\n\r\n                        var mappedBoundingBox = MapBoundingBoxToCell(row, column, box, boundingBoxPrediction);\r\n\r\n                        if (boundingBoxPrediction.Confidence < probabilityThreshold)\r\n                            continue;\r\n\r\n                        float[] classProbabilities = ExtractClassProbabilities(modelOutput, row, column, channel, boundingBoxPrediction.Confidence, labels);\r\n\r\n                        var (topProbability, topIndex) = classProbabilities.Select((probability, index) => (Score: probability, Index: index)).Max();\r\n\r\n                        if (topProbability < probabilityThreshold)\r\n                            continue;\r\n\r\n                        boxes.Add(new BoundingBox\r\n                        {\r\n                            Dimensions = mappedBoundingBox,\r\n                            Confidence = topProbability,\r\n                            Label = labels[topIndex],\r\n                            BoxColor = BoundingBox.GetColor(topIndex)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return boxes;\r\n        }\r\n\r\n        public List<BoundingBox> FilterBoundingBoxes(List<BoundingBox> boxes, int limit, float iouThreshold)\r\n        {\r\n            var results = new List<BoundingBox>();\r\n            var filteredBoxes = new bool[boxes.Count];\r\n            var sortedBoxes = boxes.OrderByDescending(b => b.Confidence).ToArray();\r\n\r\n            for (int i = 0; i < boxes.Count; i++)\r\n            {\r\n                if (filteredBoxes[i])\r\n                    continue;\r\n\r\n                results.Add(sortedBoxes[i]);\r\n\r\n                if (results.Count >= limit)\r\n                    break;\r\n\r\n                for (var j = i + 1; j < boxes.Count; j++)\r\n                {\r\n                    if (filteredBoxes[j])\r\n                        continue;\r\n\r\n                    if (IntersectionOverUnion(sortedBoxes[i].Rect, sortedBoxes[j].Rect) > iouThreshold)\r\n                        filteredBoxes[j] = true;\r\n\r\n                    if (filteredBoxes.Count(b => b) <= 0)\r\n                        break;\r\n                }\r\n            }\r\n            return results;\r\n        }\r\n\r\n        private static BoundingBoxDimensions MapBoundingBoxToCell(int row, int column, int box, BoundingBoxPrediction boxDimensions)\r\n        {\r\n            const float cellWidth = ImageSettings.imageWidth / columnCount;\r\n            const float cellHeight = ImageSettings.imageHeight / rowCount;\r\n\r\n            var mappedBox = new BoundingBoxDimensions\r\n            {\r\n                X = (row + Sigmoid(boxDimensions.X)) * cellWidth,\r\n                Y = (column + Sigmoid(boxDimensions.Y)) * cellHeight,\r\n                Width = (float)Math.Exp(boxDimensions.Width) * cellWidth * Anchors[box].x,\r\n                Height = (float)Math.Exp(boxDimensions.Height) * cellHeight * Anchors[box].y,\r\n            };\r\n\r\n            // The x,y coordinates from the (mapped) bounding box prediction represent the center\r\n            // of the bounding box. We adjust them here to represent the top left corner.\r\n            mappedBox.X -= mappedBox.Width / 2;\r\n            mappedBox.Y -= mappedBox.Height / 2;\r\n\r\n            return mappedBox;\r\n        }\r\n\r\n        private static BoundingBoxPrediction ExtractBoundingBoxPrediction(float[] modelOutput, int row, int column, int channel)\r\n        {\r\n            return new BoundingBoxPrediction\r\n            {\r\n                X = modelOutput[GetOffset(row, column, channel++)],\r\n                Y = modelOutput[GetOffset(row, column, channel++)],\r\n                Width = modelOutput[GetOffset(row, column, channel++)],\r\n                Height = modelOutput[GetOffset(row, column, channel++)],\r\n                Confidence = Sigmoid(modelOutput[GetOffset(row, column, channel++)])\r\n            };\r\n        }\r\n\r\n        private float IntersectionOverUnion(RectangleF boundingBoxA, RectangleF boundingBoxB)\r\n        {\r\n            var areaA = boundingBoxA.Width * boundingBoxA.Height;\r\n            var areaB = boundingBoxB.Width * boundingBoxB.Height;\r\n\r\n            if (areaA <= 0 || areaB <= 0)\r\n                return 0;\r\n\r\n            var minX = (float)Math.Max(boundingBoxA.Left, boundingBoxB.Left);\r\n            var minY = (float)Math.Max(boundingBoxA.Top, boundingBoxB.Top);\r\n            var maxX = (float)Math.Min(boundingBoxA.Right, boundingBoxB.Right);\r\n            var maxY = (float)Math.Min(boundingBoxA.Bottom, boundingBoxB.Bottom);\r\n            var intersectionArea = (float)Math.Max(maxY - minY, 0) * (float)Math.Max(maxX - minX, 0);\r\n\r\n            return intersectionArea / (areaA + areaB - intersectionArea);\r\n        }\r\n\r\n        public static float[] ExtractClassProbabilities(float[] modelOutput, int row, int column, int channel, float confidence, string[] labels)\r\n        {\r\n            var classProbabilitiesOffset = channel + featuresPerBox;\r\n            float[] classProbabilities = new float[labels.Length];\r\n            for (int classProbability = 0; classProbability < labels.Length; classProbability++)\r\n                classProbabilities[classProbability] = modelOutput[GetOffset(row, column, classProbability + classProbabilitiesOffset)];\r\n            return Softmax(classProbabilities).Select(p => p * confidence).ToArray();\r\n        }\r\n\r\n        private static float Sigmoid(float value)\r\n        {\r\n            var k = (float)Math.Exp(value);\r\n            return k / (0.5f + k);\r\n        }\r\n\r\n        private static float[] Softmax(float[] classProbabilities)\r\n        {\r\n            var max = classProbabilities.Max();\r\n            var exp = classProbabilities.Select(v => Math.Exp(v - max));\r\n            var sum = exp.Sum();\r\n            return exp.Select(v => (float)v / (float)sum).ToArray();\r\n        }\r\n\r\n        private void btnNewPrediction_Click(object sender, EventArgs e)\r\n        {\r\n            btnNewPrediction.Visible = false;\r\n            picPrediction.Visible = false;\r\n            btnSelectImage.Visible = true;\r\n        }\r\n\r\n        private void Form1_Load(object sender, EventArgs e)\r\n        {\r\n            // size 108,37\r\n            // location 383, 106\r\n            btnNewPrediction.Size = new Size(108, 37);\r\n            btnNewPrediction.Location = new Point(383, 106);\r\n            btnNewPrediction.BackColor = Color.LightGreen;\r\n\r\n            btnSelectImage.Size = new Size(108, 37);\r\n            btnSelectImage.Location = new Point(383, 106);\r\n            btnSelectImage.BackColor = Color.LightGreen;\r\n            btnSelectImage.Text = \"Chọn ảnh\";\r\n        }\r\n\r\n        private static int GetOffset(int row, int column, int channel)\r\n        {\r\n            const int channelStride = rowCount * columnCount;\r\n            return (channel * channelStride) + (column * columnCount) + row;\r\n        }\r\n    }\r\n\r\n\r\n    class BoundingBoxPrediction : BoundingBoxDimensions\r\n    {\r\n        public float Confidence { get; set; }\r\n    }\r\n}\r\n\r\n`","Url":"https://github.com/dotnet/machinelearning/issues/6764","RelatedDescription":"Open issue \"System.ArgumentOutOfRangeException: 'Could not determine an IDataView type and registered custom types for member Image Parameter name: rawType'\" (#6764)"},{"Id":"1803342928","IsPullRequest":true,"CreatedAt":"2023-07-13T16:11:50","Actor":"asmirnov82","Number":"6763","RawContent":null,"Title":"Improve DataFrame Arithmetics implementation","State":"open","Body":"Fixes #6762\r\n\r\nFrom the issue:\r\n\r\n> The main goals of this Issue are:\r\n> \r\n> To simplify the code related to all Element Wise comparison operations\r\n> Make consistent return types for all PrimitiveColumnContainer.BinaryOperations\r\n> To avoid unnecessary memory copying and type conversion\r\n> Currently all Elementwise comparison operations are defined to have a return type as one of method parameters:\r\n> \r\n> void Operation ( ... , PrimitiveColumnContainer<bool> ret);\r\n> \r\n> to correctly create this parameter the caller has to the container by himself. In current implementation cloning of the existing column with changing it's type is widely used:\r\n> \r\n> PrimitiveDataFrameColumn<bool> retboolColumn = CloneAsBooleanColumn();\r\n> _columnContainer.Operation( ..., retboolColumn._columnContainer);\r\n> \r\n> Cloning of column of any type as Boolean Column is error-prone and potentialy may lead to unnecessary memory copying and speed decreasing.\r\n> \r\n> Possible solution is to change the signature of all Element Wise internal methods to correctly return required results and to create required objects inside the method, also make consistent retun type of PrimitiveColumnContainer for all PrimitiveColumnContainer.BinaryOperations (currently comparison operations return DataFrameColumn as other operation returns ColumnContainer)\r\n> \r\n> Only internal or private method's signatures are proposed to be changed. Public API should not be affected\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6763","RelatedDescription":"Open PR \"Improve DataFrame Arithmetics implementation\" (#6763)"},{"Id":"1803340186","IsPullRequest":false,"CreatedAt":"2023-07-13T16:10:02","Actor":"asmirnov82","Number":"6762","RawContent":null,"Title":"Improve DataFrame arithmetic implementation","State":"open","Body":"The main goals of this Issue are:\r\n\r\n1) To simplify the code related to all Element Wise comparison operations\r\n2) Make consistent return types for all PrimitiveColumnContainer.BinaryOperations\r\n3) To avoid unnecessary memory copying and type conversion \r\n\r\nCurrently all Elementwise comparison operations are defined to have a return type as one of method parameters:\r\n\r\n`void Operation ( ... , PrimitiveColumnContainer<bool> ret);`\r\n\r\nto correctly create this parameter the caller has to the container by himself. In current implementation cloning of the existing column with changing it's type is widely used:\r\n\r\n```\r\nPrimitiveDataFrameColumn<bool> retboolColumn = CloneAsBooleanColumn();\r\n_columnContainer.Operation( ..., retboolColumn._columnContainer);\r\n\r\n```\r\nCloning of column of any type as Boolean Column is error-prone and potentialy may lead to unnecessary memory copying and speed decreasing.\r\n\r\nPossible solution is to  change the signature of all Element Wise internal methods to correctly return required results and to create required objects inside the method, also make consistent retun type of PrimitiveColumnContainer for all PrimitiveColumnContainer.BinaryOperations (currently comparison operations return DataFrameColumn as other operation returns ColumnContainer)\r\n\r\nOnly internal or private method's signatures are proposed to be changed.  Public API should not be affected\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6762","RelatedDescription":"Open issue \"Improve DataFrame arithmetic implementation\" (#6762)"},{"Id":"1784870832","IsPullRequest":false,"CreatedAt":"2023-07-11T20:07:59","Actor":"nodakai","Number":"6754","RawContent":null,"Title":"Microsoft.Data.Analysis: meaningless lines of code?","State":"closed","Body":"https://github.com/dotnet/machinelearning/blob/4c799ab1c881de54328fdafbfcfc5352bd727e89/src/Microsoft.Data.Analysis/DataFrame.IO.cs#L132\r\n\r\nThe inner loop seems to be meaningless\r\n\r\nhttps://github.com/dotnet/machinelearning/blob/4c799ab1c881de54328fdafbfcfc5352bd727e89/src/Microsoft.Data.Analysis/PrimitiveColumnContainer.cs#L36\r\n\r\nIsn't the list guaranteed to be empty here within a ctor?","Url":"https://github.com/dotnet/machinelearning/issues/6754","RelatedDescription":"Closed issue \"Microsoft.Data.Analysis: meaningless lines of code?\" (#6754)"},{"Id":"1798653916","IsPullRequest":true,"CreatedAt":"2023-07-11T20:07:58","Actor":"asmirnov82","Number":"6761","RawContent":null,"Title":"Clean DataFrame meaningless code","State":"closed","Body":"Fixes #6754\r\n\r\n1) PrimitiveColumnContainer is internal class, PrimitiveColumnContainer(T[] values) is not used anywhere inside DataFrameProject and there is another constructor that can be used for the same purpose PrimitiveColumnContainer(IEnumerable<T> values). so this unused contructor can be easily removed (taking into account, that it contains errors - seems due to copy-past of code from the append method)\r\n\r\n2) Line \r\n`items[c] = items[c];  `\r\nis redundant, seems to appear after copy pasting from:\r\n\r\n```\r\npublic static async Task<DataFrame> LoadFrom(DbDataReader reader)\r\n...\r\n  for (var c = 0; c < columnsCount; c++)\r\n  {\r\n     items[c] = reader.IsDBNull(c)  ? null : reader[c];\r\n  }\r\n```\r\n\r\nMethod has unit tests. Changes don't affect method behaviour","Url":"https://github.com/dotnet/machinelearning/pull/6761","RelatedDescription":"Closed or merged PR \"Clean DataFrame meaningless code\" (#6761)"},{"Id":"1793000281","IsPullRequest":true,"CreatedAt":"2023-07-07T09:41:50","Actor":"asmirnov82","Number":"6759","RawContent":null,"Title":"Reduce coupling of Data.Analysis.Tests project","State":"closed","Body":"This PR continues work started in https://github.com/dotnet/machinelearning/pull/4346\r\n\r\nThe aim is to eliminate dependency of Microsoft.Data.Analysis.Tests from overal ML infrastructure. Before this PR it's required to build the overal ML solution (including native cpp projects) for running Unit tests for the DataFrame. Actually all these transative dependencies where the results of using Test attributes (like X86, X86X64 and NotArm32). Moving these attributes out of the Microsoft.ML.TestFramework into light Microsoft.ML.TestFrameworkCommon reduce coupling of tests projects.\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6759","RelatedDescription":"Closed or merged PR \"Reduce coupling of Data.Analysis.Tests project\" (#6759)"},{"Id":"1792884100","IsPullRequest":true,"CreatedAt":"2023-07-07T09:39:47","Actor":"asmirnov82","Number":"6758","RawContent":null,"Title":"Run tests that requires more than 2 Gb of memory only on 64-bit env","State":"closed","Body":"Run TestAppend_SizeMoreThanMaxBufferCapacity and TestAppendMany_SizeMoreThanMaxBufferCapacity tests on X64 env\r\n\r\nSee more details in https://github.com/dotnet/machinelearning/pull/6710\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6758","RelatedDescription":"Closed or merged PR \"Run tests that requires more than 2 Gb of memory only on 64-bit env\" (#6758)"},{"Id":"1790058379","IsPullRequest":true,"CreatedAt":"2023-07-06T20:16:02","Actor":"LittleLittleCloud","Number":"6756","RawContent":null,"Title":"AutoML.Net avoid empty dataset in trainValidationDatasetManager","State":"closed","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [x] There's a descriptive title that will make sense to other developers some time from now. \r\n- [x] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [x] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\nhttps://github.com/dotnet/machinelearning-modelbuilder/issues/2734\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6756","RelatedDescription":"Closed or merged PR \"AutoML.Net avoid empty dataset in trainValidationDatasetManager\" (#6756)"},{"Id":"1790624266","IsPullRequest":false,"CreatedAt":"2023-07-06T01:40:25","Actor":"pedoc","Number":"6757","RawContent":null,"Title":"[Feature Request] Create MLImage from SKBitmap instance in ML","State":"open","Body":"**Is your feature request related to a problem? Please describe.**\r\nConsider the following code snippet\r\n```csharp\r\n    MLContext mlContext = new MLContext()\r\n            {\r\n                FallbackToCpu = true,\r\n                GpuDeviceId = 0\r\n            };\r\n\r\n  var pipeline = mlContext.Transforms.ResizeImages(inputColumnName: \"bitmap\", outputColumnName: \"input_1\",\r\n                    imageWidth: 416, imageHeight: 416, resizing: ResizingKind.IsoPad)\r\n                .Append(mlContext.Transforms.ExtractPixels(outputColumnName: \"input_1\", scaleImage: 1f / 255f))\r\n                .Append(mlContext.Transforms.Concatenate(\"image_shape\", \"height\", \"width\"))\r\n                .Append(mlContext.Transforms.ApplyOnnxModel(\r\n                    shapeDictionary: new Dictionary<string, int[]>() { { \"input_1\", new[] { 1, 3, 416, 416 } } },\r\n                    inputColumnNames: new[]\r\n                    {\r\n                        \"input_1\",\r\n                        \"image_shape\"\r\n                    },\r\n                    outputColumnNames: new[]\r\n                    {\r\n                        \"yolonms_layer_1/ExpandDims_1:0\",\r\n                        \"yolonms_layer_1/ExpandDims_3:0\",\r\n                        \"yolonms_layer_1/concat_2:0\"\r\n                    },\r\n                    modelFile: modelPath, recursionLimit: 100));\r\n            var model = pipeline.Fit(mlContext.Data.LoadFromEnumerable(new List<YoloV3BitmapData>()));\r\n            var predictionEngine = mlContext.Model.CreatePredictionEngine<YoloV3BitmapData, YoloV3Prediction>(model);\r\n\r\n\t\t\tusing var bitmap = SKBitmap.Decode(\"C:\\test.jpg\");\r\n\t\t\tvar predict = predictionEngine.Predict(new YoloV3BitmapData()\r\n                    { Image = MLImage.CreateFromFile(\"C:\\test.jpg\") });\r\n            var results = GetResults(predict, classesNames);\r\n\r\n\t\t\t using var canvas = new SKCanvas(bitmap);\r\n                var paint = new SKPaint()\r\n                {\r\n                    Color = new SKColor(Color.Red.R, 0, 0,50),\r\n                    Style = SKPaintStyle.Fill\r\n                };\r\n                foreach (var result in results)\r\n                {\r\n                    var y1 = result.BBox[0];\r\n                    var x1 = result.BBox[1];\r\n                    var y2 = result.BBox[2];\r\n                    var x2 = result.BBox[3];\r\n\r\n                    canvas.DrawRect(x1, y1, x2 - x1, y2 - y1, paint);\r\n\r\n                    var paint2 = new SKPaint()\r\n                    {\r\n                        Color = new SKColor(0xff, 00, 00),\r\n                        Style = SKPaintStyle.Fill,\r\n                        Typeface = SKTypeface.FromFamilyName(\r\n                            \"Arial\",\r\n                            SKFontStyleWeight.Bold,\r\n                            SKFontStyleWidth.Normal,\r\n                            SKFontStyleSlant.Italic),\r\n                        TextSize = 18,\r\n                        IsAntialias = true,\r\n                        TextAlign = SKTextAlign.Center,\r\n                        IsStroke = false\r\n                    };\r\n\r\n                    canvas.DrawText(result.Label + \" \" + result.Confidence.ToString(\"0.00\"), new SKPoint(x1, y1),\r\n                        paint2);\r\n                }\r\n\r\n public class YoloV3BitmapData\r\n    {\r\n        [ColumnName(\"bitmap\")]\r\n        [ImageType(416, 416)]\r\n        public MLImage Image { get; set; }\r\n\r\n        [ColumnName(\"width\")]\r\n        public float ImageWidth => Image.Width;\r\n\r\n        [ColumnName(\"height\")]\r\n        public float ImageHeight => Image.Height;\r\n    }\r\n```\r\nIn the above code, we use ``SKBitmap.Decode`` and ``MLImage.CreateFromFile`` to load the image from the file, which results in 2 IO,\r\nSo if you can directly pass SKBitmap to MLImage, you will save 1 IO.\r\n\r\nSo we can write\r\n```csharp\r\nusing var bitmap = SKBitmap.Decode(\"C:\\test.jpg\");\r\nvar predict = predictionEngine.Predict(new YoloV3BitmapData() { Image = bitmap  });\r\n```\r\nor\r\n```csharp\r\nusing var bitmap = SKBitmap.Decode(\"C:\\test.jpg\");\r\nvar predict = predictionEngine.Predict(new YoloV3BitmapData() { Image = MLImage.CreateFromSKBitmap(bitmap)});\r\n```\r\n\r\n**Describe the solution you'd like**\r\nWe want to be able to simply pass SKBitmap to MLImage.\r\n\r\n**Describe alternatives you've considered**\r\nCurrently it is possible to do something similar with the following code, but it is more redundant and error-prone\r\n\r\n```csharp\r\nusing var fs=File.OpenRead(\"C:\\test.jpg\");\r\nusing var bitmap = SKBitmap.Decode(fs);\r\nvar predict = predictionEngine.Predict(new YoloV3BitmapData() { Image = MLImage.CreateFromStream(fs) });\r\n```\r\n\r\n**Additional context**\r\nIn addition, it would be useful to be able to expose the SKBitmap instance in MLImage, because this allows us to draw the detection results on the SKBitmap after obtaining the model detection results without additional coding.\r\n","Url":"https://github.com/dotnet/machinelearning/issues/6757","RelatedDescription":"Open issue \"[Feature Request] Create MLImage from SKBitmap instance in ML\" (#6757)"},{"Id":"1788237627","IsPullRequest":false,"CreatedAt":"2023-07-04T16:56:59","Actor":"torronen","Number":"6755","RawContent":null,"Title":"AutoML 2.0: regression throws The given key 'e4' was not present in the dictionary.","State":"open","Body":"**System Information (please complete the following information):**\r\n - OS & Version: windows 11\r\n - ML.NET Version: ML.NET nightly 4th July 2023\r\n - .NET Version: .NET 7.0\r\n\r\n**Describe the bug**\r\n\r\nWhen running regression experiment I got this error. It seems to appear at \"random\" experiment. I have got it on 2nd, 4th and now not yet for 21 trials.\r\n\r\n```\r\nSystem.Collections.Generic.KeyNotFoundException: The given key 'e4' was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Microsoft.ML.SearchSpace.SearchSpace.MappingToFeatureSpace(Parameter parameter)\r\n   at Microsoft.ML.SearchSpace.SearchSpace.MappingToFeatureSpace(Parameter parameter)\r\n   at Microsoft.ML.AutoML.CsvTrialResultManager.Save()\r\n   at Microsoft.ML.AutoML.AutoMLExperiment.RunAsync(CancellationToken ct)\r\n   at Kwork.MLTrainer2023Regression.Program.TrainRegression(List`1 trainingDataFiles, String LabelColumn, String saveTo, UInt32 trainingTimeSeconds) in C:\\git\\Kwork.MLTrainer2023\\Kwork.MLTrainer2023Regression\\Program.cs:line 422\r\n   at Kwork.MLTrainer2023Regression.Program.Main(String[] args) in C:\\git\\Kwork.MLTrainer2023\\Kwork.MLTrainer2023Regression\\Program.cs:line 190\r\nThe given key 'e4' was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Microsoft.ML.SearchSpace.SearchSpace.MappingToFeatureSpace(Parameter parameter)\r\n   at Microsoft.ML.SearchSpace.SearchSpace.MappingToFeatureSpace(Parameter parameter)\r\n   at Microsoft.ML.AutoML.CsvTrialResultManager.Save()\r\n   at Microsoft.ML.AutoML.AutoMLExperiment.RunAsync(CancellationToken ct)\r\n   at Kwork.MLTrainer2023Regression.Program.TrainRegression(List`1 trainingDataFiles, String LabelColumn, String saveTo, UInt32 trainingTimeSeconds) in C:\\git\\Kwork.MLTrainer2023\\Kwork.MLTrainer2023Regression\\Program.cs:line 422\r\n   at Kwork.MLTrainer2023Regression.Program.Main(String[] args) in C:\\git\\Kwork.MLTrainer2023\\Kwork.MLTrainer2023Regression\\\r\n\r\n```\r\n\r\n\r\n\r\nmy code:\r\n```\r\n                pipeline = ctx.Transforms\r\n               .SelectColumns(columnsToKeep) // Keep only the specified columns\r\n               .Append(ctx.Auto().Featurizer(data, columnInformation: columnInference.ColumnInformation))\r\n               .Append(ctx.Auto().Regression(labelColumnName: columnInference.ColumnInformation.LabelColumnName,\r\n                useFastForest: false, useSdca: false, useLbfgsPoissonRegression: false, useLgbm: false,\r\n               useFastTree: true\r\n               )); //disable slow FastForest, run LightGBM on GPU machine\r\n```\r\n               \r\n      ```\r\n AutoMLExperiment.AutoMLExperimentSettings settings = new AutoMLExperiment.AutoMLExperimentSettings();\r\n            AutoMLExperiment experiment = ctx.Auto().CreateExperiment();\r\n\r\n            // Configure experiment\r\n            experiment\r\n                .SetPipeline(pipeline)\r\n                .SetRegressionMetric(RegressionMetric.RootMeanSquaredError, labelColumn: columnInference.ColumnInformation.LabelColumnName)\r\n                .SetTrainingTimeInSeconds(trainingTimeSeconds)\r\n                .SetDataset(data, fold: NumFolds, samplingKeyColumnName: SamplingKeyColumn)\r\n                .SetEciCostFrugalTuner();\r\n\r\n            var monitor = new AutoMLMonitor(pipeline);\r\n            experiment.SetMonitor(monitor);\r\n\r\n            var cts = new CancellationTokenSource();\r\n            Console.WriteLine(\"Start experiment\");\r\n            TrialResult experimentResults = await experiment.RunAsync(cts.Token);\r\n```\r\n   \r\n   \r\n   ","Url":"https://github.com/dotnet/machinelearning/issues/6755","RelatedDescription":"Open issue \"AutoML 2.0: regression throws The given key 'e4' was not present in the dictionary.\" (#6755)"},{"Id":"1782672648","IsPullRequest":false,"CreatedAt":"2023-06-30T14:53:20","Actor":"tafo","Number":"6751","RawContent":null,"Title":"AutoML.NET: ArgumentOutOfRangeException: Score column 'Score' not found Arg_ParamName_Name","State":"open","Body":"**System Information:**\r\n - Windows 11\r\n - ML.NET 2.0.1\r\n - .NET 6.0\r\n - AutoML.Net 0.20.1\r\n\r\n**Problem**\r\nI was trying to build a model with AutoML.NET Api. I was following the steps in https://learn.microsoft.com/en-us/dotnet/machine-learning/how-to-guides/how-to-use-the-automl-api, \r\nThe only difference between my example and the reference example is the type of label column. I am using a string for my label column. \r\n\r\n**Code**\r\n```csharp\r\nvar ctx = new MLContext();\r\nvar cols = new[]\r\n{\r\n    new TextLoader.Column(name: \"comment\", dataKind: DataKind.String, index: 0),\r\n    new TextLoader.Column(name: \"status\", dataKind: DataKind.String, index: 1),\r\n    new TextLoader.Column(name: \"dataSet\", dataKind: DataKind.String, index: 2)\r\n};\r\n\r\nvar loader = ctx.Data.CreateTextLoader(cols, separatorChar: '~', hasHeader: true);\r\nvar dataView = loader.Load(\"Comment.csv\");\r\nvar trainValidationData = ctx.Data.TrainTestSplit(dataView, testFraction: 0.2);\r\nvar pipeline = ctx.Auto().Featurizer(dataView, \"Features\", new[] { \"dataSet\" }, null, new[] { \"comment\" }, excludeColumns: new[] { \"status\" });\r\nvar anotherExperiment = ctx.Auto().CreateExperiment(new AutoMLExperiment.AutoMLExperimentSettings { MaxExperimentTimeInSeconds = 60 });\r\nanotherExperiment.SetPipeline(pipeline);\r\nanotherExperiment.SetDataset(trainValidationData);\r\nanotherExperiment.SetMulticlassClassificationMetric(MulticlassClassificationMetric.MicroAccuracy, \"status\");\r\n\r\nctx.Log += (_, e) =>\r\n{\r\n    if (e.Source.Equals(\"AutoMLExperiment\"))\r\n    {\r\n        Console.WriteLine(e.RawMessage);\r\n    }\r\n};\r\n\r\nvar result = anotherExperiment.Run();\r\nConsole.WriteLine(\"Finished\");\r\nConsole.ReadLine();\r\n```\r\n\r\n** Very Simple Data Set **\r\ncomment,status,dataset\r\n\"Felaket\",Negative,ProductComment\r\n\"Harika\",Positive,ProductComment\r\n\"Bilmem\",Notr,ProductComment\r\n...\r\n\r\n**Expected behavior**\r\nI do not even understand the exception (:","Url":"https://github.com/dotnet/machinelearning/issues/6751","RelatedDescription":"Open issue \"AutoML.NET: ArgumentOutOfRangeException: Score column 'Score' not found Arg_ParamName_Name\" (#6751)"},{"Id":"1782303763","IsPullRequest":false,"CreatedAt":"2023-06-30T13:24:57","Actor":"ermolaevakate","Number":"6750","RawContent":null,"Title":"ML.Net stuck on pretrained model Fit() method","State":"closed","Body":"**System Information (please complete the following information):**\r\n - Windows 10\r\n - ML.NET Version (downloaded through Nuget last stable version 2.0.1): \r\n - .NET Framework Version: 4.8\r\n\r\nthere is some code example which works with Pretrained model (link to whole example page https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.textcatalog.applywordembedding?view=ml-dotnet):\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n```\r\n`using System;\r\nusing System.Collections.Generic;\r\nusing Microsoft.ML;\r\nusing Microsoft.ML.Transforms.Text;\r\n\r\nnamespace Samples.Dynamic\r\n{\r\n    public static class ApplyWordEmbedding\r\n    {\r\n        public static void Example()\r\n        {\r\n        // Create a new ML context, for ML.NET operations. It can be used for\r\n        // exception tracking and logging, as well as the source of randomness.\r\n        var mlContext = new MLContext();\r\n\r\n        // Create an empty list as the dataset. The 'ApplyWordEmbedding' does\r\n        // not require training data as the estimator ('WordEmbeddingEstimator')\r\n        // created by 'ApplyWordEmbedding' API is not a trainable estimator.\r\n        // The empty list is only needed to pass input schema to the pipeline.\r\n        var emptySamples = new List<TextData>();\r\n\r\n        // Convert sample list to an empty IDataView.\r\n        var emptyDataView = mlContext.Data.LoadFromEnumerable(emptySamples);\r\n\r\n        // A pipeline for converting text into a 150-dimension embedding vector\r\n        // using pretrained 'SentimentSpecificWordEmbedding' model. The\r\n        // 'ApplyWordEmbedding' computes the minimum, average and maximum values\r\n        // for each token's embedding vector. Tokens in \r\n        // 'SentimentSpecificWordEmbedding' model are represented as\r\n        // 50 -dimension vector. Therefore, the output is of 150-dimension [min,\r\n        // avg, max].\r\n        //\r\n        // The 'ApplyWordEmbedding' API requires vector of text as input.\r\n        // The pipeline first normalizes and tokenizes text then applies word\r\n        // embedding transformation.\r\n        var textPipeline = mlContext.Transforms.Text.NormalizeText(\"Text\")\r\n            .Append(mlContext.Transforms.Text.TokenizeIntoWords(\"Tokens\",\r\n                \"Text\"))\r\n            .Append(mlContext.Transforms.Text.ApplyWordEmbedding(\"Features\",\r\n                \"Tokens\", WordEmbeddingEstimator.PretrainedModelKind\r\n                .FastTextWikipedia300D));\r\n\r\n        // Fit to data.\r\n        var textTransformer = textPipeline.Fit(emptyDataView);\r\n\r\n        // Create the prediction engine to get the embedding vector from the\r\n        // input text/string.\r\n        var predictionEngine = mlContext.Model.CreatePredictionEngine<TextData,\r\n            TransformedTextData>(textTransformer);\r\n\r\n        // Call the prediction API to convert the text into embedding vector.\r\n        var data = new TextData()\r\n        {\r\n            Text = \"This is a great product. I would \" +\r\n            \"like to buy it again.\"\r\n        };\r\n        var prediction = predictionEngine.Predict(data);\r\n\r\n        // Print the length of the embedding vector.\r\n        Console.WriteLine($\"Number of Features: {prediction.Features.Length}\");\r\n\r\n        // Print the embedding vector.\r\n        Console.Write(\"Features: \");\r\n        foreach (var f in prediction.Features)\r\n            Console.Write($\"{f:F4} \");\r\n\r\n        //  Expected output:\r\n        //   Number of Features: 150\r\n        //   Features: -1.2489 0.2384 -1.3034 -0.9135 -3.4978 -0.1784 -1.3823 -0.3863 -2.5262 -0.8950 ...\r\n    }\r\n\r\n    private class TextData\r\n    {\r\n        public string Text { get; set; }\r\n    }\r\n    private class TransformedTextData : TextData\r\n    {\r\n        public float[] Features { get; set; }\r\n    }\r\n}} \r\n```\r\n\r\n\r\n**Expected behavior**\r\nSo, in my case if I use FastTextWikipedia300D OR Glove200D OR Glove 100D pretrained models there is a stuck process which not ends even after 10 mins while run there:\r\n\r\n` var textTransformer = textPipeline.Fit(emptyDataView);`\r\n\r\nI tried use this resolution: https://stackoverflow.com/a/54561423/5168936 But adding doesn't have any effect\r\n\r\n` AppendCacheCheckpoint(mlContext)`\r\n\r\nare there any ways to understand why this happened? It seems as a bug for me; thank you!\r\nIn debug console there is a lot of messages like: \r\n```\r\nThe thread 0x4284 has exited with code 0 (0x0).\r\nThe thread 0x4ae8 has exited with code 0 (0x0).\r\nThe thread 0x30fc has exited with code 0 (0x0).\r\nThe thread 0x5a8c has exited with code 0 (0x0).\r\n```\r\n\r\n\r\n**Additional context**\r\nIf  I use SentimentSpecificWordEmbedding pretrained model everything is OK and I can return vector for it;","Url":"https://github.com/dotnet/machinelearning/issues/6750","RelatedDescription":"Closed issue \"ML.Net stuck on pretrained model Fit() method\" (#6750)"},{"Id":"1781605931","IsPullRequest":true,"CreatedAt":"2023-06-29T22:47:36","Actor":"JakeRadMSFT","Number":"6749","RawContent":null,"Title":"Update Projects to .NET 8 in MLNET 4.0 Branch","State":"open","Body":"- This PR drops netfx and .netstandard support.\r\n- ML.NET 4.0 will target .NET 8\r\n- Fixes various issues hit targeting .NET 8\r\n- Cleans up build/project files to remove multi-targeting related things (probably still more work to do here)\r\n\r\nTODO:\r\n\r\n- [ ] Open bug for looking at our code analysis things\r\n- [ ] Open bug enabling the nullable things for entire repo\r\n- [ ] Open bug to consolidate to a shared ApiCompatSuppressionFile\r\n   - Reference: `https://github.com/search?q=repo%3Adotnet%2Fruntime%20ApiCompatSuppressionFile&type=code`\r\n- [ ] Open bug for removing TargetFramework/NET8 from Build Definition ","Url":"https://github.com/dotnet/machinelearning/pull/6749","RelatedDescription":"Open PR \"Update Projects to .NET 8 in MLNET 4.0 Branch\" (#6749)"},{"Id":"1779789165","IsPullRequest":true,"CreatedAt":"2023-06-28T21:21:34","Actor":"JakeRadMSFT","Number":"6748","RawContent":null,"Title":"Rebase 4.0 Branch on Main","State":"closed","Body":"We are excited to review your PR.\r\n\r\nSo we can do the best job, please check:\r\n\r\n- [ ] There's a descriptive title that will make sense to other developers some time from now. \r\n- [ ] There's associated issues. All PR's should have issue(s) associated - unless a trivial self-evident change such as fixing a typo. You can use the format `Fixes #nnnn` in your description to cause GitHub to automatically close the issue(s) when your PR is merged.\r\n- [ ] Your change description explains what the change does, why you chose your approach, and anything else that reviewers should know.\r\n- [ ] You have included any necessary tests in the same PR.\r\n\r\n","Url":"https://github.com/dotnet/machinelearning/pull/6748","RelatedDescription":"Closed or merged PR \"Rebase 4.0 Branch on Main\" (#6748)"},{"Id":"1779567789","IsPullRequest":true,"CreatedAt":"2023-06-28T19:08:59","Actor":"JakeRadMSFT","Number":"6747","RawContent":null,"Title":"Merge Main into Feature/4.0","State":"open","Body":"","Url":"https://github.com/dotnet/machinelearning/pull/6747","RelatedDescription":"Open PR \"Merge Main into Feature/4.0\" (#6747)"},{"Id":"1778222881","IsPullRequest":false,"CreatedAt":"2023-06-28T05:22:59","Actor":"arung2207","Number":"6746","RawContent":null,"Title":"More explaination needed","State":"open","Body":"More description about how to specify the Weights, can it be only one field or a combination of fields with examples should be provided.\r\n\r\n\r\n---\r\n#### Document Details\r\n\r\n⚠ *Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.*\r\n\r\n* ID: 56cb251f-c6b8-964e-fbad-60411e0f7f8d\r\n* Version Independent ID: 4ace19d6-df67-0c78-a7b8-7079e9b6e7a6\r\n* Content: [UnsupervisedTrainerInputBaseWithWeight.ExampleWeightColumnName Field (Microsoft.ML.Trainers)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.trainers.unsupervisedtrainerinputbasewithweight.exampleweightcolumnname?view=ml-dotnet)\r\n* Content Source: [dotnet/xml/Microsoft.ML.Trainers/UnsupervisedTrainerInputBaseWithWeight.xml](https://github.com/dotnet/ml-api-docs/blob/live/dotnet/xml/Microsoft.ML.Trainers/UnsupervisedTrainerInputBaseWithWeight.xml)\r\n* Product: **dotnet-ml-api**\r\n* GitHub Login: @natke\r\n* Microsoft Alias: **nakersha**","Url":"https://github.com/dotnet/machinelearning/issues/6746","RelatedDescription":"Open issue \"More explaination needed\" (#6746)"}],"ResultType":"GitHubIssue"}},"RunOn":"2023-07-27T03:30:19.359619Z","RunDurationInMilliseconds":504}