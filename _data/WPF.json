{"Data":{"GitHub":{"Issues":[{"Id":"644311513","IsPullRequest":true,"CreatedAt":"2020-06-24T05:02:58","Actor":"dotnet-maestro[bot]","Number":"3167","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: 256c8be3-de58-46f5-d219-08d6ba11f126\r\n- **Build**: 20200623.6\r\n- **Date Produced**: 6/24/2020 4:26 AM\r\n- **Commit**: fe51dd5bcf6b27c043bd59cb69108a1c5e33446a\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 5.0.0-preview.8.20323.4 to 5.0.0-preview.8.20323.6\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3167","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#3167)"},{"Id":"644233605","IsPullRequest":true,"CreatedAt":"2020-06-24T02:58:34","Actor":"dotnet-maestro[bot]","Number":"3166","RawContent":null,"Title":"[release/5.0-preview7] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.Win32.Registry**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.CodeDom**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Configuration.ConfigurationManager**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Diagnostics.EventLog**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.DirectoryServices**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Drawing.Common**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Reflection.MetadataLoadContext**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.AccessControl**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Cryptography.Xml**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Permissions**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Principal.Windows**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Windows.Extensions**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.Platforms**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.IO.Packaging**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.ILDAsm**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.ILAsm**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **System.Resources.Extensions**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.App.Internal**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4 (parent: Microsoft.Private.Winforms)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n[marker]: <> (Begin:14488d01-4e4b-4cf9-4e12-08d812f95845)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: 14488d01-4e4b-4cf9-4e12-08d812f95845\r\n- **Build**: 20200623.5\r\n- **Date Produced**: 6/24/2020 12:22 AM\r\n- **Commit**: 5ea4571b5837490ea535cd57a39453a59d5eac21\r\n- **Branch**: refs/heads/release/5.0-preview7\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 5.0.0-preview.8.20323.2 to 5.0.0-preview.7.20323.5\r\n  - **Microsoft.Win32.Registry**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.CodeDom**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Configuration.ConfigurationManager**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Diagnostics.EventLog**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.DirectoryServices**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Drawing.Common**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Reflection.MetadataLoadContext**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Security.AccessControl**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Security.Cryptography.Xml**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Security.Permissions**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Security.Principal.Windows**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Windows.Extensions**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **Microsoft.NETCore.Platforms**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.IO.Packaging**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **Microsoft.NETCore.ILDAsm**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **Microsoft.NETCore.ILAsm**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **System.Resources.Extensions**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n  - **Microsoft.NETCore.App.Internal**: from 5.0.0-preview.7.20320.5 to 5.0.0-preview.7.20323.4\r\n\r\n[marker]: <> (End:14488d01-4e4b-4cf9-4e12-08d812f95845)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3166","RelatedDescription":"Closed or merged PR \"[release/5.0-preview7] Update dependencies from dotnet/winforms\" (#3166)"},{"Id":"644222838","IsPullRequest":true,"CreatedAt":"2020-06-24T02:54:10","Actor":"ryalanms","Number":"3165","RawContent":null,"Title":"Update branding to preview8","State":"closed","Body":"","Url":"https://github.com/dotnet/wpf/pull/3165","RelatedDescription":"Closed or merged PR \"Update branding to preview8\" (#3165)"},{"Id":"644198698","IsPullRequest":true,"CreatedAt":"2020-06-24T00:15:04","Actor":"dotnet-maestro[bot]","Number":"3164","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: 256c8be3-de58-46f5-d219-08d6ba11f126\r\n- **Build**: 20200623.4\r\n- **Date Produced**: 6/23/2020 10:38 PM\r\n- **Commit**: e2ccd96a21c8efc46fd30a9429ee3e36f021db76\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 5.0.0-preview.8.20323.2 to 5.0.0-preview.8.20323.4\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3164","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#3164)"},{"Id":"641151446","IsPullRequest":true,"CreatedAt":"2020-06-23T18:32:08","Actor":"dotnet-maestro[bot]","Number":"3153","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 3a1d3bb6-c64d-406d-e8f4-08d648cf64cb\r\n- **Build**: 20200616.1\r\n- **Date Produced**: 6/16/2020 3:17 PM\r\n- **Commit**: 71b580038fb704df63e03c6b7ae7d2c6a4fdd71d\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n  - **Microsoft.DotNet.Arcade.Sdk**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n  - **Microsoft.DotNet.CodeAnalysis**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n  - **Microsoft.DotNet.GenAPI**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n  - **Microsoft.DotNet.Helix.Sdk**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3153","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#3153)"},{"Id":"644033260","IsPullRequest":true,"CreatedAt":"2020-06-23T17:55:44","Actor":"ryalanms","Number":"3163","RawContent":null,"Title":"Update global.json SDK and tools version to include fix for _BlockWinMDsOnSupportedTFMs causing build failures","State":"closed","Body":"This update (darc-master-89e15d90-235e-4313-959a-f0283bd51d70) caused APICompat to start failing. APICompat expects PresentationUI.dll to exist in wpf.tools\\native\\bin\\net-framework-48-ref-assemblies\\0.0.0.1.\r\n\r\nThe is due to the initial version of the _BlockWinMDsOnUnsupportedTFMs target: \r\n\r\n`.dotnet\\sdk\\5.0.100-preview.6.20310.4\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.Sdk.targets`\r\n\r\n<Target Name=\"_BlockWinMDsOnUnsupportedTFMs\"\r\nBeforeTargets=\"CoreCompile\"\r\nDependsOnTargets=\"ResolveReferences\"\r\n\r\nThe version of the SDK must include the fix for _BlockWinMDsOnUnsupportedTFMs (Preview6.20310.4 does not include the fix).  Update global.json SDK and tools version to include fix for _BlockWinMDsOnSupportedTFMs.\r\n\r\n(Fixed #3153)","Url":"https://github.com/dotnet/wpf/pull/3163","RelatedDescription":"Closed or merged PR \"Update global.json SDK and tools version to include fix for _BlockWinMDsOnSupportedTFMs causing build failures\" (#3163)"},{"Id":"643939273","IsPullRequest":true,"CreatedAt":"2020-06-23T15:50:34","Actor":"dotnet-maestro[bot]","Number":"3162","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200623.1\r\n- **Date Produced**: 6/23/2020 3:16 PM\r\n- **Commit**: 2d76df3454dfcaa60afabee09ff26397d8e31f2f\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20321.2 to 5.0.0-preview.7.20323.1\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3162","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3162)"},{"Id":"643504875","IsPullRequest":false,"CreatedAt":"2020-06-23T06:29:36","Actor":"joshman1019","Number":"3161","RawContent":null,"Title":"System.Windows.Controls.Frame returns NullReferenceException when assigning content property to a variable or when trying to access it directly.","State":"closed","Body":"Version: .Net Core 3.1,\r\nDevelopment Environment: Visual Studio 2019 Community\r\nWPF-MVVM Pattern\r\nWhen attempting to assign System.Windows.Controls.Frame.Content property to a new variable, I am receiving a NullReferenceException, which does not occur in .Net Framework 4.7.1. \r\n\r\nThe following is an exact copy of my StackOverflow question which has yielded no answers:\r\n\r\nI am developing a WPF application using .Net Core 3.1 (MVVM pattern), and I have run across an issue that I have never had in .Net framework on other applications I've developed. \r\n\r\nMy main window has a frame which hosts the various pages within my application. That frame's content is set by a \"PropertyChanged\" event fired by the application viewmodel. I am doing it this way, instead of binding directly to the CurrentPage property, because I want to call an animation that fades out the page prior to the next one being loaded. \r\n\r\nMy application viewmodel looks like this:\r\n(NOTE: BaseViewmodel inherits INotifyPropertyChanged and I use PropertyChanged.Fody to handle the property change events)\r\n\r\n```\r\n    public class ApplicationViewmodel : BaseViewmodel\r\n    {\r\n        #region Constructor \r\n\r\n        /// <summary>\r\n        /// Default constructor\r\n        /// </summary>\r\n        public ApplicationViewmodel()\r\n        {\r\n            SetInitialPage(); \r\n        }\r\n\r\n        #endregion\r\n\r\n        #region Properties \r\n\r\n        /// <summary>\r\n        /// Current page hosted by the application \r\n        /// </summary>\r\n        public ApplicationPageTypes CurrentPage { get; set; }\r\n\r\n        #endregion\r\n\r\n        #region Public Methods \r\n\r\n        /// <summary>\r\n        /// Navigates to a new application page \r\n        /// </summary>\r\n        /// <param name=\"page\"></param>\r\n        public void GoToPage(ApplicationPageTypes page)\r\n        {\r\n            CurrentPage = page; \r\n        }\r\n\r\n        #endregion\r\n\r\n        #region Public Methods \r\n\r\n        /// <summary>\r\n        /// Sets the initial page for the application upon construction \r\n        /// </summary>\r\n        private void SetInitialPage()\r\n        {\r\n            CurrentPage = ApplicationPageTypes.MainMenu;\r\n        }\r\n\r\n        #endregion\r\n    }\r\n```\r\n\r\nMy application's main window has a frame component named BaseFrame. That frame's content is set initially by the viewmodel and window constructor. After being initially set, I have subscribed to the PropertyChanged event on the viewmodel, and am specifically watching for CurrentPage to be changed. Once that occurs, the page is supposed to animate out (if a previous page exists within the frame) and then load in the next page. I usually handle this by creating a variable containing the current content, await the animate out, and then allowing the content to be updated. (NOTE: The enum ApplicationPageTypes is extended in my UI project, which fetches the proper page. You will see this extension method called within the window's interaction logic.)\r\n\r\nMy window's interaction logic looks like this: \r\n\r\n```\r\n    public partial class MainWindow : Window\r\n    {\r\n        public MainWindow()\r\n        {\r\n            DataContext = SVMC.ApplicationViewmodel; \r\n            InitializeComponent();\r\n            SetInitialPage();\r\n            EventSubscriber(); \r\n        }\r\n\r\n        private void SetInitialPage()\r\n        {\r\n            BaseFrame.Content = new BasePage(); \r\n            BaseFrame.Content = SVMC.ApplicationViewmodel.CurrentPage.GetBasePageFromPageType(); \r\n        }\r\n\r\n        public void EventSubscriber()\r\n        {\r\n            SVMC.ApplicationViewmodel.PropertyChanged += async delegate (object sender, PropertyChangedEventArgs e)\r\n            {\r\n                if(e.PropertyName == nameof(SVMC.ApplicationViewmodel.CurrentPage))\r\n                {\r\n                    if (BaseFrame.Content != null)\r\n                    {\r\n                        BasePage currentPage = BaseFrame.Content as BasePage;\r\n                        await currentPage.FadeOut();\r\n                    }\r\n                    BaseFrame.Content = SVMC.ApplicationViewmodel.CurrentPage.GetBasePageFromPageType();\r\n                }\r\n            };\r\n        }\r\n    }\r\n```\r\nMy current BasePage, which all other pages inherit, looks like this:\r\n\r\n```\r\n    public class BasePage<T> : Page\r\n       where T : BaseViewmodel, new()\r\n    {\r\n        public T ViewModel { get; private set; }\r\n\r\n        public BasePage()\r\n        {\r\n            ViewModel = new T();\r\n            DataContext = ViewModel;\r\n            Loaded += async delegate (object sender, RoutedEventArgs e)\r\n            {\r\n                await FadeIn(); \r\n            };\r\n        }\r\n\r\n        public async Task FadeOut()\r\n        {\r\n            Opacity = 1;\r\n            DoubleAnimation fadeInAnimation = new DoubleAnimation();\r\n            fadeInAnimation.From = 1;\r\n            fadeInAnimation.To = 0;\r\n            fadeInAnimation.Duration = new Duration(TimeSpan.FromMilliseconds(400));\r\n            fadeInAnimation.EasingFunction = new QuadraticEase();\r\n\r\n            Storyboard sb = new Storyboard();\r\n            sb.Children.Add(fadeInAnimation);\r\n            Storyboard.SetTarget(sb, this);\r\n            Storyboard.SetTargetProperty(sb, new PropertyPath(OpacityProperty));\r\n            sb.Begin();\r\n            await Task.Delay(400); \r\n        }\r\n\r\n        public async Task FadeIn()\r\n        {\r\n            Opacity = 0;\r\n            DoubleAnimation fadeOutAnimation = new DoubleAnimation();\r\n            fadeOutAnimation.From = 0;\r\n            fadeOutAnimation.To = 1;\r\n            fadeOutAnimation.Duration = new Duration(TimeSpan.FromMilliseconds(400));\r\n            fadeOutAnimation.EasingFunction = new QuadraticEase();\r\n\r\n            Storyboard sb = new Storyboard();\r\n            sb.Children.Add(fadeOutAnimation);\r\n            Storyboard.SetTarget(sb, this);\r\n            Storyboard.SetTargetProperty(sb, new PropertyPath(OpacityProperty));\r\n            sb.Begin();\r\n            await Task.Delay(400);\r\n        }\r\n    }\r\n```\r\nMy problem is that when stepping through, the BaseFrame.Content property passes the first null check, but then fails with a NullReferenceException when I assign the content to a variable. \r\n```\r\n        public void EventSubscriber()\r\n        {\r\n            SVMC.ApplicationViewmodel.PropertyChanged += async delegate (object sender, PropertyChangedEventArgs e)\r\n            {\r\n                if(e.PropertyName == nameof(SVMC.ApplicationViewmodel.CurrentPage))\r\n                {\r\n                    if (BaseFrame.Content != null)\r\n                    {\r\n                        BasePage currentPage = BaseFrame.Content as BasePage;\r\n                        await currentPage.FadeOut(); <==== ***NULL REFERENCE EXCEPTION HERE***\r\n                    }\r\n                    BaseFrame.Content = SVMC.ApplicationViewmodel.CurrentPage.GetBasePageFromPageType();\r\n                }\r\n            };\r\n        }\r\n```","Url":"https://github.com/dotnet/wpf/issues/3161","RelatedDescription":"Closed issue \"System.Windows.Controls.Frame returns NullReferenceException when assigning content property to a variable or when trying to access it directly.\" (#3161)"},{"Id":"643111396","IsPullRequest":true,"CreatedAt":"2020-06-22T14:19:26","Actor":"lindexi","Number":"3160","RawContent":null,"Title":"Remove special vs version on the link","State":"open","Body":"When we remove a specific version, we will use the latest version by default\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3160","RelatedDescription":"Open PR \"Remove special vs version on the link\" (#3160)"},{"Id":"642988752","IsPullRequest":false,"CreatedAt":"2020-06-22T11:27:11","Actor":"felixhirt","Number":"3159","RawContent":null,"Title":"ListCollectionView Refresh throws an ArgumentNullException","State":"open","Body":"* .NET Core Version: 3.1.400-preview-015151\r\n* Windows version: win10 2004\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\nListCollectionView.Refresh runs after CollectionView.DetachFromSourceCollection (or something else) set SourceCollection to null and throws an exception\r\n \r\n **Actual behavior:**\r\nFor some reason (unfortunately, im unable to manufacture a simple repro, it only happens seemingly random at runtime on one specific view when it is discarded/goes out of scope), ListCollectionView.Refresh runs after a CollectionView.DetachFromSourceCollection and throws an argument null exception. Trace:\r\n System.ArgumentNullException: Collection cannot be null.\r\nParameter name: c\r\n   at System.Collections.ArrayList..ctor(ICollection c)\r\n   at System.Windows.Data.ListCollectionView.<RefreshOverride>b__1_0()\r\n   at MS.Internal.Data.SynchronizationInfo.AccessCollection(IEnumerable collection, Action accessMethod, Boolean writeAccess)\r\n   at System.Windows.Data.BindingOperations.AccessCollection(IEnumerable collection, Action accessMethod, Boolean writeAccess)\r\n   at System.Windows.Data.ListCollectionView.RefreshOverride()\r\n   at System.Windows.Data.CollectionView.RefreshInternal()\r\n   at System.Windows.Data.CollectionView.ProcessChangeLog(ArrayList changeLog, Boolean processAll)\r\n   at System.Windows.Data.CollectionView.ProcessInvoke(Object arg)\r\n   at MS.Internal.Data.DataBindEngine.ProcessCrossThreadRequests()\r\n   at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs)\r\n   at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Int32 numArgs, Delegate catchHandler)\r\n\r\nWhile im not 100% sure its CollectionView.DetachFromSourceCollection which sets the SourceCollection to null, it seems highly likely.\r\n\r\n **Expected behavior:**\r\nDo nothing if the source collection is gone (or clear the contents of the shadow collection? Is there a scenario where this happens legit, i.e. the view is still shown to the user? It does not seem so)\r\n \r\n **Minimal repro:**\r\nUnfortunately, the app is rather complex and i cannot pinpoint the exact point of failure. It happens on a view which has a CollectionViewSource with grouping in its resources which is used by a listview. But we have similar things in other places and it works.\r\n\r\n**Workaround:**\r\nWe are able to work around it be creating the collectionviewsource in the viewmodel, and bind the listview itemssource to its CollectionView","Url":"https://github.com/dotnet/wpf/issues/3159","RelatedDescription":"Open issue \"ListCollectionView Refresh throws an ArgumentNullException\" (#3159)"},{"Id":"642560069","IsPullRequest":true,"CreatedAt":"2020-06-21T13:21:15","Actor":"dotnet-maestro[bot]","Number":"3158","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200621.2\r\n- **Date Produced**: 6/21/2020 12:58 PM\r\n- **Commit**: 0e7f69bfbdf1205f696e03ab7d3ccad19ac99ca1\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20320.2 to 5.0.0-preview.7.20321.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3158","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3158)"},{"Id":"642372738","IsPullRequest":true,"CreatedAt":"2020-06-20T13:16:21","Actor":"dotnet-maestro[bot]","Number":"3157","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200620.2\r\n- **Date Produced**: 6/20/2020 12:58 PM\r\n- **Commit**: f6df3387759762ae57db39e3696f13167142975a\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20319.2 to 5.0.0-preview.7.20320.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3157","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3157)"},{"Id":"641957283","IsPullRequest":true,"CreatedAt":"2020-06-19T13:19:47","Actor":"dotnet-maestro[bot]","Number":"3156","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200619.2\r\n- **Date Produced**: 6/19/2020 1:02 PM\r\n- **Commit**: e4001533a9cdd2e15317fc5f179a81e2643f690e\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20318.2 to 5.0.0-preview.7.20319.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3156","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3156)"},{"Id":"641593827","IsPullRequest":true,"CreatedAt":"2020-06-18T22:50:36","Actor":"wli3","Number":"3155","RawContent":null,"Title":"Muti target 5.0 second part","State":"open","Body":"","Url":"https://github.com/dotnet/wpf/pull/3155","RelatedDescription":"Open PR \"Muti target 5.0 second part\" (#3155)"},{"Id":"641206714","IsPullRequest":true,"CreatedAt":"2020-06-18T14:16:20","Actor":"dotnet-maestro[bot]","Number":"3154","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200618.2\r\n- **Date Produced**: 6/18/2020 1:08 PM\r\n- **Commit**: 28d4c610881934a5f101b00f145dd0e94fa37d36\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20317.2 to 5.0.0-preview.7.20318.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3154","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3154)"},{"Id":"640978170","IsPullRequest":false,"CreatedAt":"2020-06-18T07:32:06","Actor":"ryalanms","Number":"3152","RawContent":null,"Title":"XamlXmlWriter is including the namespace for each element","State":"open","Body":"* .NET Core Version: (e.g. 3.0 Preview1, or daily build number, use `dotnet --info`)\r\n\r\nPreview6.  Regression from Preview5.\r\n\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes/No\r\n\r\nNo.\r\n \r\n **Problem description:**\r\n \r\nXamlXmlWriter is including the namespace where it wasn't before.\r\n \r\n **Minimal repro:**\r\n\r\n```csharp\r\n            XamlSchemaContext xsc = new XamlSchemaContext();\r\n            var generated = new StringBuilder();\r\n            var xmlSettings = new XmlWriterSettings { Indent = true, OmitXmlDeclaration = true };\r\n\r\n            var hashSetAssemblyName = typeof(HashSet<List<BigContainer>>).GetAssemblyName();\r\n            var listAssemblyName = typeof(List<Dictionary<int, HashSet<List<BigContainer>>>>).GetAssemblyName();\r\n\r\n            using (XamlXmlWriter writer = new XamlXmlWriter(XmlWriter.Create(new StringWriter(generated), xmlSettings), xsc))\r\n            {\r\n                XamlType list = xsc.GetXamlType(typeof(List<Dictionary<int, HashSet<List<BigContainer>>>>));\r\n                var ns1 = $\"clr-namespace:System.Collections.Generic;assembly={hashSetAssemblyName}\";\r\n                var ns2 = \"clr-namespace:Test.Elements;assembly=XamlTestClasses\";\r\n                var ns3 = \"http://schemas.microsoft.com/winfx/2006/xaml\";\r\n                writer.WriteNamespace(new NamespaceDeclaration(ns1, \"a\"));\r\n                writer.WriteNamespace(new NamespaceDeclaration(ns2, \"b\"));\r\n                writer.WriteNamespace(new NamespaceDeclaration(ns3, \"c\"));\r\n                writer.WriteStartObject(list);\r\n                writer.WriteEndObject();\r\n            }\r\n\r\n\r\n            var expected = @\"<List c:TypeArguments=\"\"Dictionary(c:Int32, a:HashSet(List(b:BigContainer)))\"\" xmlns=\"\"clr-namespace:System.Collections.Generic;assembly={0}\"\" xmlns:a=\"\"clr-namespace:System.Collections.Generic;assembly={1}\"\" xmlns:b=\"\"clr-namespace:Test.Elements;assembly=XamlTestClasses\"\" xmlns:c=\"\"http://schemas.microsoft.com/winfx/2006/xaml\"\" />\";\r\n            expected = string.Format(expected, listAssemblyName, hashSetAssemblyName);\r\n\r\n            Assert.AreEqual(expected, generated.ToString());\r\n\r\n```\r\n\r\n\r\n```xml\r\n--\r\n  |   | - |   | \"<List c:TypeArguments=\\\"Dictionary(c:Int32, a:HashSet(List(b:BigContainer)))\\\" xmlns=\\\"clr-namespace:System.Collections.Generic;assembly=System.Private.CoreLib\\\" xmlns:a=\\\"clr-namespace:System.Collections.Generic;assembly=System.Private.CoreLib\\\" xmlns:b=\\\"clr-namespace:Test.Elements;assembly=XamlTestClasses\\\" xmlns:c=\\\"http://schemas.microsoft.com/winfx/2006/xaml\\\" />\"\\r\\n\r\n1 |   | + |   | {<a:List c:TypeArguments=\"a:Dictionary(c:Int32, a:HashSet(a:List(b:BigContainer)))\" xmlns:a=\"clr-namespace:System.Collections.Generic;assembly=System.Private.CoreLib\" xmlns:b=\"clr-namespace:Test.Elements;assembly=XamlTestClasses\" xmlns:c=\"http://schemas.microsoft.com/winfx/2006/xaml\" />}\r\nCOMMENTS:\r\n```\r\n","Url":"https://github.com/dotnet/wpf/issues/3152","RelatedDescription":"Open issue \"XamlXmlWriter is including the namespace for each element\" (#3152)"},{"Id":"640878927","IsPullRequest":false,"CreatedAt":"2020-06-18T03:29:21","Actor":"ShankarBUS","Number":"3151","RawContent":null,"Title":"Proposal: Add support for BorderMode in BlurEffect","State":"open","Body":"## Summary\r\nThe proposal is to add support for **`BorderMode`** in **BlurEffect**\r\n\r\nThis will enable blur effect to be more visually comforting and will enable UI designers to be even more creative.\r\n\r\n## Goal\r\nThe goal is to add an enum for **`BorderModes`** and a property called **`BorderMode`** in **BlurEffect** class (and internal work that I'm not aware of).\r\n\r\n## Rationale\r\nCurrently, **BlurEffect** pads extra pixels. Which is good for **UIElements** that are neither clipped nor stretched to fit parent.\r\nBut will look ugly when applied to **UIElements** which are either clipped or stretched to fit parent container\r\nSee this SO question : [Gaussian blur leads to white frame around image](https://stackoverflow.com/questions/6236054/gaussian-blur-leads-to-white-frame-around-image) to get an insight of my proposal.\r\n\r\n**In the image below the element is blurred and has extra padded pixels. It's ok in this case**\r\n\r\n![image](https://user-images.githubusercontent.com/63704247/84972230-0e0b5800-b13c-11ea-8fe3-cf1bcc1a9555.png)\r\n\r\n**But for cases like this where the element is either stretched to fill or clipped, it will have ugly transparent edges**\r\n\r\n![](https://i.stack.imgur.com/vDqBC.png)\r\n\r\nSo having an option to not pad extra pixel will be helpful in many cases\r\n\r\nUWP (Win2D?) has the said property see [GaussianBlurEffect.BorderMode](https://microsoft.github.io/Win2D/html/P_Microsoft_Graphics_Canvas_Effects_GaussianBlurEffect_BorderMode.htm)\r\n and also [Direct2D/GaussianBlur.BorderMode](https://docs.microsoft.com/en-us/windows/win32/direct2d/gaussian-blur#border-modes)\r\n\r\n## Proposed API\r\n\r\nThe same API found in Win2D's GaussianBlurEffect can be used.\r\n\r\n```cs\r\n// Enumeration type that specifies how to process pixels that lie outside the input image.\r\npublic enum EffectBorderMode\r\n{\r\n    // Pixels outside the input image are treated as transparent black, resulting in a soft edge after processing.\r\n    Soft = 0, // Default\r\n    // The effect clamps to the size of the input image.\r\n    Hard = 1\r\n}\r\n```\r\n\r\nand in BlurEffect.cs\r\n\r\n```cs\r\n// Gets and sets border mode for edge pixels.\r\npublic EffectBorderMode BorderMode { get; set; }\r\n```\r\n\r\n## Extra Info\r\n_I'm a new comer to WPF and not well introduced to **Open-Source workflow**.\r\nIf I there are any mistakes in this proposal, please correct me._\r\n\r\nOne thing that bothers me is that it's been 13 years since WPF's release and I can't find any issue proposing to change this behavior. **Is it because this can't be implemented or no one asked for it?**\r\n\r\nAt this point I'm too afraid to ask this, since WPF is on maintenance mode and we are forced towards WinUI for a stable future.\r\nI love WPF and people like me will be so pleased if WPF can be improved with much more features.\r\n\r\n## Open questions\r\n- Is this even feasible?\r\n- What will be the difficulty of implementation?\r\n- Is this out of scope?\r\n- Do you devs still plan on adding new features?\r\n- If it the implementation process is feasible, will you consider implementing it?\r\n- Doesn't WPF and UWP both use DirectX for rendering? Then is it possible?","Url":"https://github.com/dotnet/wpf/issues/3151","RelatedDescription":"Open issue \"Proposal: Add support for BorderMode in BlurEffect\" (#3151)"},{"Id":"640434842","IsPullRequest":true,"CreatedAt":"2020-06-17T13:37:19","Actor":"dotnet-maestro[bot]","Number":"3150","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200617.2\r\n- **Date Produced**: 6/17/2020 1:05 PM\r\n- **Commit**: f56b2b1f6d7c186fd8badcc555f88032938468b7\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20316.2 to 5.0.0-preview.7.20317.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3150","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3150)"},{"Id":"639830811","IsPullRequest":false,"CreatedAt":"2020-06-16T17:01:20","Actor":"taoyue","Number":"3149","RawContent":null,"Title":"OriginalSource is wrong when command is invoked on a ListBoxItem by key gesture","State":"open","Body":"* .NET Core Version: 3.1\r\n* Windows version: Windows 10 version 2004\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\nProblem description\r\n===================\r\n\r\nWhen a ``ContextMenu`` is attached to a ``ListBoxItem``, commands can be invoked through the context menu itself or by using a key gesture.  Depending on how the command is invoked, the ``Executed`` event handler gets different values for ``ExecutedRoutedEventArgs.OriginalSource``:\r\n\r\n **Actual behavior:**\r\n* When the command is invoked through the context menu, ``OriginalSource`` is the ``ListBoxItem``.\r\n* When the command is invoked by the key gesture, ``OriginalSource`` is the ``ListBox`` instead of the ``ListBoxItem``.  Since the ``Source`` and the ``sender`` are also the ``ListBox``, the event handler never gets the ``ListBoxItem`` that the command was invoked on.\r\n\r\n **Expected behavior:**\r\n* No matter how the command is invoked, ``OriginalSource`` should always be the ``ListBoxItem``.\r\n\r\nMinimal repro\r\n=============\r\n\r\nXAML:\r\n```XAML\r\n<ListBox Name=\"CommandsListBox\" ItemsSource=\"{Binding Path=., Mode=OneWay}\">\r\n    <ListBox.CommandBindings>\r\n        <CommandBinding Command=\"ApplicationCommands.Properties\" Executed=\"Properties_Executed\"/>\r\n    </ListBox.CommandBindings>\r\n    <ListBox.Resources>\r\n        <ContextMenu x:Key=\"CommandsContextMenu\">\r\n            <MenuItem Header=\"Properties\" Command=\"ApplicationCommands.Properties\"/>\r\n        </ContextMenu>\r\n        <Style TargetType=\"ListBoxItem\">\r\n            <Setter Property=\"ContextMenu\" Value=\"{StaticResource CommandsContextMenu}\"/>\r\n        </Style>\r\n    </ListBox.Resources>\r\n</ListBox>\r\n```\r\n\r\nCode-behind:\r\n```C#\r\npublic MainWindow()\r\n{\r\n    InitializeComponent();\r\n\r\n    var items = new ObservableCollection<string> { \"Item 1\", \"Item 2\", \"Item 3\" };\r\n    CommandsListBox.DataContext = items;\r\n}\r\n\r\nprivate void Properties_Executed(object sender, ExecutedRoutedEventArgs e)\r\n{\r\n    Debug.WriteLine($\"sender = {sender.GetType().Name}, e.Source = {e.Source.GetType().Name}, e.OriginalSource = {e.OriginalSource.GetType().Name}\");\r\n}\r\n```\r\n\r\nTry both invocation methods to see the different values of ``e.OriginalSource``:\r\n\r\n  1. Right-click a list box item, and select Properties from the context menu.\r\n  2. Select a list box item, and press the F4 key.\r\n\r\nThe ``Properties_Executed`` event handler will write the types to the debug output:\r\n\r\n```\r\nsender = ListBox, e.Source = ListBox, e.OriginalSource = ListBoxItem\r\nsender = ListBox, e.Source = ListBox, e.OriginalSource = ListBox\r\n```\r\n\r\nCause of bug\r\n============\r\n\r\nWhen an accelerator key is pressed, the ``KeyEventArgs.OriginalSource`` actually starts out with the correct value of the ``ListBoxItem``.  However, this is lost because ``CommandManager.ExecuteCommand`` throws away ``inputEventArgs`` when it calls ``RoutedCommand.ExecuteCore``.\r\n\r\nWhen ``RoutedCommand.ExecuteImpl`` creates the ``ExecutedRoutedEventArgs``, it uses ``target`` as the source of the event.  But the ``target`` parameter comes from ``CommandManager.TranslateInput``, which sets it to the ``ListBox``.\r\n\r\nCommandManager.cs:\r\n```C#\r\n459  // We currently do not support declaring the element with focus as the target\r\n460  // element by setting target == null.  Instead, we interpret a null target to indicate\r\n461  // the element that we are routing the event through, e.g. the targetElement parameter.\r\n462  if (target == null)\r\n463  {\r\n464      target = targetElement;\r\n465  }\r\n```\r\n\r\nThe comment implies that this is a TODO that was never done.  It also says that the correct behavior is to set the focused element (``ListBoxItem``) as the target.  This is what the context menu is already doing.\r\n\r\nContext menu codepath\r\n=====================\r\n\r\nWhen the user selects the context menu item, ``RoutedCommand.ExecuteImpl`` is called for the first time with the ``MenuItem`` as the ``target``.  But the developer can't do anything with a ``MenuItem``, so WPF takes additional steps to find a more semantically useful element.  ``CommandManager.OnExecuted`` transfers the event to the parent scope's focused element, which is the ``ListBoxItem``.\r\n\r\nCommandManager.cs:\r\n```C#\r\n556  // This element is a focus scope.\r\n557  // Try to transfer the event to its parent focus scope's focused element.\r\n558  IInputElement focusedElement = GetParentScopeFocusedElement(d);\r\n559  if (focusedElement != null)\r\n560  {\r\n561      TransferEvent(focusedElement, e);\r\n562  }\r\n```","Url":"https://github.com/dotnet/wpf/issues/3149","RelatedDescription":"Open issue \"OriginalSource is wrong when command is invoked on a ListBoxItem by key gesture\" (#3149)"},{"Id":"639650102","IsPullRequest":true,"CreatedAt":"2020-06-16T13:32:27","Actor":"dotnet-maestro[bot]","Number":"3148","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200616.2\r\n- **Date Produced**: 6/16/2020 12:59 PM\r\n- **Commit**: 0e79517a9c55617df6db21ecc5d455d5cbea83dd\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20315.2 to 5.0.0-preview.7.20316.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3148","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3148)"},{"Id":"639366916","IsPullRequest":false,"CreatedAt":"2020-06-16T04:48:35","Actor":"lindexi","Number":"3147","RawContent":null,"Title":"The main thread of the WPF application that starts automatically at boot will forever wait for the touch thread to execute","State":"open","Body":"* .NET Core Version:3.1.300\r\n* Windows version: 10.0.18362\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\n **Problem description:**\r\n\r\nThe WPF application does not show the main window.\r\n\r\nBecause the main thread is waiting for the logic execution of the Stylus Input thread.\r\n\r\n![](http://image.acmx.xyz/lindexi%2F20206161131494577.jpg)\r\n\r\nThe main thread execution waiting method is [PresentationCore.dll! System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() ](https://github.com/dotnet/wpf/blob/08dc7bcdecb27ab25d279d0b9d05f35393852ae9/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThreadWorker.cs#L574)\r\n\r\nhttps://github.com/dotnet/wpf/blob/08dc7bcdecb27ab25d279d0b9d05f35393852ae9/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThreadWorker.cs#L574-L592\r\n\r\n![](http://image.acmx.xyz/lindexi%2F2020616114732306.jpg)\r\n\r\n![](http://image.acmx.xyz/lindexi%2F20206161149181309.jpg)\r\n\r\nWhat is the Stylus Input thread doing at this time? It is waiting for touch input\r\n\r\n![](http://image.acmx.xyz/lindexi%2F20206161154445424.jpg)\r\n\r\nSo the main thread cannot wait for the execution of the Stylus Input thread to complete, the main thread will always wait\r\n\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n\r\nThe main thread callstack \r\n\r\n\r\n```\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tPresentationCore.dll!MS.Win32.Penimc.UnsafeNativeMethods.CreatePimcManager() (IL=0x0022, Native=0x6C422318+0x53)\r\n \tPresentationCore.dll!MS.Win32.Penimc.UnsafeNativeMethods.UnsafeNativeMethods() (IL=prolog, Native=0x6C422288+0x21)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.PenThreadWorker() (IL≈0x004C, Native=0x6C42080C+0xCB)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadPool.GetPenThreadForPenContextHelper(System.Windows.Input.PenContext penContext) (IL≈0x005B, Native=0x6C42067C+0xE5)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadPool.GetPenThreadForPenContext(System.Windows.Input.PenContext penContext) (IL=epilog, Native=0x6C4205A8+0x84)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL≈0x0009, Native=0x6C439AB8+0x2D)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.RegisterHwndForInput(System.Windows.Input.InputManager inputManager, System.Windows.PresentationSource inputSource) (IL≈0x0032, Native=0x6BF5DD50+0x8F)\r\n \tPresentationCore.dll!System.Windows.Interop.HwndStylusInputProvider.HwndStylusInputProvider(System.Windows.Interop.HwndSource source) (IL=0x005A, Native=0x6BF5DBCC+0xF8)\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.Initialize(System.Windows.Interop.HwndSourceParameters parameters) (IL=0x0253, Native=0x6BF5C4C8+0x433)\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindow(bool duringShow) (IL=0x0082, Native=0x6AC1C0F4+0x1E0)\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindowDuringShow() (IL=epilog, Native=0x6ACBB474+0xF)\r\n \tPresentationFramework.dll!System.Windows.Window.SafeCreateWindowDuringShow() (IL=epilog, Native=0x6AC1D7B4+0x41)\r\n \tPresentationFramework.dll!System.Windows.Window.ShowHelper(object booleanBox) (IL=0x003B, Native=0x6AC1D644+0x78)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl() (IL≈0x007A, Native=0x6C9DE6D0+0xD2)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state) (IL=epilog, Native=0x6C9DE690+0x3C)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL≈0x0079, Native=0x6EC82DC0+0xE5)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL=epilog, Native=0x6EC82DA0+0x16)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state) (IL=epilog, Native=0x6EC82D30+0x41)\r\n \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext executionContext, System.Threading.ContextCallback callback, object state) (IL=epilog, Native=0x6C9DE480+0x63)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke() (IL=0x0020, Native=0x6C9DE340+0x4E)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue() (IL=0x00F6, Native=0x6C9DA870+0x165)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL=0x0090, Native=0x6C9DAB70+0x5A)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \t[ToNative]\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame) (IL≈0x0040, Native=0x6C9D84CC+0xB1)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame) (IL=epilog, Native=0x6C9D8124+0x4A)\r\n \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore) (IL=0x0024, Native=0x6ABF4E70+0x5A)\r\n \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window) (IL=0x00EE, Native=0x6ABF4CEC+0x74)\r\n \tPresentationFramework.dll!System.Windows.Application.Run(System.Windows.Window window) (IL=epilog, Native=0x6ABF4ADC+0x2B)\r\n \tPresentationFramework.dll!System.Windows.Application.Run() (IL=epilog, Native=0x6ABF46C8+0x1C)\r\n \tLindexi.WPF.exe!Lindexi.Program.Initialize() (IL≈0x000E, Native=0x0592A0A0+0x54)\r\n \tLindexi.WPF.exe!Lindexi.Program.Main(string[] args) (IL=0x001C, Native=0x00DF0448+0x42)\r\n```\r\n\r\nThe Stylus Input thread callstack \r\n \r\n```\r\n>\tPresentationCore.dll!System.Windows.Input.PenThreadWorker.ThreadProc() (IL≈0x00AF, Native=0x6C421E44+0x176)\r\n \tmscorlib.dll!System.Threading.ThreadHelper.ThreadStart_Context(object state) (IL=epilog, Native=0x6EC56060+0x9D)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL≈0x0079, Native=0x6EC82DC0+0xE5)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL=epilog, Native=0x6EC82DA0+0x16)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state) (IL=epilog, Native=0x6EC82D30+0x41)\r\n \tmscorlib.dll!System.Threading.ThreadHelper.ThreadStart() (IL=epilog, Native=0x6EC56014+0x44)\r\n```\r\n\r\n\r\n **Expected behavior:**\r\n\r\nThe main thread will not wait for the Stylus Input thread all the time\r\n \r\n **Minimal repro:**\r\n\r\nThe empty WPF application and set the WPF application starts automatically at boot. After the device is started, the touch screen HID device will be connected.\r\n\r\nI tested it hundreds of times and it appeared once. This seems to be part of the WPF touch thread processing problem.\r\n\r\nRelated issues:\r\n\r\nhttps://github.com/dotnet/wpf/issues/78\r\n\r\nhttps://github.com/dotnet/wpf/issues/928\r\n\r\nhttps://github.com/Microsoft/dotnet/issues/480\r\n\r\nhttps://github.com/dotnet/wpf/issues/2054\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/3147","RelatedDescription":"Open issue \"The main thread of the WPF application that starts automatically at boot will forever wait for the touch thread to execute\" (#3147)"},{"Id":"639010396","IsPullRequest":false,"CreatedAt":"2020-06-15T17:14:05","Actor":"vsfeedback","Number":"3146","RawContent":null,"Title":"Crashed during debugging","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/967201/crashed-during-debugging.html)._\n\n---\nI left the debugger running a long-running process.  I was working from home. I returned to my remote machine and remote desktop was frozen. I restarted remote desktop. When the remote desktop came up, visual studio crashed. I don't know what state the debugger was in; possibly at a breakpoint.\n\nI had ProcDump installed as the post-mortem debugger; the crash dump from ProcDump is attached.\n\n---\n### Original Comments\n\n#### Visual Studio Feedback System on 3/29/2020, 08:10 PM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/3146","RelatedDescription":"Open issue \"Crashed during debugging\" (#3146)"},{"Id":"638895711","IsPullRequest":false,"CreatedAt":"2020-06-15T14:23:37","Actor":"lindexi","Number":"3145","RawContent":null,"Title":"WPF can not receive the touch message when set WS_EX_TRANSPARENT to window","State":"open","Body":"* .NET Core Version: 3.1.300\r\n* Windows version: 10.0.18362\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\n\r\nWPF can not receive the touch message when set WS_EX_TRANSPARENT to window\r\n\r\nWe can create an empty WPF application, and then we can output message when we receive the mouse down and touch down event\r\n\r\nBut when we set the WS_EX_TRANSPARENT property to the window, that we can find that we can only receive the mouse event and can not receive the touch event\r\n\r\n```csharp\r\n        private void MainWindow_Loaded(object sender, RoutedEventArgs e)\r\n        {\r\n            IntPtr hwnd = new WindowInteropHelper(this).Handle;\r\n            var extendedStyle = GetWindowLong(hwnd, GWL_EXSTYLE);\r\n            SetWindowLong(hwnd, GWL_EXSTYLE, extendedStyle | WS_EX_TRANSPARENT);\r\n        }\r\n```\r\n \r\n **Actual behavior:**\r\n\r\nWe can not receive the touch event and we only receive the mouse event\r\n \r\n **Expected behavior:**\r\n\r\nWe can receive the touch event just like the mouse behavior\r\n \r\n **Minimal repro:**\r\n\r\nhttps://github.com/dotnet-campus/wpf-issues/tree/master/CanNotReceiveTouchMessageWS_EX_TRANSPARENT","Url":"https://github.com/dotnet/wpf/issues/3145","RelatedDescription":"Open issue \"WPF can not receive the touch message when set WS_EX_TRANSPARENT to window\" (#3145)"},{"Id":"638849876","IsPullRequest":true,"CreatedAt":"2020-06-15T13:37:32","Actor":"dotnet-maestro[bot]","Number":"3144","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200615.2\r\n- **Date Produced**: 6/15/2020 1:04 PM\r\n- **Commit**: 516f44ef4edadb3991c3fe7b820de0febff40d7f\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20314.2 to 5.0.0-preview.7.20315.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3144","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3144)"},{"Id":"638718572","IsPullRequest":false,"CreatedAt":"2020-06-15T10:03:25","Actor":"prranja23","Number":"3143","RawContent":null,"Title":".NET applications are crashing after the MCF application sets the FontWeight and FontType","State":"open","Body":".NET applications are crashing after the MCF application sets the FontWeight and FontType using the below code :\r\nSystemParamerterInfo(SPI_SETNONCLIENTMETRICS,0,&ncm,0)\r\n\r\n**Workaround :**\r\nThe simple workaround is for the C++ application to ensure it is setting the font weight between 1 and 999 prior to calling SystemParametersInfo(SPI_SETNONCLIENTMETRICS). Use FW_NORMAL (400) instead of FW_DONTCARE (0). The C++ application should also be at least system DPI aware if the application will be running on systems with the DPI scale >= 150%.\r\n\r\n**Repro Code :**\r\n1. We need to first run the C++ application and then try running the WPF application to reproduce the issue.\r\n2. We tried creating a simple WPF application, using the following XAML for the main window:\r\n```\r\n<Window x:Class=\"WpfApp1.MainWindow\"\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n        xmlns:local=\"clr-namespace:WpfApp1\"\r\n        mc:Ignorable=\"d\"\r\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\r\n        <Grid>\r\n            <RichTextBox>\r\n                <FlowDocument>\r\n                    <Table>\r\n                        <TableRowGroup>\r\n                            <TableRow>\r\n                                <TableCell>\r\n                                    <Paragraph>\r\n                                        <Run>Paragraph in a Table Cell.</Run>\r\n                                    </Paragraph>\r\n                                </TableCell>\r\n                            </TableRow>\r\n                        </TableRowGroup>\r\n                    </Table>\r\n                </FlowDocument>\r\n            </RichTextBox>\r\n        </Grid>\r\n    </Window>\r\n```\r\n3. We then created a small C++ console application that does the following:\r\n```\r\nint wmain()\r\n{\r\n    NONCLIENTMETRICSW ncm = {};\r\n    ncm.cbSize = sizeof(NONCLIENTMETRICSW);\r\n \r\n    BOOL fResult = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);\r\n    if (fResult)\r\n    {\r\n        LONG lfWeightPrev = ncm.lfMessageFont.lfWeight;\r\n        ncm.lfMessageFont.lfWeight = 0; // FW_DONTCARE\r\n \r\n        fResult = SystemParametersInfo(SPI_SETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);\r\n        if (fResult)\r\n        {\r\n            _getwch();\r\n            ncm.lfMessageFont.lfWeight = lfWeightPrev;\r\n            fResult = SystemParametersInfo(SPI_SETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);\r\n        }\r\n    }\r\n    return GetLastError();\r\n}\r\n```\r\n\r\n 4. We are able to reproduce the crash when running the WPF application. \r\n\r\n**Expected Results :**\r\n1. The WPF application should work fine.\r\n\r\n**Actual Results :**\r\n1. The WPF application crashes with below exception :\r\n0:000> !PrintException /d 02bc06c0\r\nException object: 02bc06c0\r\nException type:   System.ArgumentOutOfRangeException\r\nMessage:          The parameter value must be between '1' and '999'.\r\nInnerException:   <none>\r\nStackTrace (generated):\r\n    SP       IP       Function\r\n    00AFDE78 68CD472B PresentationCore_ni!System.Windows.FontWeight.FromOpenTypeWeight(Int32)+0x7d272b\r\n    00AFDE8C 5615BE6A PresentationFramework_ni!System.Windows.Documents.TextElement..cctor()+0x192\r\n","Url":"https://github.com/dotnet/wpf/issues/3143","RelatedDescription":"Open issue \".NET applications are crashing after the MCF application sets the FontWeight and FontType\" (#3143)"},{"Id":"638436011","IsPullRequest":false,"CreatedAt":"2020-06-14T21:41:25","Actor":"NickeManarin","Number":"3142","RawContent":null,"Title":"Not enough quota when opening Window","State":"open","Body":"After updating my WPF app from 4.6.1 to 4.8, users started getting this exception (multiple times in a row) when opening windows:\r\n\r\n```\r\n• Message - \r\n    Not enough quota is available to process this command\r\n• Type - \r\n    System.ComponentModel.Win32Exception\r\n• Source - \r\n    PresentationCore\r\n• TargetSite - \r\n    Void UpdateWindowSettings(Boolean, System.Nullable`1[System.Windows.Media.Composition.DUCE+ChannelSet])\r\n• StackTrace - \r\n   at System.Windows.Interop.HwndTarget.UpdateWindowSettings(Boolean enableRenderTarget, Nullable`1 channelSet)\r\n   at System.Windows.Interop.HwndTarget.UpdateWindowPos(IntPtr lParam)\r\n   at System.Windows.Interop.HwndTarget.HandleMessage(WindowMessage msg, IntPtr wparam, IntPtr lparam)\r\n   at System.Windows.Interop.HwndSource.HwndTargetFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean& handled)\r\n   at MS.Win32.HwndWrapper.WndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean& handled)\r\n   at MS.Win32.HwndSubclass.DispatcherCallbackOperation(Object o)\r\n   at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs)\r\n   at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Int32 numArgs, Delegate catchHandler)\r\n```\r\nUnfortunately, I could not get this exception on my machine, so I can't really understand what's happening.\r\n\r\nI already tried setting `HandleDispatcherRequestProcessingFailureOptions.Reset`, but people are still reporting crashes to me.\r\n\r\nWhat could possibly be happening? Is there any way to fix this or maybe set an workaround?","Url":"https://github.com/dotnet/wpf/issues/3142","RelatedDescription":"Open issue \"Not enough quota when opening Window\" (#3142)"},{"Id":"638348759","IsPullRequest":true,"CreatedAt":"2020-06-14T13:14:53","Actor":"dotnet-maestro[bot]","Number":"3141","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200614.2\r\n- **Date Produced**: 6/14/2020 12:58 PM\r\n- **Commit**: b5107a331887d766dffc0ad0b86cf462da86c44d\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20313.2 to 5.0.0-preview.7.20314.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3141","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3141)"},{"Id":"638344051","IsPullRequest":false,"CreatedAt":"2020-06-14T12:36:25","Actor":"ice1e0","Number":"3140","RawContent":null,"Title":"SelectedItems property on DataGrid","State":"open","Body":"The DataGrid has a property SelectedItems property which can not be used in WPF like 'SelectedItem' because it has no dependency property. I would love to see this be added to WPF.\r\n\r\nSee as well: https://stackoverflow.com/questions/9880589/bind-to-selecteditems-from-datagrid-or-listbox-in-mvvm\r\nHere the DataGrid is used with SelectionMode \"Extended\" and using SelectionUnit=\"FullRow\" --> with this configuration I think there should be no issue adding this functionality.\r\n\r\nHere a raw template for a simple extension (only supporting to read the 'SelectedItems' property):\r\n\r\n``` c#\r\npublic class CustomDataGrid : DataGrid\r\n{\r\n        public static readonly DependencyProperty SelectedItemsProperty = DependencyProperty.Register(nameof(SelectedItems), typeof(IList), typeof(CustomDataGrid), new PropertyMetadata(default(IList), OnSelectedItemsPropertyChanged));\r\n\r\n        protected override void OnSelectionChanged(SelectionChangedEventArgs e)\r\n        {\r\n            base.OnSelectionChanged(e);\r\n            SetValue(SelectedItemsProperty, base.SelectedItems);\r\n        }\r\n\r\n        public new IList SelectedItems\r\n        {\r\n            get => (IList)GetValue(SelectedItemsProperty);\r\n            set => throw new Exception(\"This property is read-only. To bind to it you must use 'Mode=OneWayToSource'.\");\r\n        }\r\n\r\n        private static void OnSelectedItemsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\r\n        {\r\n            ((CustomDataGrid)d).OnSelectedItemsChanged((IList)e.OldValue, (IList)e.NewValue);\r\n        }\r\n\r\n        protected virtual void OnSelectedItemsChanged(IList oldSelectedItems, IList newSelectedItems)\r\n        {\r\n        }\r\n}\r\n```","Url":"https://github.com/dotnet/wpf/issues/3140","RelatedDescription":"Open issue \"SelectedItems property on DataGrid\" (#3140)"},{"Id":"638308276","IsPullRequest":true,"CreatedAt":"2020-06-14T08:28:14","Actor":"sdcarterchen","Number":"3139","RawContent":null,"Title":"111","State":"open","Body":"","Url":"https://github.com/dotnet/wpf/pull/3139","RelatedDescription":"Open PR \"111\" (#3139)"},{"Id":"638234683","IsPullRequest":false,"CreatedAt":"2020-06-13T21:14:26","Actor":"miloush","Number":"3138","RawContent":null,"Title":"No permission to delete temporary files leads to crash on load","State":"open","Body":"* .NET Core Version: 3.1.400-preview-015151\r\n* Windows version: 10.0.19619.1000\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\n **Problem description:**\r\n\r\nWhen WPF app does not have delete permission to the temp directory, loading XAML with Cursor property set crashes the app on load.\r\n \r\n **Actual behavior:** \r\n\r\n```\r\nSystem.Windows.Markup.XamlParseException: Provide value on 'System.Windows.Baml2006.TypeConverterMarkupExtension' threw an exception. ---> System.UnauthorizedAccessException: Access to the path 'C:\\Users\\User\\AppData\\Local\\Temp\\WPF\\o4fqaecx.33n' is denied.\r\n   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)\r\n   at System.IO.File.InternalDelete(String path, Boolean checkHost)\r\n   at System.IO.FileHelper.DeleteTemporaryFile(String filePath)\r\n   at System.Windows.Input.Cursor.LoadFromStream(Stream cursorStream)\r\n   at System.Windows.Input.CursorConverter.ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, Object value)\r\n   at MS.Internal.Xaml.Runtime.ClrObjectRuntime.CallProvideValue(MarkupExtension me, IServiceProvider serviceProvider)\r\n   --- End of inner exception stack trace ---\r\n   at System.Windows.Markup.XamlReader.RewrapException(Exception e, IXamlLineInfo lineInfo, Uri baseUri)\r\n   at System.Windows.Markup.WpfXamlLoader.Load(XamlReader xamlReader, IXamlObjectWriterFactory writerFactory, Boolean skipJournaledProperties, Object rootObject, XamlObjectWriterSettings settings, Uri baseUri)\r\n   at System.Windows.ResourceDictionary.CreateObject(KeyRecord key)\r\n   at System.Windows.ResourceDictionary.OnGettingValue(Object key, Object& value, Boolean& canCache)\r\n   at System.Windows.ResourceDictionary.OnGettingValuePrivate(Object key, Object& value, Boolean& canCache)\r\n   at System.Windows.ResourceDictionary.GetValueWithoutLock(Object key, Boolean& canCache)\r\n   at System.Windows.ResourceDictionary.GetValue(Object key, Boolean& canCache)\r\n   at System.Windows.SystemResources.LookupResourceInDictionary(ResourceDictionary dictionary, Object key, Boolean allowDeferredResourceReference, Boolean mustReturnDeferredResourceReference, Boolean& canCache)\r\n   at System.Windows.SystemResources.FindDictionaryResource(Object key, Type typeKey, ResourceKey resourceKey, Boolean isTraceEnabled, Boolean allowDeferredResourceReference, Boolean mustReturnDeferredResourceReference, Boolean& canCache)\r\n   at System.Windows.SystemResources.FindResourceInternal(Object key, Boolean allowDeferredResourceReference, Boolean mustReturnDeferredResourceReference)\r\n   at System.Windows.StyleHelper.GetThemeStyle(FrameworkElement fe, FrameworkContentElement fce)\r\n   at System.Windows.FrameworkElement.UpdateThemeStyleProperty()\r\n   at System.Windows.FrameworkElement.OnInitialized(EventArgs e)\r\n   at System.Windows.FrameworkElement.TryFireInitialized()\r\n   at System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject oldParent)\r\n   at System.Windows.Media.Visual.FireOnVisualParentChanged(DependencyObject oldParent)\r\n   at System.Windows.Media.Visual.AddVisualChild(Visual child)\r\n   at System.Windows.Media.VisualCollection.ConnectChild(Int32 index, Visual value)\r\n   at System.Windows.Media.VisualCollection.Add(Visual visual)\r\n   at System.Windows.Controls.UIElementCollection.AddInternal(UIElement element)\r\n   at System.Windows.Controls.Panel.GenerateChildren()\r\n   at System.Windows.Controls.Panel.EnsureGenerator()\r\n   at System.Windows.Controls.Panel.get_InternalChildren()\r\n   at System.Windows.Controls.StackPanel.StackMeasureHelper(IStackMeasure measureElement, IStackMeasureScrollData scrollData, Size constraint)\r\n ...\r\n   at System.Windows.UIElement.Measure(Size availableSize)\r\n   at System.Windows.Interop.HwndSource.SetLayoutSize()\r\n   at System.Windows.Interop.HwndSource.set_RootVisualInternal(Visual value)\r\n   at System.Windows.Window.SetRootVisual()\r\n   at System.Windows.Window.SetRootVisualAndUpdateSTC()\r\n   at System.Windows.Window.SetupInitialState(Double requestedTop, Double requestedLeft, Double requestedWidth, Double requestedHeight)\r\n   at System.Windows.Window.CreateSourceWindow(Boolean duringShow)\r\n   at System.Windows.Window.ShowHelper(Object booleanBox)\r\n```\r\n \r\n **Expected behavior:**\r\n\r\nLeave the file behind with no crash, like in the case when it is being used by another process, i.e. `System.IO.FileHelper.DeleteTemporaryFile` should not only catch `IOException` but also `UnauthorizedAccessException`.\r\n","Url":"https://github.com/dotnet/wpf/issues/3138","RelatedDescription":"Open issue \"No permission to delete temporary files leads to crash on load\" (#3138)"}],"ResultType":"GitHubIssue"}},"RunOn":"2020-06-24T05:30:50.5788853Z","RunDurationInMilliseconds":634}