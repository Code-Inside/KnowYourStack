{"Data":{"GitHub":{"Issues":[{"Id":"675390923","IsPullRequest":true,"CreatedAt":"2020-08-08T01:27:02","Actor":"GrabYourPitchforks","Number":"3318","RawContent":null,"Title":"Call SHA1.HashData static helper instead of instantiating SHA1CSP","State":"open","Body":"We're trying to minimize usage of the `*CryptoServiceProvider` and `*Managed` types through our code bases so that we can eventually write analyzers to recommend moving off of them. See https://github.com/dotnet/runtime/issues/40169 for some related discussion w.r.t. `RNGCryptoServiceProvider`.\r\n\r\nThis PR changes the call site to use the static one-shot helper method so that you don't need to instantiate a hasher object. The `HashData` static method uses the best available implementation for the current OS.","Url":"https://github.com/dotnet/wpf/pull/3318","RelatedDescription":"Open PR \"Call SHA1.HashData static helper instead of instantiating SHA1CSP\" (#3318)"},{"Id":"675171067","IsPullRequest":false,"CreatedAt":"2020-08-07T17:43:36","Actor":"vatsan-madhavan","Number":"3317","RawContent":null,"Title":"Warning C4244 - implicit double -> float conversion with possible data-loss in BaseMatrix.cpp","State":"open","Body":"Here is the warning: \r\n\r\n> src\\Microsoft.DotNet.Wpf\\src\\WpfGfx\\core\\common\\BaseMatrix.cpp(1034,57): warning C4244: 'argument':\r\nconversion from 'double' to 'float', possible loss of data\r\n\r\nhttps://github.com/dotnet/wpf/blob/49cc5c6dcf0ead39a08b1917eeb1d472bcfbe739/src/Microsoft.DotNet.Wpf/src/WpfGfx/core/common/BaseMatrix.cpp#L1034\r\n\r\n`CFloatFpu::Ceiling` takes a `float` param, but `std::pow` returns a `double`, which leads to the warning: \r\n\r\nhttps://github.com/dotnet/wpf/blob/49cc5c6dcf0ead39a08b1917eeb1d472bcfbe739/src/Microsoft.DotNet.Wpf/src/WpfGfx/common/shared/real.h#L628-L630\r\n\r\n\r\n`std::pow` is defined to return `double` since C++11 ([reference](https://en.cppreference.com/w/cpp/numeric/math/pow))\r\n\r\n\r\n>```C++\r\n>Promoted    pow ( Arithmetic1 base, Arithmetic2 exp ); | (7) | (since C++11)\r\n>```\r\n>7) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by 1-3). If any argument has integral type, it is cast to `double`. If any argument is `long double`, then the return type Promoted is also `long double`, otherwise the return type is always `double`.\r\n\r\n-- \r\n\r\nThe result of `std::pow` should be safe to `static_cast` to `REAL` since `rScaleThreshold <= 1` (this is assert'ed early in the method). \r\n\r\n-- \r\n\r\nWhy isn't this warning seen in CI/dev builds using build.cmd today? I can see it easily when building wpfgfx.vcxproj with `msbuild` directly. ","Url":"https://github.com/dotnet/wpf/issues/3317","RelatedDescription":"Open issue \"Warning C4244 - implicit double -> float conversion with possible data-loss in BaseMatrix.cpp\" (#3317)"},{"Id":"674991435","IsPullRequest":true,"CreatedAt":"2020-08-07T13:05:12","Actor":"dotnet-maestro[bot]","Number":"3316","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200807.2\r\n- **Date Produced**: 8/7/2020 12:37 PM\r\n- **Commit**: faaaf57a2500812161247f3b0a528ff77a53e91e\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20406.4 to 5.0.0-preview.8.20407.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3316","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3316)"},{"Id":"670253657","IsPullRequest":false,"CreatedAt":"2020-08-07T11:25:20","Actor":"NotThatBen","Number":"3297","RawContent":null,"Title":"Wrong behaviour of DataGridCellInfo Equality operator.","State":"closed","Body":"* .NET Core Version: (e.g. 3.0 Preview1, or daily build number, use `dotnet --info`) - **Any**\r\n* Windows version: (`winver`) - **Win7**\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes/No - **Yes**\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? If yes, please file the issue via the instructions [here](https://docs.microsoft.com/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019). - **No**\r\n* Security issues and bugs should be reported privately, learn more via our [responsible disclosure guidelines](https://github.com/dotnet/wpf/blob/master/README.md#reporting-security-issues-and-security-bugs). - **Not Related**\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\nDataGridCellInfo equality operator returns wrong result when virtualization enabled.\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nEquality operator returns _false_ instead _true_ on the same cell. Disabling _RowVirtualization_ eliminate this issue.\r\n \r\n **Expected behavior:**\r\nObvious...\r\n \r\n **Minimal repro:**\r\n_DataGrid_ with _RowVirtualization_ enabled and enough items in source collection to run in virtualization. Create _DataGridCellInfo_ object for any cell, keep it, then scroll to hide that cell (virtualize). Then create another _CellInfo_ for any visible cell. Then scroll back to first cell, create _CellInfo_ again and make \"==\"-ing. \r\n \r\n","Url":"https://github.com/dotnet/wpf/issues/3297","RelatedDescription":"Closed issue \"Wrong behaviour of DataGridCellInfo Equality operator.\" (#3297)"},{"Id":"674884264","IsPullRequest":false,"CreatedAt":"2020-08-07T09:20:10","Actor":"Nukepayload2","Number":"3315","RawContent":null,"Title":"ExecutionEngineException when calling TextBox.Focus in TextInputStart","State":"open","Body":"* .NET Core Version: 5.0.0-preview.7.20364.11\r\n* Windows version: \r\nBuild 10.0.19041.388\r\nWindows feature experience pack 120.2202.130.0\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? \r\nNo\r\n* Security issues and bugs should be reported privately, learn more via our [responsible disclosure guidelines](https://github.com/dotnet/wpf/blob/master/README.md#reporting-security-issues-and-security-bugs).\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\nWhen using Microsoft Japanese IME, `TextBox.Focus` throws `ExecutionEngineException` when calling it in a `TextInputStart` attached event handler.\r\n \r\n **Actual behavior:** \r\n```\r\nSystem.ExecutionEngineException\r\nHResult is 80131506\r\n\r\n>\tWindowsBase.dll!MS.Internal.Invariant.FailFast(string message, string detailMessage)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.VerifyTextStoreConsistency()\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.GrantLock()\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.GrantLockWorker(MS.Win32.UnsafeNativeMethods.LockFlags flags)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.RequestLock(MS.Win32.UnsafeNativeMethods.LockFlags flags, out int hrSession)\tUnknown\r\n \t[Native to Managed Transition]\t\r\n \t[Managed to Native Transition]\t\r\n \tPresentationFramework.dll!System.Windows.Documents.FrameworkTextComposition.CompleteCurrentComposition(MS.Win32.UnsafeNativeMethods.ITfDocumentMgr documentMgr)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.CompleteComposition()\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextEditor.OnLostKeyboardFocus(object sender, System.Windows.Input.KeyboardFocusChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Controls.Primitives.TextBoxBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs e)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnLostKeyboardFocusThunk(object sender, System.Windows.Input.KeyboardFocusChangedEventArgs e)\tUnknown\r\n \tPresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)\tUnknown\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseTrustedEvent(System.Windows.RoutedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.KeyboardDevice.ChangeFocus(System.Windows.DependencyObject focus, int timestamp)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.KeyboardDevice.TryChangeFocus(System.Windows.DependencyObject newFocus, System.Windows.Input.IKeyboardInputProvider keyboardInputProvider, bool askOld, bool askNew, bool forceToNullIfFailed)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.KeyboardDevice.Focus(System.Windows.DependencyObject focus, bool askOld, bool askNew, bool forceToNullIfFailed)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.KeyboardDevice.Focus(System.Windows.IInputElement element)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.Focus()\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextCompositionEventArgs.InvokeEventHandler(System.Delegate genericHandler, object genericTarget)\tUnknown\r\n \tPresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)\tUnknown\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseTrustedEvent(System.Windows.RoutedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextCompositionManager.UnsafeStartComposition(System.Windows.Input.TextComposition composition)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextCompositionManager.StartComposition(System.Windows.Input.TextComposition composition)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.RaiseCompositionEvents(out int appSelectionAnchorOffset, out int appSelectionMovingOffset)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.HandleCompositionEvents(int previousUndoCount)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.GrantLockWorker(MS.Win32.UnsafeNativeMethods.LockFlags flags)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.RequestLock(MS.Win32.UnsafeNativeMethods.LockFlags flags, out int hrSession)\tUnknown\r\n \t[Native to Managed Transition]\t\r\n \t[Managed to Native Transition]\t\r\n \tPresentationCore.dll!System.Windows.Input.TextServicesContext.Keystroke(int wParam, int lParam, System.Windows.Input.TextServicesContext.KeyOp op)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextServicesManager.TextServicesKeystroke(System.Windows.Input.TextServicesContext context, System.Windows.Input.KeyEventArgs keyArgs, bool test)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextServicesManager.PostProcessInput(object sender, System.Windows.Input.ProcessInputEventArgs e)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputManager.RaiseProcessInputEventHandlers(System.Windows.Input.ProcessInputEventHandler postProcessInput, System.Windows.Input.ProcessInputEventArgs processInputEventArgs)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputProviderSite.ReportInput(System.Windows.Input.InputReport inputReport)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndKeyboardInputProvider.ReportInput(System.IntPtr hwnd, System.Windows.Input.InputMode mode, int timestamp, System.Windows.Input.RawKeyboardActions actions, int scanCode, bool isExtendedKey, bool isSystemKey, int virtualKey)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndKeyboardInputProvider.ProcessKeyAction(ref System.Windows.Interop.MSG msg, ref bool handled)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.CriticalTranslateAccelerator(ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.OnPreprocessMessage(object param)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.OnPreprocessMessageThunk(ref System.Windows.Interop.MSG msg, ref bool handled)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Interop.ComponentDispatcherThread.RaiseThreadMessage(ref System.Windows.Interop.MSG msg)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run()\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Application.Run()\tUnknown\r\n```\r\n \r\n **Expected behavior:**\r\nThe program should not crash.\r\n \r\n **Minimal repro:**\r\n1. Create a new WPF project\r\n```console\r\ndotnet new wpf -lang vb\r\n```\r\n2. Edit `MainWindow.xaml`\r\n```xml\r\n<Window x:Class=\"MainWindow\"\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        Title=\"Windows 10 version 2004 JP IME crash\"\r\n        Height=\"350\" Width=\"400\">\r\n    <StackPanel>\r\n        <TextBlock>1. Use Windows 10 version 2004 (ja-JP)</TextBlock>\r\n        <TextBlock>2. Click this text box ↓</TextBlock>\r\n        <TextBox x:Name=\"Editor1\" />\r\n        <TextBlock>3. Switch to Japanese IME</TextBlock>\r\n        <TextBlock>4. Switch to Hiragana mode</TextBlock>\r\n        <TextBlock>5. Press \"A\"</TextBlock>\r\n\r\n        <TextBlock Margin=\"0,24,0,0\">Don't use this one:</TextBlock>\r\n        <TextBox x:Name=\"Editor2\" HorizontalAlignment=\"Left\"/>\r\n    </StackPanel>\r\n</Window>\r\n```\r\n3. Edit `MainWindow.xaml.vb`\r\n```vbnet\r\nClass MainWindow\r\n    Private Sub MainWindow_Loaded() Handles Me.Loaded\r\n        TextCompositionManager.AddTextInputStartHandler(Editor1, AddressOf Editor2.Focus)\r\n    End Sub\r\nEnd Class\r\n```\r\n4. Run the project\r\n```console\r\ndotnet run\r\n```\r\n5. Click the first text box.\r\n6. Use Japanese IME, Hiragana mode.\r\n7. Press the \"A\" key. \r\n","Url":"https://github.com/dotnet/wpf/issues/3315","RelatedDescription":"Open issue \"ExecutionEngineException when calling TextBox.Focus in TextInputStart\" (#3315)"},{"Id":"673821938","IsPullRequest":true,"CreatedAt":"2020-08-06T20:39:23","Actor":"wli3","Number":"3307","RawContent":null,"Title":"Update to net5.0 template with backcompact","State":"closed","Body":"Port https://github.com/dotnet/wpf/pull/3302","Url":"https://github.com/dotnet/wpf/pull/3307","RelatedDescription":"Closed or merged PR \"Update to net5.0 template with backcompact\" (#3307)"},{"Id":"672403447","IsPullRequest":true,"CreatedAt":"2020-08-06T20:26:51","Actor":"wli3","Number":"3302","RawContent":null,"Title":"Update to net5.0 template with backcompact","State":"closed","Body":"Works for\r\n\r\n```\r\n dotnet new wpf -n wpf1 -f netcoreapp3.1\r\n dotnet new wpf -n wpf2\r\n dotnet new wpf -n wpf3 -f netcoreapp3.1 --target-framework-override net461\r\n dotnet new wpf -n wpf3 -f net5.0 --target-framework-override net6.0\r\n dotnet new wpf -n wpf4 -f net5.0 --target-framework-override net6.0\r\n```","Url":"https://github.com/dotnet/wpf/pull/3302","RelatedDescription":"Closed or merged PR \"Update to net5.0 template with backcompact\" (#3302)"},{"Id":"674323150","IsPullRequest":true,"CreatedAt":"2020-08-06T13:55:49","Actor":"dotnet-maestro[bot]","Number":"3314","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200806.4\r\n- **Date Produced**: 8/6/2020 1:32 PM\r\n- **Commit**: 58b6c51dc1ad5ab1dcf602b138bf06a9566cd2b7\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20406.3 to 5.0.0-preview.8.20406.4\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3314","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3314)"},{"Id":"674303347","IsPullRequest":true,"CreatedAt":"2020-08-06T13:22:29","Actor":"dotnet-maestro[bot]","Number":"3313","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200806.3\r\n- **Date Produced**: 8/6/2020 1:04 PM\r\n- **Commit**: b966f5c54abdc64411c4fe96ab42d7f091ce12bd\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20405.2 to 5.0.0-preview.8.20406.3\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3313","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3313)"},{"Id":"674287447","IsPullRequest":false,"CreatedAt":"2020-08-06T12:48:33","Actor":"53m1k0l0n","Number":"3312","RawContent":null,"Title":"Updating to 16.7 from 16.6.5 causes build issues with WPF project file.","State":"open","Body":"When building a WPF project the following error is shown, this built fine in the last 16.6.5 version that was released.\r\n\r\nC:\\Program Files\\dotnet\\sdk\\3.1.400\\Sdks\\Microsoft.NET.Sdk.WindowsDesktop\\targets\\Microsoft.WinFX.targets 225\r\n\r\nUnknown build error, 'Could not find assembly 'mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e'. Either explicitly load this assembly using a method such as LoadFromAssemblyPath() or use a MetadataAssemblyResolver that returns a valid assembly.\r\n","Url":"https://github.com/dotnet/wpf/issues/3312","RelatedDescription":"Open issue \"Updating to 16.7 from 16.6.5 causes build issues with WPF project file.\" (#3312)"},{"Id":"674259942","IsPullRequest":true,"CreatedAt":"2020-08-06T12:18:06","Actor":"dotnet-maestro[bot]","Number":"3311","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 3a1d3bb6-c64d-406d-e8f4-08d648cf64cb\r\n- **Build**: 20200803.5\r\n- **Date Produced**: 8/3/2020 9:14 PM\r\n- **Commit**: 7385e2722b9fa517314aa5db1fa598a8d417b3c7\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n  - **Microsoft.DotNet.GenAPI**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n  - **Microsoft.DotNet.Arcade.Sdk**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n  - **Microsoft.DotNet.Helix.Sdk**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n  - **Microsoft.DotNet.ApiCompat**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3311","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#3311)"},{"Id":"674239023","IsPullRequest":false,"CreatedAt":"2020-08-06T11:24:32","Actor":"inosik","Number":"3310","RawContent":null,"Title":"Data-bound TabControls don't select an initial tab item","State":"open","Body":"* .NET Core Version: 3.1.302, 3.1.6\r\n* Windows version: Windows 10 1903\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\n **Problem description:**\r\n\r\nTab controls with data-bound `ItemsSource` don't select an initial tab item, if the tab control is visible at program start. If the tab control becomes visible later, it properly selects the first tab item. This can be verified by moving the \"Dummy\" tab item from the repro sample before the \"Repro\" tab item.\r\n \r\n **Actual behavior:**\r\n\r\n![2020-08-06_13-20-01](https://user-images.githubusercontent.com/11393003/89526116-8ced4a80-d7e7-11ea-8799-e0d88593a6c7.png)\r\n \r\n **Expected behavior:**\r\n\r\nThe inner tab control should automatically select the first item.\r\n \r\n **Minimal repro:**\r\n\r\n[Tabs.zip](https://github.com/dotnet/wpf/files/5034480/Tabs.zip)\r\n","Url":"https://github.com/dotnet/wpf/issues/3310","RelatedDescription":"Open issue \"Data-bound TabControls don't select an initial tab item\" (#3310)"},{"Id":"673973657","IsPullRequest":false,"CreatedAt":"2020-08-06T02:50:38","Actor":"heartacker","Number":"3309","RawContent":null,"Title":"window can't show in win 10/(win7work)","State":"open","Body":"please help me, please ✋ \r\n* .NET Core Version: (e.g. 3.0 Preview1, or daily build number, use `dotnet --info`)\r\n```\r\n.NET Core SDK（反映任何 global.json）:\r\n Version:   3.1.400\r\n Commit:    035fb2aa2f\r\n\r\n运行时环境:\r\n OS Name:     Windows\r\n OS Version:  10.0.14393\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.1.400\\\r\n\r\nHost (useful for support):\r\n  Version: 3.1.6\r\n  Commit:  3acd9b0cd1\r\n\r\n.NET Core SDKs installed:\r\n  3.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.400 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\n```\r\n* Windows version: (`winver`)\r\n![image](https://user-images.githubusercontent.com/1876302/89484381-fe6dce80-d7d0-11ea-8c1d-5542de682a45.png)\r\n\r\n\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes/No\r\nI don't know\r\n\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? If yes, please file the issue via the instructions [here](https://docs.microsoft.com/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019).\r\n \r\n **Problem description:**\r\n app hangs because of one window can't  show.\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nAPP hang \r\n- blank window can show\r\n- the same bin file: win7 run well/ win10 hang\r\n- the same bin x86 file: win7 run well/ win10 hang\r\n- the special-window-code(xaml and cs) has no change to an Previous bin.exe but the Previous bin.exe work well in win7/win10\r\n![image](https://user-images.githubusercontent.com/1876302/89484821-ee0a2380-d7d1-11ea-89d6-74f936558b5b.png)\r\n\r\n![image](https://user-images.githubusercontent.com/1876302/89484875-0ed27900-d7d2-11ea-85d9-661b156971f3.png)\r\n```log\r\n未标记\t>\t0x000031B8\t0x00000001\t主线程\t主线程\tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics\r\n \t \t \t \t \t \t[托管到本机的转换]\r\n \t \t \t \t \t \tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics(ushort* pGlyphIndices, uint glyphCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GlyphMetrics(ushort* pGlyphIndices, int characterCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics, double emSize, float pixelsPerDip, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsAndIndicesOptimized(uint* pCodepoints, int characterCount, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsOptimized(System.Windows.Media.TextFormatting.CharacterBufferRange characters, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.Typeface.CheckFastPathNominalGlyphs(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double scalingFactor, double widthMax, bool keepAWord, bool numberSubstitution, System.Globalization.CultureInfo cultureInfo, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways, bool breakOnTabs, out int stringLengthFit)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.CreateSimpleTextRun(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, System.Windows.Media.TextFormatting.TextRun textRun, MS.Internal.TextFormatting.TextFormatterImp formatter, int widthLeft, bool emergencyWrap, bool breakOnTabs, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.Create(MS.Internal.TextFormatting.FormatSettings settings, System.Windows.Media.TextFormatting.CharacterBufferRange charString, System.Windows.Media.TextFormatting.TextRun textRun, int cp, int cpFirst, int runLength, int widthLeft, int idealRunOffsetUnRounded, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleTextLine.Create(MS.Internal.TextFormatting.FormatSettings settings, int cpFirst, int paragraphWidth, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLineInternal(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLine(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.DockPanel.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Decorator.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Documents.AdornerDecorator.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.MeasureOverrideHelper(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.MeasureOverride(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.SetLayoutSize()\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisual.set(System.Windows.Media.Visual value)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetRootVisual()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetRootVisualAndUpdateSTC()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindow(bool duringShow)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindowDuringShow()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SafeCreateWindowDuringShow()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.ShowHelper(object booleanBox)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.Show()\r\n \t \t \t \t \t \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.MainTpms.OpenFlash_SramBoard(object sender, System.Windows.RoutedEventArgs e) 行 274\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.MenuItem.InvokeClickAfterRender(object arg)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.CallbackWrapper(object obj)\r\n \t \t \t \t \t \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam)\r\n \t \t \t \t \t \t[本机到托管的转换]\r\n \t \t \t \t \t \t[托管到本机的转换]\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.Run()\r\n \t \t \t \t \t \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.App.Main()\r\n\r\n\r\n```\r\n![image](https://user-images.githubusercontent.com/1876302/89484949-36c1dc80-d7d2-11ea-826a-c4577ca79f3b.png)\r\n\r\n```log\r\n \t[托管到本机的转换]\t\r\n \tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics(ushort* pGlyphIndices, uint glyphCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GlyphMetrics(ushort* pGlyphIndices, int characterCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics, double emSize, float pixelsPerDip, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsAndIndicesOptimized(uint* pCodepoints, int characterCount, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsOptimized(System.Windows.Media.TextFormatting.CharacterBufferRange characters, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.Typeface.CheckFastPathNominalGlyphs(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double scalingFactor, double widthMax, bool keepAWord, bool numberSubstitution, System.Globalization.CultureInfo cultureInfo, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways, bool breakOnTabs, out int stringLengthFit)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.CreateSimpleTextRun(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, System.Windows.Media.TextFormatting.TextRun textRun, MS.Internal.TextFormatting.TextFormatterImp formatter, int widthLeft, bool emergencyWrap, bool breakOnTabs, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.Create(MS.Internal.TextFormatting.FormatSettings settings, System.Windows.Media.TextFormatting.CharacterBufferRange charString, System.Windows.Media.TextFormatting.TextRun textRun, int cp, int cpFirst, int runLength, int widthLeft, int idealRunOffsetUnRounded, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleTextLine.Create(MS.Internal.TextFormatting.FormatSettings settings, int cpFirst, int paragraphWidth, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLineInternal(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLine(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.DockPanel.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Decorator.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Documents.AdornerDecorator.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.MeasureOverrideHelper(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.MeasureOverride(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.SetLayoutSize()\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value)\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisual.set(System.Windows.Media.Visual value)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetRootVisual()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetRootVisualAndUpdateSTC()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindow(bool duringShow)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindowDuringShow()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SafeCreateWindowDuringShow()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.ShowHelper(object booleanBox)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.Show()\t未知\r\n>\tATC.TPMS.GUI.dll!ATC.TPMS.GUI.MainTpms.OpenFlash_SramBoard(object sender, System.Windows.RoutedEventArgs e) 行 274\tC#\r\n \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)\t未知\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.MenuItem.InvokeClickAfterRender(object arg)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state)\t未知\r\n \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.CallbackWrapper(object obj)\t未知\r\n \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam)\t未知\r\n \t[本机到托管的转换]\t\r\n \t[托管到本机的转换]\t\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run()\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.Run()\t未知\r\n \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.App.Main()\t未知\r\n\r\n```\r\n **Expected behavior:**\r\n window can show\r\n **Minimal repro:**\r\n","Url":"https://github.com/dotnet/wpf/issues/3309","RelatedDescription":"Open issue \"window can't show in win 10/(win7work)\" (#3309)"},{"Id":"673841140","IsPullRequest":false,"CreatedAt":"2020-08-05T22:56:30","Actor":"davkean","Number":"3308","RawContent":null,"Title":"WPF tmpproj is excluding Microsoft.Net.Compilers.Toolset package ","State":"closed","Body":"**Version Used**: \r\nVersion 16.8.0 Preview 2.0 [30404.163.master]\r\n\r\n**Steps to Reproduce**:\r\n[Build.zip](https://github.com/dotnet/roslyn/files/5026511/Build.zip)\r\n\r\nFrom a VS developer prompt from the above version:\r\n\r\n1. `git clone http://github.com/dotnet/project-system`\r\n2. `cd project-system`\r\n3. `git checkout 90acd3b85ed4fa5eaef154f71d480800332a9946`\r\n4. `build.cmd`\r\n \r\n**Expected Behavior**:\r\nNo errors\r\n\r\n**Actual Behavior**:\r\n\r\nErrors because we're picking up csc from the VS directory instead of the package we're using:\r\n\r\n```\r\nG:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\ProjectSystem\\VS\\Waiting\\VisualStudioWaitIndicator.cs(101,24): error CS8619: Nullability of reference types in value of type '\r\n(WaitIndicatorResult Canceled, T?)' doesn't match target type '(WaitIndicatorResult, T)'. [G:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\Microsoft.VisualStudio.ProjectSyste\r\nm.Managed.VS_jrfzhkfp_wpftmp.csproj]\r\nG:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\ProjectSystem\\VS\\Waiting\\VisualStudioWaitIndicator.cs(108,24): error CS8619: Nullability of reference types in value of type '\r\n(WaitIndicatorResult Canceled, T?)' doesn't match target type '(WaitIndicatorResult, T)'. [G:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\Microsoft.VisualStudio.ProjectSyste\r\nm.Managed.VS_jrfzhkfp_wpftmp.csproj]\r\n```\r\n\r\nRelated part of the build log:\r\n\r\n![image](https://user-images.githubusercontent.com/1103906/89379155-9ff51180-d738-11ea-93eb-a19cfe7a73a7.png)\r\n","Url":"https://github.com/dotnet/wpf/issues/3308","RelatedDescription":"Closed issue \"WPF tmpproj is excluding Microsoft.Net.Compilers.Toolset package \" (#3308)"},{"Id":"673636398","IsPullRequest":false,"CreatedAt":"2020-08-05T16:08:02","Actor":"indinfer","Number":"3306","RawContent":null,"Title":"DataGrid bound to List does not allow adding new rows","State":"closed","Body":"* .NET Core Version: 3.1\r\n* Windows version: Microsoft Windows 10 Pro Version 10.0.19041 Build 19041\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g., XAML Designer, Code editing, etc...)? No\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n\r\nI do not believe this is an actual defect. I hope to learn what I am missing or to understand the behavior.\r\n\r\n **Problem description:**\r\nI run a DataGrid with ItemsSource = a List<>.\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nI run the program. DataGrid allows deleting and changing rows. DataGrid does not allow adding rows.\r\n \r\n **Expected behavior:**\r\nDataGrid should allow adding rows.\r\n \r\n **Minimal repro:**\r\nXaml:\r\n`<Window\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n        xmlns:local=\"clr-namespace:myNamespace\"\r\n        xmlns:Schema=\"clr-namespace:System.Xml.Schema;assembly=System.Xml.ReaderWriter\" x:Class=\"myNamespace.MainWindow\"\r\n        mc:Ignorable=\"d\"\r\n        Title=\"MainWindow\" Height=\"350\" Width=\"600\">\r\n    <Grid>\r\n        <DataGrid x:Name=\"dataGrid\" AutoGenerateColumns=\"False\" CanUserAddRows=\"True\"   >\r\n            <DataGrid.Columns>\r\n                <DataGridTextColumn x:Name=\"col_id\" Width=\"200\" Header=\"Col ID\"  Binding=\"{Binding value_id}\" />\r\n                <DataGridTextColumn x:Name=\"col_1\" Width=\"200\" Header=\"Col One\"  Binding=\"{Binding value_1}\" />\r\n                <DataGridTextColumn x:Name=\"col_2\" Width=\"200\" Header=\"Col Two\"  Binding=\"{Binding value_2}\" />\r\n            </DataGrid.Columns>\r\n        </DataGrid>\r\n\r\n    </Grid>\r\n</Window>\r\n`\r\n\r\nCode Behind:\r\n`using System.Collections.Generic;\r\nusing System.Collections.ObjectModel;\r\nusing System.Windows;\r\n\r\nnamespace myNamespace\r\n{\r\n    /// <summary>\r\n    /// Interaction logic for MainWindow.xaml\r\n    /// </summary>\r\n    public partial class MainWindow : Window\r\n    {\r\n        public MainWindow()\r\n        {\r\n            InitializeComponent();\r\n\r\n            init_item_list();\r\n            dataGrid.ItemsSource = _itemList;\r\n        }\r\n\r\n\r\n        private List<DataItem> _itemList = new List<DataItem>();\r\n        public List<DataItem> ItemList\r\n        {\r\n            get { return _itemList; }\r\n            set { _itemList = value; }\r\n        }\r\n\r\n        public void init_item_list()\r\n        {\r\n            _itemList.Add(new DataItem(1, \"one\", \"i\"));\r\n            _itemList.Add(new DataItem(2, \"two\", \"ii\"));\r\n            _itemList.Add(new DataItem(3, \"three\", \"ii\"));\r\n        }\r\n        public class DataItem\r\n        {\r\n            public DataItem(int id, string val_1, string val_2)\r\n            {\r\n                value_id = id;\r\n                value_1 = val_1;\r\n                value_2 = val_2;\r\n            }\r\n            private int _value_id;\r\n            public int value_id\r\n            {\r\n                get { return _value_id; }\r\n                set { _value_id = value; }\r\n            }\r\n\r\n            private string _value_1;\r\n            public string value_1\r\n            {\r\n                get { return _value_1; }\r\n                set { _value_1 = value; }\r\n            }\r\n\r\n            private string _value_2;\r\n            public string value_2\r\n            {\r\n                get { return _value_2; }\r\n                set { _value_2 = value; }\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n}\r\n`\r\n\r\nHere is how it appears:\r\n\r\n![DataGrid bound to List](https://user-images.githubusercontent.com/8902149/89432421-19780a00-d70f-11ea-972c-4a1583ce015e.png)\r\n\r\nThere is no blank line for adding a new row.\r\n\r\nNote that in Xaml, I explicitly set `CanUserAddRows=\"True\"` \r\n\r\nI thought I saw DataGrid bound to a List allowing adding rows. But I need some help to see what the difference is between what I did before or what I saw before and the code I have in this post. \r\n\r\nHow do I get DataGrid bound to a List to allow adding rows?","Url":"https://github.com/dotnet/wpf/issues/3306","RelatedDescription":"Closed issue \"DataGrid bound to List does not allow adding new rows\" (#3306)"},{"Id":"673518906","IsPullRequest":true,"CreatedAt":"2020-08-05T13:12:10","Actor":"dotnet-maestro[bot]","Number":"3305","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200805.2\r\n- **Date Produced**: 8/5/2020 12:48 PM\r\n- **Commit**: 71d8cb94ba1614d788967d95d34855b92c09d3e6\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20404.2 to 5.0.0-preview.8.20405.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3305","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3305)"},{"Id":"673004642","IsPullRequest":false,"CreatedAt":"2020-08-04T18:55:32","Actor":"Vafnir","Number":"3304","RawContent":null,"Title":"UI Bug","State":"open","Body":"* .NET Core Version: 5.0.100-preview.7.20366.6\r\n* Windows version: 1909\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?:  No\r\n\r\n![g54g](https://user-images.githubusercontent.com/37485150/89332765-9cac4800-d69c-11ea-97a8-8a15eb66c163.gif)\r\n \r\n **Actual behavior:** The board disappears when the window loses focus.\r\n","Url":"https://github.com/dotnet/wpf/issues/3304","RelatedDescription":"Open issue \"UI Bug\" (#3304)"},{"Id":"672829440","IsPullRequest":true,"CreatedAt":"2020-08-04T14:33:22","Actor":"dotnet-maestro[bot]","Number":"3303","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200804.2\r\n- **Date Produced**: 8/4/2020 2:07 PM\r\n- **Commit**: 7739bce4872714b7492280d7b33c08e83c436ee0\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20403.2 to 5.0.0-preview.8.20404.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3303","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3303)"},{"Id":"671747616","IsPullRequest":false,"CreatedAt":"2020-08-04T00:23:53","Actor":"indinfer","Number":"3299","RawContent":null,"Title":"DatePicker in DataGrid loses data","State":"closed","Body":"* .NET Core Version: 3.5\r\n* Windows version: Microsoft Windows 10 Pro\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? No.\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\nDataGrid has DatePicker embedded. Enter a date in the Date column (DatePicker). Tab to the next column. Enter data. Then observe that the Date column goes blank, losing the date. The date should stay.\r\n \r\n **Actual behavior:**\r\nDate column goes blank.\r\n \r\n **Expected behavior:**\r\nDate column should retain the entered date. \r\n\r\n **Minimal repro:**\r\nSteps to the problem.\r\n\r\n[iacc_core.zip](https://github.com/dotnet/wpf/files/5013526/iacc_core.zip)\r\nSetup:\r\n\r\nUnzip iacc_core.zip into a directory of your choosing.\r\n\r\nSubdirectory acc_db contains MySQL schema and data. Hopefully, you can do a data import in MySQL Workbench to load test scheme with test data. \r\n\r\nYou will need to adjust directory paths and set up database connections.\r\n\r\nSteps:\r\n\r\n1. Compile and Run (i.e. Press F5 in Visual Studio).\r\nObserve: The program opens. Focus is on the last row of the top DataGrid (Transactions).\r\n\r\n2. Tab twice, then enter date \"7/20/2020\".\r\nObserve date \"7/20/2020\" showing in DataPicker.\r\n\r\n3. Tab once to \"Ref\" column. Type \"2\".\r\nObserve the problem: DatePicker date disappears. The date should stay.\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/3299","RelatedDescription":"Closed issue \"DatePicker in DataGrid loses data\" (#3299)"},{"Id":"672339239","IsPullRequest":true,"CreatedAt":"2020-08-03T23:33:53","Actor":"wli3","Number":"3301","RawContent":null,"Title":"[Sample no merge] Update to net5.0 template with back compact","State":"closed","Body":"","Url":"https://github.com/dotnet/wpf/pull/3301","RelatedDescription":"Closed or merged PR \"[Sample no merge] Update to net5.0 template with back compact\" (#3301)"},{"Id":"672156881","IsPullRequest":true,"CreatedAt":"2020-08-03T15:41:42","Actor":"dotnet-maestro[bot]","Number":"3300","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200803.2\r\n- **Date Produced**: 8/3/2020 3:18 PM\r\n- **Commit**: e5cdeaa164f2b1f14e79df05389d04195c4d18d6\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20401.2 to 5.0.0-preview.8.20403.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3300","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3300)"},{"Id":"670858507","IsPullRequest":true,"CreatedAt":"2020-08-01T13:19:55","Actor":"dotnet-maestro[bot]","Number":"3298","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200801.2\r\n- **Date Produced**: 8/1/2020 1:02 PM\r\n- **Commit**: f156a59f7e5bf708ca56f03bae698060ee9f014a\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20381.2 to 5.0.0-preview.8.20401.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3298","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3298)"},{"Id":"669900980","IsPullRequest":false,"CreatedAt":"2020-07-31T14:54:39","Actor":"mrlacey","Number":"3296","RawContent":null,"Title":"Expose more AutomationProperties","State":"open","Body":"The currently available AutomationProperties require lots of work to fully control the UI Automation/Accessibility Tree and produce the best possible experience for ALL people using our software.\r\n\r\nAs an example, if I have a TextBlock containing a symbol (via an appropriate font) that is purely visual and next to another TextBlock that contains displayed text relating to the symbol, there is no easy way to hide the symbol TextBlock from the UIA tree.\r\nThe only way to do this seems to be to derive from the TextBlock and access the automation per directly to set `IsControl` and `IsContent` accordingly. That seems complex and unnecessary just to hide a symbol from the UIA Tree.\r\n\r\nIn UWP there is the [AccessibilityView](https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.automation.peers.accessibilityview) property that makes it easy to set this from XAML.\r\nThat would be a start.\r\nEven better would be exposing AutomationProperties for all the [AutomationElementIdentifiers](https://docs.microsoft.com/en-us/dotnet/api/system.windows.automation.automationelementidentifiers?view=netcore-3.1).\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/3296","RelatedDescription":"Open issue \"Expose more AutomationProperties\" (#3296)"},{"Id":"669779155","IsPullRequest":true,"CreatedAt":"2020-07-31T12:54:45","Actor":"dotnet-maestro[bot]","Number":"3295","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200731.2\r\n- **Date Produced**: 7/31/2020 12:35 PM\r\n- **Commit**: 4463395f711e9d2b7627864824457cc68c94e41c\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20380.2 to 5.0.0-preview.8.20381.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3295","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3295)"},{"Id":"669706931","IsPullRequest":false,"CreatedAt":"2020-07-31T11:15:21","Actor":"lindexi","Number":"3294","RawContent":null,"Title":"Enable DirectManipulation","State":"open","Body":"See: [Direct Manipulation - Win32 apps | Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/api/_directmanipulation/ )","Url":"https://github.com/dotnet/wpf/issues/3294","RelatedDescription":"Open issue \"Enable DirectManipulation\" (#3294)"},{"Id":"669075609","IsPullRequest":false,"CreatedAt":"2020-07-30T18:43:26","Actor":"vsfeedback","Number":"3293","RawContent":null,"Title":".NET Core 3.1 WPF Project build fails when project has a long path","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/1117902/net-core-31-wpf-project-build-fails-when-project-h.html)._\n\n---\nVS 2019 Pro\nCore 3.1\nWPF\n\nWhen building a WPF that is within a deep path, the build fails with the following:\n\n>C:\\Program Files\\dotnet\\sdk\\3.1.301\\Sdks\\Microsoft.NET.Sdk.WindowsDesktop\\targets\\Microsoft.WinFX.targets(225,9): error MC1000: Unknown build error, 'Could not find a part of the path 'C:\\<long project path>\\obj\\Debug\\netcoreapp3.1\\<project name>_MarkupCompile.cache'.'\n\nMy project root folder path is 142 chars.\nMy project name is 39 chars.\nThe resuling intermediate MarkupCompile.cache path is 267 chars.\n\nIf I change the path of the project, the compile succeeds. The project builds successfully directly from msbuild.\n\nThank you.\n\n---\n### Original Comments\n\n#### Feedback Bot on 7/19/2020, 07:03 PM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/3293","RelatedDescription":"Open issue \".NET Core 3.1 WPF Project build fails when project has a long path\" (#3293)"},{"Id":"669074315","IsPullRequest":false,"CreatedAt":"2020-07-30T18:42:11","Actor":"vsfeedback","Number":"3292","RawContent":null,"Title":"Unknown build error, 'An item with the same key has already been added.","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/853708/unknown-build-error-an-item-with-the-same-key-has.html)._\n\n---\nWorking on WPF .NET Core 3.1 application and getting this error on first compile after edditing source code, no error if I rebuild it for the second time.  VS 16.4.0 Pro.\n\nError\tRG1000\tUnknown build error, 'An item with the same key has already been added.' \tVtsr\tC:\\Program Files\\dotnet\\sdk\\3.1.100\\Sdks\\Microsoft.NET.Sdk.WindowsDesktop\\targets\\Microsoft.WinFX.targets\t672\n\n---\n### Original Comments\n\n#### Feedback Bot on 12/11/2019, 11:27 PM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n#### Feedback Bot on 1/16/2020, 05:46 PM: \n\nI have detected that for the last 35 days, this issue didn't have much product team activity and a very small amount of new votes or comments. Based on this, its severity, and affected area, it’s my experience that this issue is very unlikely to be fixed.\n#### Peter Czurak on 1/16/2020, 06:13 PM: \n\n<p>Yeah, more bugs in the product. Just amazing!</p><p>A bug is not a bug if Visual Studio Team has to fix it.</p>\n\n#### Karlsson, Henrik on 6/17/2020, 10:48 AM: \n\n<p>It would be amazing if this error could give more information. I'm currently running in to the same problem (.net core 3.1 on visual studio 16.7.0 Preview 2.0 and I just can't figure out what it is.. I've more or less stripped my project down to the bones. Maybe the \"item\" could be named in that error?</p><p>C:\\Program Files\\dotnet\\sdk\\3.1.400-preview-015151\\Sdks\\Microsoft.NET.Sdk.WindowsDesktop\\targets\\Microsoft.WinFX.targets(672,5): error RG1000: Unknown build error, 'An item with the same key has already been added.'</p>\n\n#### Fabian Toader [MSFT] on 6/24/2020, 10:42 AM: \n\n<p>Can you please attach a simple repro project? Thanks!</p>\n\n#### Karlsson, Henrik on 6/25/2020, 02:26 PM: \n\n<p>ok, I figured out why this was happening in our projects.</p><p>It seems like .net core does not like xaml files with the same names inside the same csproj. I had to rename a bunch of xaml files to give them all unique names within the same csproj.</p><p>That's where I noticed that we had multiple Generic.xaml in the same csproj and the Themes one referenced the other.. somehow both got picked up independently so the referenced one was added twice and that way caused \"same key\" problem.</p><p>I renamed one of the Generic.xaml to some other name and referenced that instead and problem went away.</p><p>I don't know if this is the same problem <a rel=\"user\" href=\"https://developercommunity.visualstudio.com/users/1587/8adaea9a-8720-48a9-adba-5323b4521494.html\" nodeid=\"1587\">@Peter Czurak</a> had but it is not totally unlikely :-)</p><p>(The problem for generic.xaml actually goes away on second compile (somehow ends up hidden) but caused infinite loops during runtime load in some cases)</p>\n\n#### Karlsson, Henrik on 6/26/2020, 11:43 AM: \n\n<p>ok, I have even more info. We don't have our csproj files in the same path as the source code (the xaml and cs files) and it seems like if that is the case the intermediate files are just flattened in to one folder... causing problems when two files have the same name.</p><p>so example:</p><p>c:\\dev\\myproj\\myproj.csproj</p><p>have links to</p><p>c:\\dev\\mysource\\a.xaml</p><p>c:\\dev\\ mysource\\folder\\a.xaml</p><p>Both these files write intermediate files to the same folder and overwrite each other</p><p>It feels like maybe in these cases the path to the intermediate file should be based on the &lt;link&gt; metadata in the csproj file?</p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/3292","RelatedDescription":"Open issue \"Unknown build error, 'An item with the same key has already been added.\" (#3292)"},{"Id":"668702646","IsPullRequest":true,"CreatedAt":"2020-07-30T13:21:11","Actor":"dotnet-maestro[bot]","Number":"3291","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200730.2\r\n- **Date Produced**: 7/30/2020 12:55 PM\r\n- **Commit**: 02747e9978cc867fe424612c6c1851f38d7706ab\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20379.2 to 5.0.0-preview.8.20380.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3291","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3291)"},{"Id":"668616267","IsPullRequest":false,"CreatedAt":"2020-07-30T11:09:10","Actor":"usernamedd","Number":"3290","RawContent":null,"Title":"when debugging an error occurs System.IO.FileNotFoundException:“Could not load file or assembly 'PresentationFramework","State":"open","Body":"details below \r\nSystem.IO.FileNotFoundException:“Could not load file or assembly 'PresentationFramework, Version=42.42.42.42, Culture=neutral, PublicKeyToken=31bf3856ad364e35\r\n\r\n after building succefully , I add an project named wpfapp1 target netcore5.0 and then add references to other project in the wpf sln . Complie and run , it occurs that presentationFramework file could not loaded ,but the file is at the same directory with wpfapp1.exe\r\n\r\nsome suggest?","Url":"https://github.com/dotnet/wpf/issues/3290","RelatedDescription":"Open issue \"when debugging an error occurs System.IO.FileNotFoundException:“Could not load file or assembly 'PresentationFramework\" (#3290)"},{"Id":"668006740","IsPullRequest":true,"CreatedAt":"2020-07-29T17:26:10","Actor":"dotnet-maestro[bot]","Number":"3289","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200729.2\r\n- **Date Produced**: 7/29/2020 5:05 PM\r\n- **Commit**: 8cfe0dbe0710ff5064b4d418563c3d126f07887d\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20376.2 to 5.0.0-preview.8.20379.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3289","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3289)"}],"ResultType":"GitHubIssue"}},"RunOn":"2020-08-08T05:30:51.5983978Z","RunDurationInMilliseconds":676}