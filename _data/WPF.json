{"Data":{"GitHub":{"Issues":[{"Id":"678672742","IsPullRequest":true,"CreatedAt":"2020-08-13T19:09:40","Actor":"ryalanms","Number":"3333","RawContent":null,"Title":"Remove private Cpp tools in favor of using production tools","State":"open","Body":"Unpin privatized C++ toolsets and ship using real-signed shipping tools\r\n> #2857 introduced use of privatized C++/CLI toolsets. This is a temporary fix and should be rolled back in favor of production tools.\r\n\r\nTracked by issue #2870. \r\n\r\n> //build and RC/RTM products should not ship using these tools - they should be changed to production tools obtained from ambient tools coming from build pipeline machines.\r\n\r\n> This would become possible as soon as Dev16.6p3 ships.\r\n\r\n> **This should be treated as a release blocker for broad releases like //build, RC etc **\r\n\r\n/cc @dotnet/wpf-developers\r\n\r\nRequires part 2 (see @vatsan-madhavan's comment): \r\n\r\n> You'll need to make 2 additional changes when fixing this one.\r\n\r\n> wpfcontrib@11c24e3\r\n> Disable LTCG for bilinearspan.lib. This causes error C1047 when compilers change. Though this is only a transient problem, it can be a bother in dev-builds.\r\n> Here is a preview of an upcoming build failure:\r\n\r\n> C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.28.29115\\include\\yvals_core.h(503,1): fatal error C1189: #error: STL1001: Unexpected compiler version, expected MSVC 19.27 or newer.\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3333","RelatedDescription":"Open PR \"Remove private Cpp tools in favor of using production tools\" (#3333)"},{"Id":"678635476","IsPullRequest":true,"CreatedAt":"2020-08-13T18:03:49","Actor":"stevenbrix","Number":"3332","RawContent":null,"Title":"adding XamlRuntime msbuild property/metadata","State":"open","Body":"This PR contains a scoped version of the changes described in #3245 \r\n\r\nFor now, we'll keep the globbing in WPF targets, and add the appropriate Item metadata and project property, so that vs tooling can distinguish WPF from WinUI in .NET core projects.\r\n\r\n/cc @dsplaisted @ryalanms @chabiss","Url":"https://github.com/dotnet/wpf/pull/3332","RelatedDescription":"Open PR \"adding XamlRuntime msbuild property/metadata\" (#3332)"},{"Id":"678470685","IsPullRequest":true,"CreatedAt":"2020-08-13T14:12:59","Actor":"dotnet-maestro[bot]","Number":"3331","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"open","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 3a1d3bb6-c64d-406d-e8f4-08d648cf64cb\r\n- **Build**: 20200811.8\r\n- **Date Produced**: 8/11/2020 7:07 PM\r\n- **Commit**: ecec08a0eebbd92bb9538e351d475582551d9092\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: from 5.0.0-beta.20407.3 to 5.0.0-beta.20411.8\r\n  - **Microsoft.DotNet.GenAPI**: from 5.0.0-beta.20407.3 to 5.0.0-beta.20411.8\r\n  - **Microsoft.DotNet.Arcade.Sdk**: from 5.0.0-beta.20407.3 to 5.0.0-beta.20411.8\r\n  - **Microsoft.DotNet.Helix.Sdk**: from 5.0.0-beta.20407.3 to 5.0.0-beta.20411.8\r\n  - **Microsoft.DotNet.ApiCompat**: from 5.0.0-beta.20407.3 to 5.0.0-beta.20411.8\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3331","RelatedDescription":"Open PR \"[master] Update dependencies from dotnet/arcade\" (#3331)"},{"Id":"678042229","IsPullRequest":false,"CreatedAt":"2020-08-12T23:38:37","Actor":"maxbrister","Number":"3330","RawContent":null,"Title":" WPF applications with non ascii project names do not work","State":"open","Body":"* .NET Core Version: 5.0.100-preview.7.20366.6\r\n* Windows version: 2004 (OS Build 19041.450)\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: No\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? No\r\n* Security issues and bugs should be reported privately, learn more via our [responsible disclosure guidelines](https://github.com/dotnet/wpf/blob/master/README.md#reporting-security-issues-and-security-bugs).\r\n \r\n **Problem description:**\r\n\r\n WPF applications with non ascii project names throw an exception when creating MainPage.xaml.\r\n\r\n **Actual behavior:**\r\n\r\nException has occurred: CLR/System.UriFormatException\r\nAn exception of type 'System.UriFormatException' occurred in System.Private.Uri.dll but was not handled in user code: 'Invalid URI: The Authority/Host could not be parsed.'\r\n   at System.Uri.CreateThis(String uri, Boolean dontEscape, UriKind uriKind)\r\n   at System.Uri..ctor(Uri baseUri, Uri relativeUri)\r\n   at System.Windows.Application.LoadComponent(Object component, Uri resourceLocator)\r\n   at Prj_ヺヸヺヰィヰヷゆモ.MainWindow.InitializeComponent() in C:\\Users\\mabriste\\temp\\Prj_ヺヸヺヰィヰヷゆモ\\MainWindow.xaml:line 1\r\n   at Prj_ヺヸヺヰィヰヷゆモ.MainWindow..ctor() in C:\\Users\\mabriste\\temp\\Prj_ヺヸヺヰィヰヷゆモ\\MainWindow.xaml.cs:line 25\r\n \r\n **Expected behavior:**\r\n \r\n **Minimal repro:**\r\n\r\ndotnet new wpf --name \"Prj_ヺヸヺヰィヰヷゆモ\"\r\ncd \"Prj_ヺヸヺヰィヰヷゆモ\"\r\ndotnet run\r\n\r\nObserve app does not start. To see exception start in a debugger.","Url":"https://github.com/dotnet/wpf/issues/3330","RelatedDescription":"Open issue \" WPF applications with non ascii project names do not work\" (#3330)"},{"Id":"678041917","IsPullRequest":true,"CreatedAt":"2020-08-12T23:37:46","Actor":"agocke","Number":"3329","RawContent":null,"Title":"Remove VerifyWpfDllSet","State":"open","Body":"Fixes #3322","Url":"https://github.com/dotnet/wpf/pull/3329","RelatedDescription":"Open PR \"Remove VerifyWpfDllSet\" (#3329)"},{"Id":"678010427","IsPullRequest":true,"CreatedAt":"2020-08-12T23:17:56","Actor":"dotnet-maestro[bot]","Number":"3328","RawContent":null,"Title":"[release/3.1] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: fd5f4619-cca3-4e12-8f56-08d72a4ce301\r\n- **Build**: 20200812.5\r\n- **Date Produced**: 8/12/2020 10:04 PM\r\n- **Commit**: cf28cab9e5142862de29534e688680a239ba781c\r\n- **Branch**: refs/heads/release/3.1\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 4.8.1-servicing.20411.4 to 4.8.1-servicing.20412.5\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3328","RelatedDescription":"Closed or merged PR \"[release/3.1] Update dependencies from dotnet/winforms\" (#3328)"},{"Id":"677664836","IsPullRequest":true,"CreatedAt":"2020-08-12T12:54:44","Actor":"dotnet-maestro[bot]","Number":"3327","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200812.2\r\n- **Date Produced**: 8/12/2020 12:34 PM\r\n- **Commit**: ae770e8f2bf4dffba628c0175bacb036e27987db\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20411.4 to 5.0.0-preview.8.20412.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3327","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3327)"},{"Id":"673004642","IsPullRequest":false,"CreatedAt":"2020-08-12T08:21:29","Actor":"Vafnir","Number":"3304","RawContent":null,"Title":"UI Bug","State":"closed","Body":"* .NET Core Version: 5.0.100-preview.7.20366.6\r\n* Windows version: 1909\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?:  No\r\n\r\n![g54g](https://user-images.githubusercontent.com/37485150/89332765-9cac4800-d69c-11ea-97a8-8a15eb66c163.gif)\r\n \r\n **Actual behavior:** The board disappears when the window loses focus.\r\n","Url":"https://github.com/dotnet/wpf/issues/3304","RelatedDescription":"Closed issue \"UI Bug\" (#3304)"},{"Id":"674287447","IsPullRequest":false,"CreatedAt":"2020-08-12T06:56:10","Actor":"53m1k0l0n","Number":"3312","RawContent":null,"Title":"Updating to 16.7 from 16.6.5 causes build issues with WPF project file.","State":"closed","Body":"When building a WPF project the following error is shown, this built fine in the last 16.6.5 version that was released.\r\n\r\nC:\\Program Files\\dotnet\\sdk\\3.1.400\\Sdks\\Microsoft.NET.Sdk.WindowsDesktop\\targets\\Microsoft.WinFX.targets 225\r\n\r\nUnknown build error, 'Could not find assembly 'mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e'. Either explicitly load this assembly using a method such as LoadFromAssemblyPath() or use a MetadataAssemblyResolver that returns a valid assembly.\r\n","Url":"https://github.com/dotnet/wpf/issues/3312","RelatedDescription":"Closed issue \"Updating to 16.7 from 16.6.5 causes build issues with WPF project file.\" (#3312)"},{"Id":"677323417","IsPullRequest":true,"CreatedAt":"2020-08-12T02:22:00","Actor":"dotnet-maestro[bot]","Number":"3326","RawContent":null,"Title":"[release/3.1] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: fd5f4619-cca3-4e12-8f56-08d72a4ce301\r\n- **Build**: 20200811.4\r\n- **Date Produced**: 8/12/2020 2:03 AM\r\n- **Commit**: 96f8bef5b7856c14407744fb9fe3fc81d61e8e67\r\n- **Branch**: refs/heads/release/3.1\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 4.8.1-servicing.20308.4 to 4.8.1-servicing.20411.4\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:fd5f4619-cca3-4e12-8f56-08d72a4ce301)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3326","RelatedDescription":"Closed or merged PR \"[release/3.1] Update dependencies from dotnet/winforms\" (#3326)"},{"Id":"676899348","IsPullRequest":true,"CreatedAt":"2020-08-11T14:11:32","Actor":"dotnet-maestro[bot]","Number":"3325","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200811.4\r\n- **Date Produced**: 8/11/2020 1:46 PM\r\n- **Commit**: 4e44ecfa999a2fe8998b69156e4d4241a3b6a471\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20411.3 to 5.0.0-preview.8.20411.4\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3325","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3325)"},{"Id":"676865258","IsPullRequest":true,"CreatedAt":"2020-08-11T13:26:24","Actor":"dotnet-maestro[bot]","Number":"3324","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200811.3\r\n- **Date Produced**: 8/11/2020 12:57 PM\r\n- **Commit**: e02a53d60d68468c50479b3fbccf7b35cfc9f151\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20410.2 to 5.0.0-preview.8.20411.3\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3324","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3324)"},{"Id":"676821186","IsPullRequest":true,"CreatedAt":"2020-08-11T12:18:36","Actor":"dotnet-maestro[bot]","Number":"3323","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 3a1d3bb6-c64d-406d-e8f4-08d648cf64cb\r\n- **Build**: 20200807.3\r\n- **Date Produced**: 8/7/2020 7:54 PM\r\n- **Commit**: ea8f37e8982dc22022b33c5e151081ad04d923a6\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: from 5.0.0-beta.20403.5 to 5.0.0-beta.20407.3\r\n  - **Microsoft.DotNet.GenAPI**: from 5.0.0-beta.20403.5 to 5.0.0-beta.20407.3\r\n  - **Microsoft.DotNet.Arcade.Sdk**: from 5.0.0-beta.20403.5 to 5.0.0-beta.20407.3\r\n  - **Microsoft.DotNet.Helix.Sdk**: from 5.0.0-beta.20403.5 to 5.0.0-beta.20407.3\r\n  - **Microsoft.DotNet.ApiCompat**: from 5.0.0-beta.20403.5 to 5.0.0-beta.20407.3\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3323","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#3323)"},{"Id":"676375956","IsPullRequest":false,"CreatedAt":"2020-08-10T19:51:55","Actor":"ryalanms","Number":"3322","RawContent":null,"Title":"Remove WpfDllVerifier checks from WPF","State":"open","Body":"WPF has runtime checks to verify the correct versions of WPF assemblies are being loaded. It does so by validating that the DLLs are loaded from the same path. These checks were very useful when porting WPF to .NET Core, but WPF assembly load locations are varied for .NET 5 scenarios. The WpfDllVerifier class and uses of it should be removed for .NET 5.\r\n\r\n    /// This class attempts to verify that core WPF binaries are all loaded from the same\r\n    /// location.  Due to the fact that WPF can load binaries in different orders, this class\r\n    /// needs to be called from all of the core managed binaries in static constructors of\r\n    /// commonly used classes.\r\n    /// \r\n    /// This can also be used to verify specific additional binaries as needed (say if they are\r\n    /// optionally loaded).\r\n\r\n    /// If the binaries fail to load from the same location an exception is thrown as we cannot \r\n    /// guarantee there won't be difficult to debug issues.\r\n\r\n#11350\r\ndotnet/runtime#38636\r\n ","Url":"https://github.com/dotnet/wpf/issues/3322","RelatedDescription":"Open issue \"Remove WpfDllVerifier checks from WPF\" (#3322)"},{"Id":"676112190","IsPullRequest":true,"CreatedAt":"2020-08-10T13:07:12","Actor":"dotnet-maestro[bot]","Number":"3321","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200810.2\r\n- **Date Produced**: 8/10/2020 12:42 PM\r\n- **Commit**: 7f5edb888a00367085fe1071ead837e4e289cb20\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20409.2 to 5.0.0-preview.8.20410.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3321","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3321)"},{"Id":"675695127","IsPullRequest":true,"CreatedAt":"2020-08-09T13:09:11","Actor":"dotnet-maestro[bot]","Number":"3320","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200809.2\r\n- **Date Produced**: 8/9/2020 12:46 PM\r\n- **Commit**: 7a30a7d9e7f04048c8cb968c6e2a6f25b4ac2073\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20407.2 to 5.0.0-preview.8.20409.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3320","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3320)"},{"Id":"675501131","IsPullRequest":false,"CreatedAt":"2020-08-08T14:25:36","Actor":"CreateAndInject","Number":"3319","RawContent":null,"Title":"The AssemblyId of a TypeInfoRecord doesn't exist","State":"closed","Body":"I found this baml:\r\n```TypeInfo [TypeId=0x0001, AssemblyId=0x1000, TypeFullName=\"x.y\"]```\r\n\r\nBut there's no `AssemblyInfoRecord` with `AssemblyId=0x1000`\r\nWhy does this program can still run?\r\nIs `0x1000` a special id? Does .Net allways try to find type in the current assembly if its `AssemblyId` doesn't exist?\r\nCan someone tell me the logic?","Url":"https://github.com/dotnet/wpf/issues/3319","RelatedDescription":"Closed issue \"The AssemblyId of a TypeInfoRecord doesn't exist\" (#3319)"},{"Id":"675390923","IsPullRequest":true,"CreatedAt":"2020-08-08T01:27:02","Actor":"GrabYourPitchforks","Number":"3318","RawContent":null,"Title":"Call SHA1.HashData static helper instead of instantiating SHA1CSP","State":"open","Body":"We're trying to minimize usage of the `*CryptoServiceProvider` and `*Managed` types through our code bases so that we can eventually write analyzers to recommend moving off of them. See https://github.com/dotnet/runtime/issues/40169 for some related discussion w.r.t. `RNGCryptoServiceProvider`.\r\n\r\nThis PR changes the call site to use the static one-shot helper method so that you don't need to instantiate a hasher object. The `HashData` static method uses the best available implementation for the current OS.","Url":"https://github.com/dotnet/wpf/pull/3318","RelatedDescription":"Open PR \"Call SHA1.HashData static helper instead of instantiating SHA1CSP\" (#3318)"},{"Id":"675171067","IsPullRequest":false,"CreatedAt":"2020-08-07T17:43:36","Actor":"vatsan-madhavan","Number":"3317","RawContent":null,"Title":"Warning C4244 - implicit double -> float conversion with possible data-loss in BaseMatrix.cpp","State":"open","Body":"Here is the warning: \r\n\r\n> src\\Microsoft.DotNet.Wpf\\src\\WpfGfx\\core\\common\\BaseMatrix.cpp(1034,57): warning C4244: 'argument':\r\nconversion from 'double' to 'float', possible loss of data\r\n\r\nhttps://github.com/dotnet/wpf/blob/49cc5c6dcf0ead39a08b1917eeb1d472bcfbe739/src/Microsoft.DotNet.Wpf/src/WpfGfx/core/common/BaseMatrix.cpp#L1034\r\n\r\n`CFloatFpu::Ceiling` takes a `float` param, but `std::pow` returns a `double`, which leads to the warning: \r\n\r\nhttps://github.com/dotnet/wpf/blob/49cc5c6dcf0ead39a08b1917eeb1d472bcfbe739/src/Microsoft.DotNet.Wpf/src/WpfGfx/common/shared/real.h#L628-L630\r\n\r\n\r\n`std::pow` is defined to return `double` since C++11 ([reference](https://en.cppreference.com/w/cpp/numeric/math/pow))\r\n\r\n\r\n>```C++\r\n>Promoted    pow ( Arithmetic1 base, Arithmetic2 exp ); | (7) | (since C++11)\r\n>```\r\n>7) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by 1-3). If any argument has integral type, it is cast to `double`. If any argument is `long double`, then the return type Promoted is also `long double`, otherwise the return type is always `double`.\r\n\r\n-- \r\n\r\nThe result of `std::pow` should be safe to `static_cast` to `REAL` since `rScaleThreshold <= 1` (this is assert'ed early in the method). \r\n\r\n-- \r\n\r\nWhy isn't this warning seen in CI/dev builds using build.cmd today? I can see it easily when building wpfgfx.vcxproj with `msbuild` directly. ","Url":"https://github.com/dotnet/wpf/issues/3317","RelatedDescription":"Open issue \"Warning C4244 - implicit double -> float conversion with possible data-loss in BaseMatrix.cpp\" (#3317)"},{"Id":"674991435","IsPullRequest":true,"CreatedAt":"2020-08-07T13:05:12","Actor":"dotnet-maestro[bot]","Number":"3316","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200807.2\r\n- **Date Produced**: 8/7/2020 12:37 PM\r\n- **Commit**: faaaf57a2500812161247f3b0a528ff77a53e91e\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20406.4 to 5.0.0-preview.8.20407.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3316","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3316)"},{"Id":"674884264","IsPullRequest":false,"CreatedAt":"2020-08-07T09:20:10","Actor":"Nukepayload2","Number":"3315","RawContent":null,"Title":"ExecutionEngineException when calling TextBox.Focus in TextInputStart","State":"open","Body":"* .NET Core Version: 5.0.0-preview.7.20364.11\r\n* Windows version: \r\nBuild 10.0.19041.388\r\nWindows feature experience pack 120.2202.130.0\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? \r\nNo\r\n* Security issues and bugs should be reported privately, learn more via our [responsible disclosure guidelines](https://github.com/dotnet/wpf/blob/master/README.md#reporting-security-issues-and-security-bugs).\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\nWhen using Microsoft Japanese IME, `TextBox.Focus` throws `ExecutionEngineException` when calling it in a `TextInputStart` attached event handler.\r\n \r\n **Actual behavior:** \r\n```\r\nSystem.ExecutionEngineException\r\nHResult is 80131506\r\n\r\n>\tWindowsBase.dll!MS.Internal.Invariant.FailFast(string message, string detailMessage)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.VerifyTextStoreConsistency()\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.GrantLock()\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.GrantLockWorker(MS.Win32.UnsafeNativeMethods.LockFlags flags)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.RequestLock(MS.Win32.UnsafeNativeMethods.LockFlags flags, out int hrSession)\tUnknown\r\n \t[Native to Managed Transition]\t\r\n \t[Managed to Native Transition]\t\r\n \tPresentationFramework.dll!System.Windows.Documents.FrameworkTextComposition.CompleteCurrentComposition(MS.Win32.UnsafeNativeMethods.ITfDocumentMgr documentMgr)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.CompleteComposition()\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextEditor.OnLostKeyboardFocus(object sender, System.Windows.Input.KeyboardFocusChangedEventArgs e)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Controls.Primitives.TextBoxBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs e)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.OnLostKeyboardFocusThunk(object sender, System.Windows.Input.KeyboardFocusChangedEventArgs e)\tUnknown\r\n \tPresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)\tUnknown\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseTrustedEvent(System.Windows.RoutedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.KeyboardDevice.ChangeFocus(System.Windows.DependencyObject focus, int timestamp)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.KeyboardDevice.TryChangeFocus(System.Windows.DependencyObject newFocus, System.Windows.Input.IKeyboardInputProvider keyboardInputProvider, bool askOld, bool askNew, bool forceToNullIfFailed)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.KeyboardDevice.Focus(System.Windows.DependencyObject focus, bool askOld, bool askNew, bool forceToNullIfFailed)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.KeyboardDevice.Focus(System.Windows.IInputElement element)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.Focus()\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextCompositionEventArgs.InvokeEventHandler(System.Delegate genericHandler, object genericTarget)\tUnknown\r\n \tPresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target)\tUnknown\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseTrustedEvent(System.Windows.RoutedEventArgs args)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextCompositionManager.UnsafeStartComposition(System.Windows.Input.TextComposition composition)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextCompositionManager.StartComposition(System.Windows.Input.TextComposition composition)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.RaiseCompositionEvents(out int appSelectionAnchorOffset, out int appSelectionMovingOffset)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.HandleCompositionEvents(int previousUndoCount)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.GrantLockWorker(MS.Win32.UnsafeNativeMethods.LockFlags flags)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Documents.TextStore.RequestLock(MS.Win32.UnsafeNativeMethods.LockFlags flags, out int hrSession)\tUnknown\r\n \t[Native to Managed Transition]\t\r\n \t[Managed to Native Transition]\t\r\n \tPresentationCore.dll!System.Windows.Input.TextServicesContext.Keystroke(int wParam, int lParam, System.Windows.Input.TextServicesContext.KeyOp op)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextServicesManager.TextServicesKeystroke(System.Windows.Input.TextServicesContext context, System.Windows.Input.KeyEventArgs keyArgs, bool test)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.TextServicesManager.PostProcessInput(object sender, System.Windows.Input.ProcessInputEventArgs e)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputManager.RaiseProcessInputEventHandlers(System.Windows.Input.ProcessInputEventHandler postProcessInput, System.Windows.Input.ProcessInputEventArgs processInputEventArgs)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputManager.ProcessStagingArea()\tUnknown\r\n \tPresentationCore.dll!System.Windows.Input.InputProviderSite.ReportInput(System.Windows.Input.InputReport inputReport)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndKeyboardInputProvider.ReportInput(System.IntPtr hwnd, System.Windows.Input.InputMode mode, int timestamp, System.Windows.Input.RawKeyboardActions actions, int scanCode, bool isExtendedKey, bool isSystemKey, int virtualKey)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndKeyboardInputProvider.ProcessKeyAction(ref System.Windows.Interop.MSG msg, ref bool handled)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.CriticalTranslateAccelerator(ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.OnPreprocessMessage(object param)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)\tUnknown\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.OnPreprocessMessageThunk(ref System.Windows.Interop.MSG msg, ref bool handled)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Interop.ComponentDispatcherThread.RaiseThreadMessage(ref System.Windows.Interop.MSG msg)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)\tUnknown\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run()\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)\tUnknown\r\n \tPresentationFramework.dll!System.Windows.Application.Run()\tUnknown\r\n```\r\n \r\n **Expected behavior:**\r\nThe program should not crash.\r\n \r\n **Minimal repro:**\r\n1. Create a new WPF project\r\n```console\r\ndotnet new wpf -lang vb\r\n```\r\n2. Edit `MainWindow.xaml`\r\n```xml\r\n<Window x:Class=\"MainWindow\"\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        Title=\"Windows 10 version 2004 JP IME crash\"\r\n        Height=\"350\" Width=\"400\">\r\n    <StackPanel>\r\n        <TextBlock>1. Use Windows 10 version 2004 (ja-JP)</TextBlock>\r\n        <TextBlock>2. Click this text box ↓</TextBlock>\r\n        <TextBox x:Name=\"Editor1\" />\r\n        <TextBlock>3. Switch to Japanese IME</TextBlock>\r\n        <TextBlock>4. Switch to Hiragana mode</TextBlock>\r\n        <TextBlock>5. Press \"A\"</TextBlock>\r\n\r\n        <TextBlock Margin=\"0,24,0,0\">Don't use this one:</TextBlock>\r\n        <TextBox x:Name=\"Editor2\" HorizontalAlignment=\"Left\"/>\r\n    </StackPanel>\r\n</Window>\r\n```\r\n3. Edit `MainWindow.xaml.vb`\r\n```vbnet\r\nClass MainWindow\r\n    Private Sub MainWindow_Loaded() Handles Me.Loaded\r\n        TextCompositionManager.AddTextInputStartHandler(Editor1, AddressOf Editor2.Focus)\r\n    End Sub\r\nEnd Class\r\n```\r\n4. Run the project\r\n```console\r\ndotnet run\r\n```\r\n5. Click the first text box.\r\n6. Use Japanese IME, Hiragana mode.\r\n7. Press the \"A\" key. \r\n","Url":"https://github.com/dotnet/wpf/issues/3315","RelatedDescription":"Open issue \"ExecutionEngineException when calling TextBox.Focus in TextInputStart\" (#3315)"},{"Id":"673821938","IsPullRequest":true,"CreatedAt":"2020-08-06T20:39:23","Actor":"wli3","Number":"3307","RawContent":null,"Title":"Update to net5.0 template with backcompact","State":"closed","Body":"Port https://github.com/dotnet/wpf/pull/3302","Url":"https://github.com/dotnet/wpf/pull/3307","RelatedDescription":"Closed or merged PR \"Update to net5.0 template with backcompact\" (#3307)"},{"Id":"674323150","IsPullRequest":true,"CreatedAt":"2020-08-06T13:55:49","Actor":"dotnet-maestro[bot]","Number":"3314","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200806.4\r\n- **Date Produced**: 8/6/2020 1:32 PM\r\n- **Commit**: 58b6c51dc1ad5ab1dcf602b138bf06a9566cd2b7\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20406.3 to 5.0.0-preview.8.20406.4\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3314","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3314)"},{"Id":"674303347","IsPullRequest":true,"CreatedAt":"2020-08-06T13:22:29","Actor":"dotnet-maestro[bot]","Number":"3313","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200806.3\r\n- **Date Produced**: 8/6/2020 1:04 PM\r\n- **Commit**: b966f5c54abdc64411c4fe96ab42d7f091ce12bd\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20405.2 to 5.0.0-preview.8.20406.3\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3313","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3313)"},{"Id":"674259942","IsPullRequest":true,"CreatedAt":"2020-08-06T12:18:06","Actor":"dotnet-maestro[bot]","Number":"3311","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 3a1d3bb6-c64d-406d-e8f4-08d648cf64cb\r\n- **Build**: 20200803.5\r\n- **Date Produced**: 8/3/2020 9:14 PM\r\n- **Commit**: 7385e2722b9fa517314aa5db1fa598a8d417b3c7\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n  - **Microsoft.DotNet.GenAPI**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n  - **Microsoft.DotNet.Arcade.Sdk**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n  - **Microsoft.DotNet.Helix.Sdk**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n  - **Microsoft.DotNet.ApiCompat**: from 5.0.0-beta.20374.1 to 5.0.0-beta.20403.5\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3311","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#3311)"},{"Id":"674239023","IsPullRequest":false,"CreatedAt":"2020-08-06T11:24:32","Actor":"inosik","Number":"3310","RawContent":null,"Title":"Data-bound TabControls don't select an initial tab item","State":"open","Body":"* .NET Core Version: 3.1.302, 3.1.6\r\n* Windows version: Windows 10 1903\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\n **Problem description:**\r\n\r\nTab controls with data-bound `ItemsSource` don't select an initial tab item, if the tab control is visible at program start. If the tab control becomes visible later, it properly selects the first tab item. This can be verified by moving the \"Dummy\" tab item from the repro sample before the \"Repro\" tab item.\r\n \r\n **Actual behavior:**\r\n\r\n![2020-08-06_13-20-01](https://user-images.githubusercontent.com/11393003/89526116-8ced4a80-d7e7-11ea-8799-e0d88593a6c7.png)\r\n \r\n **Expected behavior:**\r\n\r\nThe inner tab control should automatically select the first item.\r\n \r\n **Minimal repro:**\r\n\r\n[Tabs.zip](https://github.com/dotnet/wpf/files/5034480/Tabs.zip)\r\n","Url":"https://github.com/dotnet/wpf/issues/3310","RelatedDescription":"Open issue \"Data-bound TabControls don't select an initial tab item\" (#3310)"},{"Id":"673973657","IsPullRequest":false,"CreatedAt":"2020-08-06T02:50:38","Actor":"heartacker","Number":"3309","RawContent":null,"Title":"window can't show in win 10/(win7work)","State":"open","Body":"please help me, please ✋ \r\n* .NET Core Version: (e.g. 3.0 Preview1, or daily build number, use `dotnet --info`)\r\n```\r\n.NET Core SDK（反映任何 global.json）:\r\n Version:   3.1.400\r\n Commit:    035fb2aa2f\r\n\r\n运行时环境:\r\n OS Name:     Windows\r\n OS Version:  10.0.14393\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.1.400\\\r\n\r\nHost (useful for support):\r\n  Version: 3.1.6\r\n  Commit:  3acd9b0cd1\r\n\r\n.NET Core SDKs installed:\r\n  3.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.400 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\n```\r\n* Windows version: (`winver`)\r\n![image](https://user-images.githubusercontent.com/1876302/89484381-fe6dce80-d7d0-11ea-8c1d-5542de682a45.png)\r\n\r\n\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes/No\r\nI don't know\r\n\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? If yes, please file the issue via the instructions [here](https://docs.microsoft.com/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019).\r\n \r\n **Problem description:**\r\n app hangs because of one window can't  show.\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nAPP hang \r\n- blank window can show\r\n- the same bin file: win7 run well/ win10 hang\r\n- the same bin x86 file: win7 run well/ win10 hang\r\n- the special-window-code(xaml and cs) has no change to an Previous bin.exe but the Previous bin.exe work well in win7/win10\r\n![image](https://user-images.githubusercontent.com/1876302/89484821-ee0a2380-d7d1-11ea-89d6-74f936558b5b.png)\r\n\r\n![image](https://user-images.githubusercontent.com/1876302/89484875-0ed27900-d7d2-11ea-85d9-661b156971f3.png)\r\n```log\r\n未标记\t>\t0x000031B8\t0x00000001\t主线程\t主线程\tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics\r\n \t \t \t \t \t \t[托管到本机的转换]\r\n \t \t \t \t \t \tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics(ushort* pGlyphIndices, uint glyphCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GlyphMetrics(ushort* pGlyphIndices, int characterCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics, double emSize, float pixelsPerDip, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsAndIndicesOptimized(uint* pCodepoints, int characterCount, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsOptimized(System.Windows.Media.TextFormatting.CharacterBufferRange characters, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.Typeface.CheckFastPathNominalGlyphs(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double scalingFactor, double widthMax, bool keepAWord, bool numberSubstitution, System.Globalization.CultureInfo cultureInfo, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways, bool breakOnTabs, out int stringLengthFit)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.CreateSimpleTextRun(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, System.Windows.Media.TextFormatting.TextRun textRun, MS.Internal.TextFormatting.TextFormatterImp formatter, int widthLeft, bool emergencyWrap, bool breakOnTabs, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.Create(MS.Internal.TextFormatting.FormatSettings settings, System.Windows.Media.TextFormatting.CharacterBufferRange charString, System.Windows.Media.TextFormatting.TextRun textRun, int cp, int cpFirst, int runLength, int widthLeft, int idealRunOffsetUnRounded, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleTextLine.Create(MS.Internal.TextFormatting.FormatSettings settings, int cpFirst, int paragraphWidth, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLineInternal(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLine(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.DockPanel.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Decorator.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Documents.AdornerDecorator.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.MeasureOverrideHelper(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.MeasureOverride(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.SetLayoutSize()\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisual.set(System.Windows.Media.Visual value)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetRootVisual()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetRootVisualAndUpdateSTC()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindow(bool duringShow)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindowDuringShow()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SafeCreateWindowDuringShow()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.ShowHelper(object booleanBox)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.Show()\r\n \t \t \t \t \t \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.MainTpms.OpenFlash_SramBoard(object sender, System.Windows.RoutedEventArgs e) 行 274\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.MenuItem.InvokeClickAfterRender(object arg)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.CallbackWrapper(object obj)\r\n \t \t \t \t \t \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam)\r\n \t \t \t \t \t \t[本机到托管的转换]\r\n \t \t \t \t \t \t[托管到本机的转换]\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.Run()\r\n \t \t \t \t \t \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.App.Main()\r\n\r\n\r\n```\r\n![image](https://user-images.githubusercontent.com/1876302/89484949-36c1dc80-d7d2-11ea-826a-c4577ca79f3b.png)\r\n\r\n```log\r\n \t[托管到本机的转换]\t\r\n \tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics(ushort* pGlyphIndices, uint glyphCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GlyphMetrics(ushort* pGlyphIndices, int characterCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics, double emSize, float pixelsPerDip, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsAndIndicesOptimized(uint* pCodepoints, int characterCount, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsOptimized(System.Windows.Media.TextFormatting.CharacterBufferRange characters, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.Typeface.CheckFastPathNominalGlyphs(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double scalingFactor, double widthMax, bool keepAWord, bool numberSubstitution, System.Globalization.CultureInfo cultureInfo, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways, bool breakOnTabs, out int stringLengthFit)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.CreateSimpleTextRun(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, System.Windows.Media.TextFormatting.TextRun textRun, MS.Internal.TextFormatting.TextFormatterImp formatter, int widthLeft, bool emergencyWrap, bool breakOnTabs, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.Create(MS.Internal.TextFormatting.FormatSettings settings, System.Windows.Media.TextFormatting.CharacterBufferRange charString, System.Windows.Media.TextFormatting.TextRun textRun, int cp, int cpFirst, int runLength, int widthLeft, int idealRunOffsetUnRounded, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleTextLine.Create(MS.Internal.TextFormatting.FormatSettings settings, int cpFirst, int paragraphWidth, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLineInternal(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLine(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.DockPanel.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Decorator.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Documents.AdornerDecorator.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.MeasureOverrideHelper(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.MeasureOverride(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.SetLayoutSize()\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value)\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisual.set(System.Windows.Media.Visual value)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetRootVisual()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetRootVisualAndUpdateSTC()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindow(bool duringShow)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindowDuringShow()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SafeCreateWindowDuringShow()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.ShowHelper(object booleanBox)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.Show()\t未知\r\n>\tATC.TPMS.GUI.dll!ATC.TPMS.GUI.MainTpms.OpenFlash_SramBoard(object sender, System.Windows.RoutedEventArgs e) 行 274\tC#\r\n \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)\t未知\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.MenuItem.InvokeClickAfterRender(object arg)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state)\t未知\r\n \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.CallbackWrapper(object obj)\t未知\r\n \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam)\t未知\r\n \t[本机到托管的转换]\t\r\n \t[托管到本机的转换]\t\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run()\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.Run()\t未知\r\n \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.App.Main()\t未知\r\n\r\n```\r\n **Expected behavior:**\r\n window can show\r\n **Minimal repro:**\r\n","Url":"https://github.com/dotnet/wpf/issues/3309","RelatedDescription":"Open issue \"window can't show in win 10/(win7work)\" (#3309)"},{"Id":"673841140","IsPullRequest":false,"CreatedAt":"2020-08-05T22:56:30","Actor":"davkean","Number":"3308","RawContent":null,"Title":"WPF tmpproj is excluding Microsoft.Net.Compilers.Toolset package ","State":"closed","Body":"**Version Used**: \r\nVersion 16.8.0 Preview 2.0 [30404.163.master]\r\n\r\n**Steps to Reproduce**:\r\n[Build.zip](https://github.com/dotnet/roslyn/files/5026511/Build.zip)\r\n\r\nFrom a VS developer prompt from the above version:\r\n\r\n1. `git clone http://github.com/dotnet/project-system`\r\n2. `cd project-system`\r\n3. `git checkout 90acd3b85ed4fa5eaef154f71d480800332a9946`\r\n4. `build.cmd`\r\n \r\n**Expected Behavior**:\r\nNo errors\r\n\r\n**Actual Behavior**:\r\n\r\nErrors because we're picking up csc from the VS directory instead of the package we're using:\r\n\r\n```\r\nG:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\ProjectSystem\\VS\\Waiting\\VisualStudioWaitIndicator.cs(101,24): error CS8619: Nullability of reference types in value of type '\r\n(WaitIndicatorResult Canceled, T?)' doesn't match target type '(WaitIndicatorResult, T)'. [G:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\Microsoft.VisualStudio.ProjectSyste\r\nm.Managed.VS_jrfzhkfp_wpftmp.csproj]\r\nG:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\ProjectSystem\\VS\\Waiting\\VisualStudioWaitIndicator.cs(108,24): error CS8619: Nullability of reference types in value of type '\r\n(WaitIndicatorResult Canceled, T?)' doesn't match target type '(WaitIndicatorResult, T)'. [G:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\Microsoft.VisualStudio.ProjectSyste\r\nm.Managed.VS_jrfzhkfp_wpftmp.csproj]\r\n```\r\n\r\nRelated part of the build log:\r\n\r\n![image](https://user-images.githubusercontent.com/1103906/89379155-9ff51180-d738-11ea-93eb-a19cfe7a73a7.png)\r\n","Url":"https://github.com/dotnet/wpf/issues/3308","RelatedDescription":"Closed issue \"WPF tmpproj is excluding Microsoft.Net.Compilers.Toolset package \" (#3308)"},{"Id":"673636398","IsPullRequest":false,"CreatedAt":"2020-08-05T16:08:02","Actor":"indinfer","Number":"3306","RawContent":null,"Title":"DataGrid bound to List does not allow adding new rows","State":"closed","Body":"* .NET Core Version: 3.1\r\n* Windows version: Microsoft Windows 10 Pro Version 10.0.19041 Build 19041\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g., XAML Designer, Code editing, etc...)? No\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n\r\nI do not believe this is an actual defect. I hope to learn what I am missing or to understand the behavior.\r\n\r\n **Problem description:**\r\nI run a DataGrid with ItemsSource = a List<>.\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nI run the program. DataGrid allows deleting and changing rows. DataGrid does not allow adding rows.\r\n \r\n **Expected behavior:**\r\nDataGrid should allow adding rows.\r\n \r\n **Minimal repro:**\r\nXaml:\r\n`<Window\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n        xmlns:local=\"clr-namespace:myNamespace\"\r\n        xmlns:Schema=\"clr-namespace:System.Xml.Schema;assembly=System.Xml.ReaderWriter\" x:Class=\"myNamespace.MainWindow\"\r\n        mc:Ignorable=\"d\"\r\n        Title=\"MainWindow\" Height=\"350\" Width=\"600\">\r\n    <Grid>\r\n        <DataGrid x:Name=\"dataGrid\" AutoGenerateColumns=\"False\" CanUserAddRows=\"True\"   >\r\n            <DataGrid.Columns>\r\n                <DataGridTextColumn x:Name=\"col_id\" Width=\"200\" Header=\"Col ID\"  Binding=\"{Binding value_id}\" />\r\n                <DataGridTextColumn x:Name=\"col_1\" Width=\"200\" Header=\"Col One\"  Binding=\"{Binding value_1}\" />\r\n                <DataGridTextColumn x:Name=\"col_2\" Width=\"200\" Header=\"Col Two\"  Binding=\"{Binding value_2}\" />\r\n            </DataGrid.Columns>\r\n        </DataGrid>\r\n\r\n    </Grid>\r\n</Window>\r\n`\r\n\r\nCode Behind:\r\n`using System.Collections.Generic;\r\nusing System.Collections.ObjectModel;\r\nusing System.Windows;\r\n\r\nnamespace myNamespace\r\n{\r\n    /// <summary>\r\n    /// Interaction logic for MainWindow.xaml\r\n    /// </summary>\r\n    public partial class MainWindow : Window\r\n    {\r\n        public MainWindow()\r\n        {\r\n            InitializeComponent();\r\n\r\n            init_item_list();\r\n            dataGrid.ItemsSource = _itemList;\r\n        }\r\n\r\n\r\n        private List<DataItem> _itemList = new List<DataItem>();\r\n        public List<DataItem> ItemList\r\n        {\r\n            get { return _itemList; }\r\n            set { _itemList = value; }\r\n        }\r\n\r\n        public void init_item_list()\r\n        {\r\n            _itemList.Add(new DataItem(1, \"one\", \"i\"));\r\n            _itemList.Add(new DataItem(2, \"two\", \"ii\"));\r\n            _itemList.Add(new DataItem(3, \"three\", \"ii\"));\r\n        }\r\n        public class DataItem\r\n        {\r\n            public DataItem(int id, string val_1, string val_2)\r\n            {\r\n                value_id = id;\r\n                value_1 = val_1;\r\n                value_2 = val_2;\r\n            }\r\n            private int _value_id;\r\n            public int value_id\r\n            {\r\n                get { return _value_id; }\r\n                set { _value_id = value; }\r\n            }\r\n\r\n            private string _value_1;\r\n            public string value_1\r\n            {\r\n                get { return _value_1; }\r\n                set { _value_1 = value; }\r\n            }\r\n\r\n            private string _value_2;\r\n            public string value_2\r\n            {\r\n                get { return _value_2; }\r\n                set { _value_2 = value; }\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n}\r\n`\r\n\r\nHere is how it appears:\r\n\r\n![DataGrid bound to List](https://user-images.githubusercontent.com/8902149/89432421-19780a00-d70f-11ea-972c-4a1583ce015e.png)\r\n\r\nThere is no blank line for adding a new row.\r\n\r\nNote that in Xaml, I explicitly set `CanUserAddRows=\"True\"` \r\n\r\nI thought I saw DataGrid bound to a List allowing adding rows. But I need some help to see what the difference is between what I did before or what I saw before and the code I have in this post. \r\n\r\nHow do I get DataGrid bound to a List to allow adding rows?","Url":"https://github.com/dotnet/wpf/issues/3306","RelatedDescription":"Closed issue \"DataGrid bound to List does not allow adding new rows\" (#3306)"},{"Id":"673518906","IsPullRequest":true,"CreatedAt":"2020-08-05T13:12:10","Actor":"dotnet-maestro[bot]","Number":"3305","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200805.2\r\n- **Date Produced**: 8/5/2020 12:48 PM\r\n- **Commit**: 71d8cb94ba1614d788967d95d34855b92c09d3e6\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20404.2 to 5.0.0-preview.8.20405.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3305","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3305)"}],"ResultType":"GitHubIssue"}},"RunOn":"2020-08-14T05:30:52.6947383Z","RunDurationInMilliseconds":679}