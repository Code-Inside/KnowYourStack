{"Data":{"GitHub":{"Issues":[{"Id":"641593827","IsPullRequest":true,"CreatedAt":"2020-06-18T22:50:36","Actor":"wli3","Number":"3155","RawContent":null,"Title":"Muti target 5.0 second part","State":"open","Body":"","Url":"https://github.com/dotnet/wpf/pull/3155","RelatedDescription":"Open PR \"Muti target 5.0 second part\" (#3155)"},{"Id":"641206714","IsPullRequest":true,"CreatedAt":"2020-06-18T14:16:20","Actor":"dotnet-maestro[bot]","Number":"3154","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200618.2\r\n- **Date Produced**: 6/18/2020 1:08 PM\r\n- **Commit**: 28d4c610881934a5f101b00f145dd0e94fa37d36\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20317.2 to 5.0.0-preview.7.20318.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3154","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3154)"},{"Id":"641151446","IsPullRequest":true,"CreatedAt":"2020-06-18T12:03:12","Actor":"dotnet-maestro[bot]","Number":"3153","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"open","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 3a1d3bb6-c64d-406d-e8f4-08d648cf64cb\r\n- **Build**: 20200616.1\r\n- **Date Produced**: 6/16/2020 3:17 PM\r\n- **Commit**: 71b580038fb704df63e03c6b7ae7d2c6a4fdd71d\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.ApiCompat**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n  - **Microsoft.DotNet.Arcade.Sdk**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n  - **Microsoft.DotNet.CodeAnalysis**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n  - **Microsoft.DotNet.GenAPI**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n  - **Microsoft.DotNet.Helix.Sdk**: from 5.0.0-beta.20309.1 to 5.0.0-beta.20316.1\r\n- **Updates to .NET SDKs:**\r\n  - Updates sdk.version to 5.0.100-preview.6.20310.4\r\n  - Updates tools.dotnet to 5.0.100-preview.6.20310.4\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3153","RelatedDescription":"Open PR \"[master] Update dependencies from dotnet/arcade\" (#3153)"},{"Id":"640978170","IsPullRequest":false,"CreatedAt":"2020-06-18T07:32:06","Actor":"ryalanms","Number":"3152","RawContent":null,"Title":"XamlXmlWriter is including the namespace for each element","State":"open","Body":"* .NET Core Version: (e.g. 3.0 Preview1, or daily build number, use `dotnet --info`)\r\n\r\nPreview6.  Regression from Preview5.\r\n\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes/No\r\n\r\nNo.\r\n \r\n **Problem description:**\r\n \r\nXamlXmlWriter is including the namespace where it wasn't before.\r\n \r\n **Minimal repro:**\r\n\r\n```csharp\r\n            XamlSchemaContext xsc = new XamlSchemaContext();\r\n            var generated = new StringBuilder();\r\n            var xmlSettings = new XmlWriterSettings { Indent = true, OmitXmlDeclaration = true };\r\n\r\n            var hashSetAssemblyName = typeof(HashSet<List<BigContainer>>).GetAssemblyName();\r\n            var listAssemblyName = typeof(List<Dictionary<int, HashSet<List<BigContainer>>>>).GetAssemblyName();\r\n\r\n            using (XamlXmlWriter writer = new XamlXmlWriter(XmlWriter.Create(new StringWriter(generated), xmlSettings), xsc))\r\n            {\r\n                XamlType list = xsc.GetXamlType(typeof(List<Dictionary<int, HashSet<List<BigContainer>>>>));\r\n                var ns1 = $\"clr-namespace:System.Collections.Generic;assembly={hashSetAssemblyName}\";\r\n                var ns2 = \"clr-namespace:Test.Elements;assembly=XamlTestClasses\";\r\n                var ns3 = \"http://schemas.microsoft.com/winfx/2006/xaml\";\r\n                writer.WriteNamespace(new NamespaceDeclaration(ns1, \"a\"));\r\n                writer.WriteNamespace(new NamespaceDeclaration(ns2, \"b\"));\r\n                writer.WriteNamespace(new NamespaceDeclaration(ns3, \"c\"));\r\n                writer.WriteStartObject(list);\r\n                writer.WriteEndObject();\r\n            }\r\n\r\n\r\n            var expected = @\"<List c:TypeArguments=\"\"Dictionary(c:Int32, a:HashSet(List(b:BigContainer)))\"\" xmlns=\"\"clr-namespace:System.Collections.Generic;assembly={0}\"\" xmlns:a=\"\"clr-namespace:System.Collections.Generic;assembly={1}\"\" xmlns:b=\"\"clr-namespace:Test.Elements;assembly=XamlTestClasses\"\" xmlns:c=\"\"http://schemas.microsoft.com/winfx/2006/xaml\"\" />\";\r\n            expected = string.Format(expected, listAssemblyName, hashSetAssemblyName);\r\n\r\n            Assert.AreEqual(expected, generated.ToString());\r\n\r\n```\r\n\r\n\r\n```xml\r\n--\r\n  |   | - |   | \"<List c:TypeArguments=\\\"Dictionary(c:Int32, a:HashSet(List(b:BigContainer)))\\\" xmlns=\\\"clr-namespace:System.Collections.Generic;assembly=System.Private.CoreLib\\\" xmlns:a=\\\"clr-namespace:System.Collections.Generic;assembly=System.Private.CoreLib\\\" xmlns:b=\\\"clr-namespace:Test.Elements;assembly=XamlTestClasses\\\" xmlns:c=\\\"http://schemas.microsoft.com/winfx/2006/xaml\\\" />\"\\r\\n\r\n1 |   | + |   | {<a:List c:TypeArguments=\"a:Dictionary(c:Int32, a:HashSet(a:List(b:BigContainer)))\" xmlns:a=\"clr-namespace:System.Collections.Generic;assembly=System.Private.CoreLib\" xmlns:b=\"clr-namespace:Test.Elements;assembly=XamlTestClasses\" xmlns:c=\"http://schemas.microsoft.com/winfx/2006/xaml\" />}\r\nCOMMENTS:\r\n```\r\n","Url":"https://github.com/dotnet/wpf/issues/3152","RelatedDescription":"Open issue \"XamlXmlWriter is including the namespace for each element\" (#3152)"},{"Id":"640878927","IsPullRequest":false,"CreatedAt":"2020-06-18T03:29:21","Actor":"ShankarBUS","Number":"3151","RawContent":null,"Title":"Proposal: Add support for BorderMode in BlurEffect","State":"open","Body":"## Summary\r\nThe proposal is to add support for **`BorderMode`** in **BlurEffect**\r\n\r\nThis will enable blur effect to be more visually comforting and will enable UI designers to be even more creative.\r\n\r\n## Goal\r\nThe goal is to add an enum for **`BorderModes`** and a property called **`BorderMode`** in **BlurEffect** class (and internal work that I'm not aware of).\r\n\r\n## Rationale\r\nCurrently, **BlurEffect** pads extra pixels. Which is good for **UIElements** that are neither clipped nor stretched to fit parent.\r\nBut will look ugly when applied to **UIElements** which are either clipped or stretched to fit parent container\r\nSee this SO question : [Gaussian blur leads to white frame around image](https://stackoverflow.com/questions/6236054/gaussian-blur-leads-to-white-frame-around-image) to get an insight of my proposal.\r\n\r\n**In the image below the element is blurred and has extra padded pixels. It's ok in this case**\r\n\r\n![image](https://user-images.githubusercontent.com/63704247/84972230-0e0b5800-b13c-11ea-8fe3-cf1bcc1a9555.png)\r\n\r\n**But for cases like this where the element is either stretched to fill or clipped, it will have ugly transparent edges**\r\n\r\n![](https://i.stack.imgur.com/vDqBC.png)\r\n\r\nSo having an option to not pad extra pixel will be helpful in many cases\r\n\r\nUWP (Win2D?) has the said property see [GaussianBlurEffect.BorderMode](https://microsoft.github.io/Win2D/html/P_Microsoft_Graphics_Canvas_Effects_GaussianBlurEffect_BorderMode.htm)\r\n and also [Direct2D/GaussianBlur.BorderMode](https://docs.microsoft.com/en-us/windows/win32/direct2d/gaussian-blur#border-modes)\r\n\r\n## Proposed API\r\n\r\nThe same API found in Win2D's GaussianBlurEffect can be used.\r\n\r\n```cs\r\n// Enumeration type that specifies how to process pixels that lie outside the input image.\r\npublic enum EffectBorderMode\r\n{\r\n    // Pixels outside the input image are treated as transparent black, resulting in a soft edge after processing.\r\n    Soft = 0, // Default\r\n    // The effect clamps to the size of the input image.\r\n    Hard = 1\r\n}\r\n```\r\n\r\nand in BlurEffect.cs\r\n\r\n```cs\r\n// Gets and sets border mode for edge pixels.\r\npublic EffectBorderMode BorderMode { get; set; }\r\n```\r\n\r\n## Extra Info\r\n_I'm a new comer to WPF and not well introduced to **Open-Source workflow**.\r\nIf I there are any mistakes in this proposal, please correct me._\r\n\r\nOne thing that bothers me is that it's been 13 years since WPF's release and I can't find any issue proposing to change this behavior. **Is it because this can't be implemented or no one asked for it?**\r\n\r\nAt this point I'm too afraid to ask this, since WPF is on maintenance mode and we are forced towards WinUI for a stable future.\r\nI love WPF and people like me will be so pleased if WPF can be improved with much more features.\r\n\r\n## Open questions\r\n- Is this even feasible?\r\n- What will be the difficulty of implementation?\r\n- Is this out of scope?\r\n- Do you devs still plan on adding new features?\r\n- If it the implementation process is feasible, will you consider implementing it?\r\n- Doesn't WPF and UWP both use DirectX for rendering? Then is it possible?","Url":"https://github.com/dotnet/wpf/issues/3151","RelatedDescription":"Open issue \"Proposal: Add support for BorderMode in BlurEffect\" (#3151)"},{"Id":"640434842","IsPullRequest":true,"CreatedAt":"2020-06-17T13:37:19","Actor":"dotnet-maestro[bot]","Number":"3150","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200617.2\r\n- **Date Produced**: 6/17/2020 1:05 PM\r\n- **Commit**: f56b2b1f6d7c186fd8badcc555f88032938468b7\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20316.2 to 5.0.0-preview.7.20317.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3150","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3150)"},{"Id":"639830811","IsPullRequest":false,"CreatedAt":"2020-06-16T17:01:20","Actor":"taoyue","Number":"3149","RawContent":null,"Title":"OriginalSource is wrong when command is invoked on a ListBoxItem by key gesture","State":"open","Body":"* .NET Core Version: 3.1\r\n* Windows version: Windows 10 version 2004\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\nProblem description\r\n===================\r\n\r\nWhen a ``ContextMenu`` is attached to a ``ListBoxItem``, commands can be invoked through the context menu itself or by using a key gesture.  Depending on how the command is invoked, the ``Executed`` event handler gets different values for ``ExecutedRoutedEventArgs.OriginalSource``:\r\n\r\n **Actual behavior:**\r\n* When the command is invoked through the context menu, ``OriginalSource`` is the ``ListBoxItem``.\r\n* When the command is invoked by the key gesture, ``OriginalSource`` is the ``ListBox`` instead of the ``ListBoxItem``.  Since the ``Source`` and the ``sender`` are also the ``ListBox``, the event handler never gets the ``ListBoxItem`` that the command was invoked on.\r\n\r\n **Expected behavior:**\r\n* No matter how the command is invoked, ``OriginalSource`` should always be the ``ListBoxItem``.\r\n\r\nMinimal repro\r\n=============\r\n\r\nXAML:\r\n```XAML\r\n<ListBox Name=\"CommandsListBox\" ItemsSource=\"{Binding Path=., Mode=OneWay}\">\r\n    <ListBox.CommandBindings>\r\n        <CommandBinding Command=\"ApplicationCommands.Properties\" Executed=\"Properties_Executed\"/>\r\n    </ListBox.CommandBindings>\r\n    <ListBox.Resources>\r\n        <ContextMenu x:Key=\"CommandsContextMenu\">\r\n            <MenuItem Header=\"Properties\" Command=\"ApplicationCommands.Properties\"/>\r\n        </ContextMenu>\r\n        <Style TargetType=\"ListBoxItem\">\r\n            <Setter Property=\"ContextMenu\" Value=\"{StaticResource CommandsContextMenu}\"/>\r\n        </Style>\r\n    </ListBox.Resources>\r\n</ListBox>\r\n```\r\n\r\nCode-behind:\r\n```C#\r\npublic MainWindow()\r\n{\r\n    InitializeComponent();\r\n\r\n    var items = new ObservableCollection<string> { \"Item 1\", \"Item 2\", \"Item 3\" };\r\n    CommandsListBox.DataContext = items;\r\n}\r\n\r\nprivate void Properties_Executed(object sender, ExecutedRoutedEventArgs e)\r\n{\r\n    Debug.WriteLine($\"sender = {sender.GetType().Name}, e.Source = {e.Source.GetType().Name}, e.OriginalSource = {e.OriginalSource.GetType().Name}\");\r\n}\r\n```\r\n\r\nTry both invocation methods to see the different values of ``e.OriginalSource``:\r\n\r\n  1. Right-click a list box item, and select Properties from the context menu.\r\n  2. Select a list box item, and press the F4 key.\r\n\r\nThe ``Properties_Executed`` event handler will write the types to the debug output:\r\n\r\n```\r\nsender = ListBox, e.Source = ListBox, e.OriginalSource = ListBoxItem\r\nsender = ListBox, e.Source = ListBox, e.OriginalSource = ListBox\r\n```\r\n\r\nCause of bug\r\n============\r\n\r\nWhen an accelerator key is pressed, the ``KeyEventArgs.OriginalSource`` actually starts out with the correct value of the ``ListBoxItem``.  However, this is lost because ``CommandManager.ExecuteCommand`` throws away ``inputEventArgs`` when it calls ``RoutedCommand.ExecuteCore``.\r\n\r\nWhen ``RoutedCommand.ExecuteImpl`` creates the ``ExecutedRoutedEventArgs``, it uses ``target`` as the source of the event.  But the ``target`` parameter comes from ``CommandManager.TranslateInput``, which sets it to the ``ListBox``.\r\n\r\nCommandManager.cs:\r\n```C#\r\n459  // We currently do not support declaring the element with focus as the target\r\n460  // element by setting target == null.  Instead, we interpret a null target to indicate\r\n461  // the element that we are routing the event through, e.g. the targetElement parameter.\r\n462  if (target == null)\r\n463  {\r\n464      target = targetElement;\r\n465  }\r\n```\r\n\r\nThe comment implies that this is a TODO that was never done.  It also says that the correct behavior is to set the focused element (``ListBoxItem``) as the target.  This is what the context menu is already doing.\r\n\r\nContext menu codepath\r\n=====================\r\n\r\nWhen the user selects the context menu item, ``RoutedCommand.ExecuteImpl`` is called for the first time with the ``MenuItem`` as the ``target``.  But the developer can't do anything with a ``MenuItem``, so WPF takes additional steps to find a more semantically useful element.  ``CommandManager.OnExecuted`` transfers the event to the parent scope's focused element, which is the ``ListBoxItem``.\r\n\r\nCommandManager.cs:\r\n```C#\r\n556  // This element is a focus scope.\r\n557  // Try to transfer the event to its parent focus scope's focused element.\r\n558  IInputElement focusedElement = GetParentScopeFocusedElement(d);\r\n559  if (focusedElement != null)\r\n560  {\r\n561      TransferEvent(focusedElement, e);\r\n562  }\r\n```","Url":"https://github.com/dotnet/wpf/issues/3149","RelatedDescription":"Open issue \"OriginalSource is wrong when command is invoked on a ListBoxItem by key gesture\" (#3149)"},{"Id":"639650102","IsPullRequest":true,"CreatedAt":"2020-06-16T13:32:27","Actor":"dotnet-maestro[bot]","Number":"3148","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200616.2\r\n- **Date Produced**: 6/16/2020 12:59 PM\r\n- **Commit**: 0e79517a9c55617df6db21ecc5d455d5cbea83dd\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20315.2 to 5.0.0-preview.7.20316.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3148","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3148)"},{"Id":"639366916","IsPullRequest":false,"CreatedAt":"2020-06-16T04:48:35","Actor":"lindexi","Number":"3147","RawContent":null,"Title":"The main thread of the WPF application that starts automatically at boot will forever wait for the touch thread to execute","State":"open","Body":"* .NET Core Version:3.1.300\r\n* Windows version: 10.0.18362\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\n **Problem description:**\r\n\r\nThe WPF application does not show the main window.\r\n\r\nBecause the main thread is waiting for the logic execution of the Stylus Input thread.\r\n\r\n![](http://image.acmx.xyz/lindexi%2F20206161131494577.jpg)\r\n\r\nThe main thread execution waiting method is [PresentationCore.dll! System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() ](https://github.com/dotnet/wpf/blob/08dc7bcdecb27ab25d279d0b9d05f35393852ae9/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThreadWorker.cs#L574)\r\n\r\nhttps://github.com/dotnet/wpf/blob/08dc7bcdecb27ab25d279d0b9d05f35393852ae9/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThreadWorker.cs#L574-L592\r\n\r\n![](http://image.acmx.xyz/lindexi%2F2020616114732306.jpg)\r\n\r\n![](http://image.acmx.xyz/lindexi%2F20206161149181309.jpg)\r\n\r\nWhat is the Stylus Input thread doing at this time? It is waiting for touch input\r\n\r\n![](http://image.acmx.xyz/lindexi%2F20206161154445424.jpg)\r\n\r\nSo the main thread cannot wait for the execution of the Stylus Input thread to complete, the main thread will always wait\r\n\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n\r\nThe main thread callstack \r\n\r\n\r\n```\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tmscorlib.dll!System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext) (IL≈0x0014, Native=0x6EC56B10+0x21)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne(int millisecondsTimeout, bool exitContext) (IL≈0x0000, Native=0x6EC56AD0+0x28)\r\n \tmscorlib.dll!System.Threading.WaitHandle.WaitOne() (IL=epilog, Native=0x6EC56AB0+0x12)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.WorkerGetTabletsInfo() (IL≈0x002F, Native=0x6C420C30+0xBE)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL=epilog, Native=0x6C439AB8+0x64)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.OnDeviceChange() (IL≈0x000F, Native=0x6C3E9830+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.HandleMessage(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x004C, Native=0x6C3E85C0+0x73)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.InvalidateTabletDevices(MS.Internal.Interop.WindowMessage msg, System.IntPtr wParam, System.IntPtr lParam) (IL=epilog, Native=0x6B3EA58C+0x9D)\r\n \tPresentationFramework.dll!System.Windows.SystemResources.SystemThemeFilterMessage(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0094, Native=0x6AC6FC60+0x96)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherSynchronizationContext.Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6C9DB400+0x23)\r\n \tmscorlib.dll!System.Threading.SynchronizationContext.InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) (IL=epilog, Native=0x6EC55D30+0x14)\r\n \tPresentationCore.dll!MS.Win32.Penimc.UnsafeNativeMethods.CreatePimcManager() (IL=0x0022, Native=0x6C422318+0x53)\r\n \tPresentationCore.dll!MS.Win32.Penimc.UnsafeNativeMethods.UnsafeNativeMethods() (IL=prolog, Native=0x6C422288+0x21)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadWorker.PenThreadWorker() (IL≈0x004C, Native=0x6C42080C+0xCB)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadPool.GetPenThreadForPenContextHelper(System.Windows.Input.PenContext penContext) (IL≈0x005B, Native=0x6C42067C+0xE5)\r\n \tPresentationCore.dll!System.Windows.Input.PenThreadPool.GetPenThreadForPenContext(System.Windows.Input.PenContext penContext) (IL=epilog, Native=0x6C4205A8+0x84)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTabletsImpl() (IL≈0x0009, Native=0x6C439AB8+0x2D)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.UpdateTablets() (IL=0x0042, Native=0x6C439A24+0x5A)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispTabletDeviceCollection.WispTabletDeviceCollection() (IL≈0x003D, Native=0x6BF31B38+0xC2)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.WispTabletDevices.get() (IL=0x000E, Native=0x6BF5DF4C+0x20)\r\n \tPresentationCore.dll!System.Windows.Input.StylusWisp.WispLogic.RegisterHwndForInput(System.Windows.Input.InputManager inputManager, System.Windows.PresentationSource inputSource) (IL≈0x0032, Native=0x6BF5DD50+0x8F)\r\n \tPresentationCore.dll!System.Windows.Interop.HwndStylusInputProvider.HwndStylusInputProvider(System.Windows.Interop.HwndSource source) (IL=0x005A, Native=0x6BF5DBCC+0xF8)\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.Initialize(System.Windows.Interop.HwndSourceParameters parameters) (IL=0x0253, Native=0x6BF5C4C8+0x433)\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindow(bool duringShow) (IL=0x0082, Native=0x6AC1C0F4+0x1E0)\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindowDuringShow() (IL=epilog, Native=0x6ACBB474+0xF)\r\n \tPresentationFramework.dll!System.Windows.Window.SafeCreateWindowDuringShow() (IL=epilog, Native=0x6AC1D7B4+0x41)\r\n \tPresentationFramework.dll!System.Windows.Window.ShowHelper(object booleanBox) (IL=0x003B, Native=0x6AC1D644+0x78)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl() (IL≈0x007A, Native=0x6C9DE6D0+0xD2)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state) (IL=epilog, Native=0x6C9DE690+0x3C)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL≈0x0079, Native=0x6EC82DC0+0xE5)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL=epilog, Native=0x6EC82DA0+0x16)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state) (IL=epilog, Native=0x6EC82D30+0x41)\r\n \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext executionContext, System.Threading.ContextCallback callback, object state) (IL=epilog, Native=0x6C9DE480+0x63)\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke() (IL=0x0020, Native=0x6C9DE340+0x4E)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue() (IL=0x00F6, Native=0x6C9DA870+0x165)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL=0x0090, Native=0x6C9DAB70+0x5A)\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) (IL≈0x0030, Native=0x6C9DC1F0+0x9B)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) (IL≈0x0036, Native=0x6C9DC170+0x6B)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) (IL≈0x0077, Native=0x6C9DC010+0x52)\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler) (IL≈0x0002, Native=0x6C9DBF70+0x34)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) (IL≈0x00BB, Native=0x6C9DA450+0x131)\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) (IL=0x0130, Native=0x6C9DB9C0+0xEE)\r\n \t[ToNative]\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame) (IL≈0x0040, Native=0x6C9D84CC+0xB1)\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame) (IL=epilog, Native=0x6C9D8124+0x4A)\r\n \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore) (IL=0x0024, Native=0x6ABF4E70+0x5A)\r\n \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window) (IL=0x00EE, Native=0x6ABF4CEC+0x74)\r\n \tPresentationFramework.dll!System.Windows.Application.Run(System.Windows.Window window) (IL=epilog, Native=0x6ABF4ADC+0x2B)\r\n \tPresentationFramework.dll!System.Windows.Application.Run() (IL=epilog, Native=0x6ABF46C8+0x1C)\r\n \tLindexi.WPF.exe!Lindexi.Program.Initialize() (IL≈0x000E, Native=0x0592A0A0+0x54)\r\n \tLindexi.WPF.exe!Lindexi.Program.Main(string[] args) (IL=0x001C, Native=0x00DF0448+0x42)\r\n```\r\n\r\nThe Stylus Input thread callstack \r\n \r\n```\r\n>\tPresentationCore.dll!System.Windows.Input.PenThreadWorker.ThreadProc() (IL≈0x00AF, Native=0x6C421E44+0x176)\r\n \tmscorlib.dll!System.Threading.ThreadHelper.ThreadStart_Context(object state) (IL=epilog, Native=0x6EC56060+0x9D)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL≈0x0079, Native=0x6EC82DC0+0xE5)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL=epilog, Native=0x6EC82DA0+0x16)\r\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state) (IL=epilog, Native=0x6EC82D30+0x41)\r\n \tmscorlib.dll!System.Threading.ThreadHelper.ThreadStart() (IL=epilog, Native=0x6EC56014+0x44)\r\n```\r\n\r\n\r\n **Expected behavior:**\r\n\r\nThe main thread will not wait for the Stylus Input thread all the time\r\n \r\n **Minimal repro:**\r\n\r\nThe empty WPF application and set the WPF application starts automatically at boot. After the device is started, the touch screen HID device will be connected.\r\n\r\nI tested it hundreds of times and it appeared once. This seems to be part of the WPF touch thread processing problem.\r\n\r\nRelated issues:\r\n\r\nhttps://github.com/dotnet/wpf/issues/78\r\n\r\nhttps://github.com/dotnet/wpf/issues/928\r\n\r\nhttps://github.com/Microsoft/dotnet/issues/480\r\n\r\nhttps://github.com/dotnet/wpf/issues/2054\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/3147","RelatedDescription":"Open issue \"The main thread of the WPF application that starts automatically at boot will forever wait for the touch thread to execute\" (#3147)"},{"Id":"637783246","IsPullRequest":false,"CreatedAt":"2020-06-15T17:57:53","Actor":"Noemata","Number":"3134","RawContent":null,"Title":"Permission to publish Surface SDK source code.","State":"closed","Body":"As mentioned here: https://github.com/dotnet/wpf/issues/118\r\n\r\nI would like to get permission to publish the reverse engineered source code for the WPF Surface SDK.  A lot of very valuable code is currently out of reach that would be very beneficial to the WPF user community.\r\n\r\nCan someone from Microsoft please provide some sort of legal waver for this?  It's a much better starting point than nothing.","Url":"https://github.com/dotnet/wpf/issues/3134","RelatedDescription":"Closed issue \"Permission to publish Surface SDK source code.\" (#3134)"},{"Id":"639010396","IsPullRequest":false,"CreatedAt":"2020-06-15T17:14:05","Actor":"vsfeedback","Number":"3146","RawContent":null,"Title":"Crashed during debugging","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/967201/crashed-during-debugging.html)._\n\n---\nI left the debugger running a long-running process.  I was working from home. I returned to my remote machine and remote desktop was frozen. I restarted remote desktop. When the remote desktop came up, visual studio crashed. I don't know what state the debugger was in; possibly at a breakpoint.\n\nI had ProcDump installed as the post-mortem debugger; the crash dump from ProcDump is attached.\n\n---\n### Original Comments\n\n#### Visual Studio Feedback System on 3/29/2020, 08:10 PM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/3146","RelatedDescription":"Open issue \"Crashed during debugging\" (#3146)"},{"Id":"638895711","IsPullRequest":false,"CreatedAt":"2020-06-15T14:23:37","Actor":"lindexi","Number":"3145","RawContent":null,"Title":"WPF can not receive the touch message when set WS_EX_TRANSPARENT to window","State":"open","Body":"* .NET Core Version: 3.1.300\r\n* Windows version: 10.0.18362\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\n\r\nWPF can not receive the touch message when set WS_EX_TRANSPARENT to window\r\n\r\nWe can create an empty WPF application, and then we can output message when we receive the mouse down and touch down event\r\n\r\nBut when we set the WS_EX_TRANSPARENT property to the window, that we can find that we can only receive the mouse event and can not receive the touch event\r\n\r\n```csharp\r\n        private void MainWindow_Loaded(object sender, RoutedEventArgs e)\r\n        {\r\n            IntPtr hwnd = new WindowInteropHelper(this).Handle;\r\n            var extendedStyle = GetWindowLong(hwnd, GWL_EXSTYLE);\r\n            SetWindowLong(hwnd, GWL_EXSTYLE, extendedStyle | WS_EX_TRANSPARENT);\r\n        }\r\n```\r\n \r\n **Actual behavior:**\r\n\r\nWe can not receive the touch event and we only receive the mouse event\r\n \r\n **Expected behavior:**\r\n\r\nWe can receive the touch event just like the mouse behavior\r\n \r\n **Minimal repro:**\r\n\r\nhttps://github.com/dotnet-campus/wpf-issues/tree/master/CanNotReceiveTouchMessageWS_EX_TRANSPARENT","Url":"https://github.com/dotnet/wpf/issues/3145","RelatedDescription":"Open issue \"WPF can not receive the touch message when set WS_EX_TRANSPARENT to window\" (#3145)"},{"Id":"638849876","IsPullRequest":true,"CreatedAt":"2020-06-15T13:37:32","Actor":"dotnet-maestro[bot]","Number":"3144","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200615.2\r\n- **Date Produced**: 6/15/2020 1:04 PM\r\n- **Commit**: 516f44ef4edadb3991c3fe7b820de0febff40d7f\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20314.2 to 5.0.0-preview.7.20315.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3144","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3144)"},{"Id":"638718572","IsPullRequest":false,"CreatedAt":"2020-06-15T10:03:25","Actor":"prranja23","Number":"3143","RawContent":null,"Title":".NET applications are crashing after the MCF application sets the FontWeight and FontType","State":"open","Body":".NET applications are crashing after the MCF application sets the FontWeight and FontType using the below code :\r\nSystemParamerterInfo(SPI_SETNONCLIENTMETRICS,0,&ncm,0)\r\n\r\n**Workaround :**\r\nThe simple workaround is for the C++ application to ensure it is setting the font weight between 1 and 999 prior to calling SystemParametersInfo(SPI_SETNONCLIENTMETRICS). Use FW_NORMAL (400) instead of FW_DONTCARE (0). The C++ application should also be at least system DPI aware if the application will be running on systems with the DPI scale >= 150%.\r\n\r\n**Repro Code :**\r\n1. We need to first run the C++ application and then try running the WPF application to reproduce the issue.\r\n2. We tried creating a simple WPF application, using the following XAML for the main window:\r\n```\r\n<Window x:Class=\"WpfApp1.MainWindow\"\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n        xmlns:local=\"clr-namespace:WpfApp1\"\r\n        mc:Ignorable=\"d\"\r\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\r\n        <Grid>\r\n            <RichTextBox>\r\n                <FlowDocument>\r\n                    <Table>\r\n                        <TableRowGroup>\r\n                            <TableRow>\r\n                                <TableCell>\r\n                                    <Paragraph>\r\n                                        <Run>Paragraph in a Table Cell.</Run>\r\n                                    </Paragraph>\r\n                                </TableCell>\r\n                            </TableRow>\r\n                        </TableRowGroup>\r\n                    </Table>\r\n                </FlowDocument>\r\n            </RichTextBox>\r\n        </Grid>\r\n    </Window>\r\n```\r\n3. We then created a small C++ console application that does the following:\r\n```\r\nint wmain()\r\n{\r\n    NONCLIENTMETRICSW ncm = {};\r\n    ncm.cbSize = sizeof(NONCLIENTMETRICSW);\r\n \r\n    BOOL fResult = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);\r\n    if (fResult)\r\n    {\r\n        LONG lfWeightPrev = ncm.lfMessageFont.lfWeight;\r\n        ncm.lfMessageFont.lfWeight = 0; // FW_DONTCARE\r\n \r\n        fResult = SystemParametersInfo(SPI_SETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);\r\n        if (fResult)\r\n        {\r\n            _getwch();\r\n            ncm.lfMessageFont.lfWeight = lfWeightPrev;\r\n            fResult = SystemParametersInfo(SPI_SETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);\r\n        }\r\n    }\r\n    return GetLastError();\r\n}\r\n```\r\n\r\n 4. We are able to reproduce the crash when running the WPF application. \r\n\r\n**Expected Results :**\r\n1. The WPF application should work fine.\r\n\r\n**Actual Results :**\r\n1. The WPF application crashes with below exception :\r\n0:000> !PrintException /d 02bc06c0\r\nException object: 02bc06c0\r\nException type:   System.ArgumentOutOfRangeException\r\nMessage:          The parameter value must be between '1' and '999'.\r\nInnerException:   <none>\r\nStackTrace (generated):\r\n    SP       IP       Function\r\n    00AFDE78 68CD472B PresentationCore_ni!System.Windows.FontWeight.FromOpenTypeWeight(Int32)+0x7d272b\r\n    00AFDE8C 5615BE6A PresentationFramework_ni!System.Windows.Documents.TextElement..cctor()+0x192\r\n","Url":"https://github.com/dotnet/wpf/issues/3143","RelatedDescription":"Open issue \".NET applications are crashing after the MCF application sets the FontWeight and FontType\" (#3143)"},{"Id":"638436011","IsPullRequest":false,"CreatedAt":"2020-06-14T21:41:25","Actor":"NickeManarin","Number":"3142","RawContent":null,"Title":"Not enough quota when opening Window","State":"open","Body":"After updating my WPF app from 4.6.1 to 4.8, users started getting this exception (multiple times in a row) when opening windows:\r\n\r\n```\r\n• Message - \r\n    Not enough quota is available to process this command\r\n• Type - \r\n    System.ComponentModel.Win32Exception\r\n• Source - \r\n    PresentationCore\r\n• TargetSite - \r\n    Void UpdateWindowSettings(Boolean, System.Nullable`1[System.Windows.Media.Composition.DUCE+ChannelSet])\r\n• StackTrace - \r\n   at System.Windows.Interop.HwndTarget.UpdateWindowSettings(Boolean enableRenderTarget, Nullable`1 channelSet)\r\n   at System.Windows.Interop.HwndTarget.UpdateWindowPos(IntPtr lParam)\r\n   at System.Windows.Interop.HwndTarget.HandleMessage(WindowMessage msg, IntPtr wparam, IntPtr lparam)\r\n   at System.Windows.Interop.HwndSource.HwndTargetFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean& handled)\r\n   at MS.Win32.HwndWrapper.WndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean& handled)\r\n   at MS.Win32.HwndSubclass.DispatcherCallbackOperation(Object o)\r\n   at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs)\r\n   at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Int32 numArgs, Delegate catchHandler)\r\n```\r\nUnfortunately, I could not get this exception on my machine, so I can't really understand what's happening.\r\n\r\nI already tried setting `HandleDispatcherRequestProcessingFailureOptions.Reset`, but people are still reporting crashes to me.\r\n\r\nWhat could possibly be happening? Is there any way to fix this or maybe set an workaround?","Url":"https://github.com/dotnet/wpf/issues/3142","RelatedDescription":"Open issue \"Not enough quota when opening Window\" (#3142)"},{"Id":"638348759","IsPullRequest":true,"CreatedAt":"2020-06-14T13:14:53","Actor":"dotnet-maestro[bot]","Number":"3141","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200614.2\r\n- **Date Produced**: 6/14/2020 12:58 PM\r\n- **Commit**: b5107a331887d766dffc0ad0b86cf462da86c44d\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20313.2 to 5.0.0-preview.7.20314.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3141","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3141)"},{"Id":"638344051","IsPullRequest":false,"CreatedAt":"2020-06-14T12:36:25","Actor":"ice1e0","Number":"3140","RawContent":null,"Title":"SelectedItems property on DataGrid","State":"open","Body":"The DataGrid has a property SelectedItems property which can not be used in WPF like 'SelectedItem' because it has no dependency property. I would love to see this be added to WPF.\r\n\r\nSee as well: https://stackoverflow.com/questions/9880589/bind-to-selecteditems-from-datagrid-or-listbox-in-mvvm\r\nHere the DataGrid is used with SelectionMode \"Extended\" and using SelectionUnit=\"FullRow\" --> with this configuration I think there should be no issue adding this functionality.\r\n\r\nHere a raw template for a simple extension (only supporting to read the 'SelectedItems' property):\r\n\r\n``` c#\r\npublic class CustomDataGrid : DataGrid\r\n{\r\n        public static readonly DependencyProperty SelectedItemsProperty = DependencyProperty.Register(nameof(SelectedItems), typeof(IList), typeof(CustomDataGrid), new PropertyMetadata(default(IList), OnSelectedItemsPropertyChanged));\r\n\r\n        protected override void OnSelectionChanged(SelectionChangedEventArgs e)\r\n        {\r\n            base.OnSelectionChanged(e);\r\n            SetValue(SelectedItemsProperty, base.SelectedItems);\r\n        }\r\n\r\n        public new IList SelectedItems\r\n        {\r\n            get => (IList)GetValue(SelectedItemsProperty);\r\n            set => throw new Exception(\"This property is read-only. To bind to it you must use 'Mode=OneWayToSource'.\");\r\n        }\r\n\r\n        private static void OnSelectedItemsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\r\n        {\r\n            ((CustomDataGrid)d).OnSelectedItemsChanged((IList)e.OldValue, (IList)e.NewValue);\r\n        }\r\n\r\n        protected virtual void OnSelectedItemsChanged(IList oldSelectedItems, IList newSelectedItems)\r\n        {\r\n        }\r\n}\r\n```","Url":"https://github.com/dotnet/wpf/issues/3140","RelatedDescription":"Open issue \"SelectedItems property on DataGrid\" (#3140)"},{"Id":"638308276","IsPullRequest":true,"CreatedAt":"2020-06-14T08:28:14","Actor":"sdcarterchen","Number":"3139","RawContent":null,"Title":"111","State":"open","Body":"","Url":"https://github.com/dotnet/wpf/pull/3139","RelatedDescription":"Open PR \"111\" (#3139)"},{"Id":"638234683","IsPullRequest":false,"CreatedAt":"2020-06-13T21:14:26","Actor":"miloush","Number":"3138","RawContent":null,"Title":"No permission to delete temporary files leads to crash on load","State":"open","Body":"* .NET Core Version: 3.1.400-preview-015151\r\n* Windows version: 10.0.19619.1000\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n\r\n **Problem description:**\r\n\r\nWhen WPF app does not have delete permission to the temp directory, loading XAML with Cursor property set crashes the app on load.\r\n \r\n **Actual behavior:** \r\n\r\n```\r\nSystem.Windows.Markup.XamlParseException: Provide value on 'System.Windows.Baml2006.TypeConverterMarkupExtension' threw an exception. ---> System.UnauthorizedAccessException: Access to the path 'C:\\Users\\User\\AppData\\Local\\Temp\\WPF\\o4fqaecx.33n' is denied.\r\n   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)\r\n   at System.IO.File.InternalDelete(String path, Boolean checkHost)\r\n   at System.IO.FileHelper.DeleteTemporaryFile(String filePath)\r\n   at System.Windows.Input.Cursor.LoadFromStream(Stream cursorStream)\r\n   at System.Windows.Input.CursorConverter.ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, Object value)\r\n   at MS.Internal.Xaml.Runtime.ClrObjectRuntime.CallProvideValue(MarkupExtension me, IServiceProvider serviceProvider)\r\n   --- End of inner exception stack trace ---\r\n   at System.Windows.Markup.XamlReader.RewrapException(Exception e, IXamlLineInfo lineInfo, Uri baseUri)\r\n   at System.Windows.Markup.WpfXamlLoader.Load(XamlReader xamlReader, IXamlObjectWriterFactory writerFactory, Boolean skipJournaledProperties, Object rootObject, XamlObjectWriterSettings settings, Uri baseUri)\r\n   at System.Windows.ResourceDictionary.CreateObject(KeyRecord key)\r\n   at System.Windows.ResourceDictionary.OnGettingValue(Object key, Object& value, Boolean& canCache)\r\n   at System.Windows.ResourceDictionary.OnGettingValuePrivate(Object key, Object& value, Boolean& canCache)\r\n   at System.Windows.ResourceDictionary.GetValueWithoutLock(Object key, Boolean& canCache)\r\n   at System.Windows.ResourceDictionary.GetValue(Object key, Boolean& canCache)\r\n   at System.Windows.SystemResources.LookupResourceInDictionary(ResourceDictionary dictionary, Object key, Boolean allowDeferredResourceReference, Boolean mustReturnDeferredResourceReference, Boolean& canCache)\r\n   at System.Windows.SystemResources.FindDictionaryResource(Object key, Type typeKey, ResourceKey resourceKey, Boolean isTraceEnabled, Boolean allowDeferredResourceReference, Boolean mustReturnDeferredResourceReference, Boolean& canCache)\r\n   at System.Windows.SystemResources.FindResourceInternal(Object key, Boolean allowDeferredResourceReference, Boolean mustReturnDeferredResourceReference)\r\n   at System.Windows.StyleHelper.GetThemeStyle(FrameworkElement fe, FrameworkContentElement fce)\r\n   at System.Windows.FrameworkElement.UpdateThemeStyleProperty()\r\n   at System.Windows.FrameworkElement.OnInitialized(EventArgs e)\r\n   at System.Windows.FrameworkElement.TryFireInitialized()\r\n   at System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject oldParent)\r\n   at System.Windows.Media.Visual.FireOnVisualParentChanged(DependencyObject oldParent)\r\n   at System.Windows.Media.Visual.AddVisualChild(Visual child)\r\n   at System.Windows.Media.VisualCollection.ConnectChild(Int32 index, Visual value)\r\n   at System.Windows.Media.VisualCollection.Add(Visual visual)\r\n   at System.Windows.Controls.UIElementCollection.AddInternal(UIElement element)\r\n   at System.Windows.Controls.Panel.GenerateChildren()\r\n   at System.Windows.Controls.Panel.EnsureGenerator()\r\n   at System.Windows.Controls.Panel.get_InternalChildren()\r\n   at System.Windows.Controls.StackPanel.StackMeasureHelper(IStackMeasure measureElement, IStackMeasureScrollData scrollData, Size constraint)\r\n ...\r\n   at System.Windows.UIElement.Measure(Size availableSize)\r\n   at System.Windows.Interop.HwndSource.SetLayoutSize()\r\n   at System.Windows.Interop.HwndSource.set_RootVisualInternal(Visual value)\r\n   at System.Windows.Window.SetRootVisual()\r\n   at System.Windows.Window.SetRootVisualAndUpdateSTC()\r\n   at System.Windows.Window.SetupInitialState(Double requestedTop, Double requestedLeft, Double requestedWidth, Double requestedHeight)\r\n   at System.Windows.Window.CreateSourceWindow(Boolean duringShow)\r\n   at System.Windows.Window.ShowHelper(Object booleanBox)\r\n```\r\n \r\n **Expected behavior:**\r\n\r\nLeave the file behind with no crash, like in the case when it is being used by another process, i.e. `System.IO.FileHelper.DeleteTemporaryFile` should not only catch `IOException` but also `UnauthorizedAccessException`.\r\n","Url":"https://github.com/dotnet/wpf/issues/3138","RelatedDescription":"Open issue \"No permission to delete temporary files leads to crash on load\" (#3138)"},{"Id":"638172959","IsPullRequest":false,"CreatedAt":"2020-06-13T14:36:36","Actor":"MaciekSwiszczowski","Number":"3137","RawContent":null,"Title":"Non-string x:Key ignored on DataTemplate, when DataType set.","State":"open","Body":"* .NET Core Version: 5.0.100-preview.1.20155.7\r\n* Windows version: Windows 10.0.18363\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio? No.\r\n \r\n **Problem description:**\r\nAccording to docs, x:Key can be set to whatever markup extension returns.\r\nThis however is not a truth.\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n\r\n If there is a resource dictionary with the following 2 lines:\r\n```\r\n    <DataTemplate DataType=\"{x:Type local:ViewModel}\" />\r\n    <DataTemplate DataType=\"{x:Type local:ViewModel}\" x:Key=\"{x:Static local:ResourceKeys.AKey}\" />\r\n```\r\n(where `local:ResourceKeys` is an enum.)\r\n\r\nThese lines will cause an exception: `ArgumentException: Item has already been added. Key in dictionary: 'DataTemplateKey(Framework.ViewModel)'  Key being added: 'DataTemplateKey(Framework.ViewModel)'`\r\n\r\nConsider also the following lines being read in a resource dictionary:\r\n```\r\n    <DataTemplate DataType=\"{x:Type core:ViewModel}\" x:Key=\"{x:Static core:ResourceKeys.AKey}\" />\r\n    <DataTemplate x:Key=\"{x:Static core:ResourceKeys.TheOtherKey}\" />\r\n    <DataTemplate DataType=\"{x:Type core:TheOtherViewModel}\" x:Key=\"TheOtherKey\" />\r\n```\r\nIf later in the application you'll try to find these resources in code-behind:\r\n```\r\nvar theOtherKeyDataTemplateByEnum = Application.Current.TryFindResource(ResourceKeys.TheOtherKey);\r\nvar theOtherKeyDataTemplateByString = Application.Current.TryFindResource(\"TheOtherKey\");\r\nvar dataTemplateByEnumKeyAndWithDataType = Application.Current.TryFindResource(ResourceKeys.AKey);\r\n```\r\nThen `theOtherKeyDataTemplateByEnum` and `theOtherKeyDataTemplateByString` won't be `null`, while `dataTemplateByEnumKeyAndWithDataType` will.\r\n\r\n **Expected behavior:**\r\n I expect that non-string `x:Key` is not ignored when `DataType` is set for a `DataTemplate`.\r\n\r\n **Minimal repro:**\r\n[Repro for .NET Core and .NET Framework is here](https://github.com/MaciekSwiszczowski/EnumBugRepro)\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/3137","RelatedDescription":"Open issue \"Non-string x:Key ignored on DataTemplate, when DataType set.\" (#3137)"},{"Id":"638159037","IsPullRequest":true,"CreatedAt":"2020-06-13T13:16:10","Actor":"dotnet-maestro[bot]","Number":"3136","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200613.2\r\n- **Date Produced**: 6/13/2020 12:57 PM\r\n- **Commit**: 24be90a15277b01e004178c5537aaeddded633f0\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20312.2 to 5.0.0-preview.7.20313.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3136","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3136)"},{"Id":"637876112","IsPullRequest":false,"CreatedAt":"2020-06-12T16:34:19","Actor":"teh173","Number":"3135","RawContent":null,"Title":"WPF window and images take massive amount of memory compared to UWP","State":"open","Body":"* .NET Core Version: 3.1.300\r\n* Windows version: 19041.329, but also reproducible in earlier versions\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? No\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\n \r\nA WPF window and image seem to take a massive amount of memory compared to an equivalently sized window in UWP.\r\n\r\nPossibly related issues:\r\n- https://developercommunity.visualstudio.com/content/problem/724609/wpf-window-memory-usage-is-high-on-big-screens-on.html\r\n- we are also seeing this error in some crash data, but haven't been able to reproduce in-house, so not clear if it is related  https://github.com/dotnet/wpf/issues/128\r\nSystem.OutOfMemoryException: Insufficient memory to continue the execution of the program.\r\n   at MS.Internal.HRESULT.Check(int hr)\r\n   at System.Windows.Media.Composition.DUCE+Channel.SyncFlush()\r\n- I noticed encountering this issue as well, when resizing a WPF window, the Dedicated GPU usage column continually goes up in Task Manager. I guess it's a Task Manager bug but I'm wondering why it's manifested by WPF here.\r\nhttps://support.microsoft.com/en-us/help/4490156/windows-10-1709-gpu-process-memory-counters-report-incorrect-values\r\nAlso see a lot of page faults.\r\n\r\n **Minimal repro:**\r\n\r\nTest apps for WPF and UWP\r\n\r\n[WindowMemoryTestApps.zip](https://github.com/dotnet/wpf/files/4771955/WindowMemoryTestApps.zip)\r\n\r\n1. Create a window\r\n2. (optional) Add an image element at the size of the screen. It just increases the memory usage even further than a blank window alone\r\n3. Resize the window to multiple monitors ( for example, 2 4Ks, or 1 4K monitor and other sized monitors)\r\n\r\nCompare the memory usage in WPF vs. UWP\r\n\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nOn my monitor setup with 7495 x 4440 virtual screen pixels, for WPF, sizing a window to that size takes around\r\n![image](https://user-images.githubusercontent.com/5522385/84521894-b1272200-aca3-11ea-824a-f4e362600a82.png)\r\n\r\nThis is what a similar setup looks like in UWP.\r\n![image](https://user-images.githubusercontent.com/5522385/84523071-b2f1e500-aca5-11ea-807b-339d01d4d2f8.png)\r\n\r\n **Expected behavior:**\r\nI would expect the behavior closer to UWP.  I would expect say a (3840 x 2160 x 4 bytes per pixel) * 2 monitor setup to take 66,355,200 bytes, but WPF seems to be using many multiples of that.  \r\n\r\nIs this just an architectural limitation in WPF, or a bug?\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/3135","RelatedDescription":"Open issue \"WPF window and images take massive amount of memory compared to UWP\" (#3135)"},{"Id":"637737279","IsPullRequest":true,"CreatedAt":"2020-06-12T13:32:12","Actor":"dotnet-maestro[bot]","Number":"3133","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200612.2\r\n- **Date Produced**: 6/12/2020 12:58 PM\r\n- **Commit**: cedbac7844a828fd4b97bad17a51fdde83726b1f\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20312.2\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3133","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3133)"},{"Id":"637717844","IsPullRequest":false,"CreatedAt":"2020-06-12T12:33:26","Actor":"miloush","Number":"3132","RawContent":null,"Title":"Local testing missing packages","State":"open","Body":"I am trying to test a local WPF build, but since it involves changes in public API, I need the sample app to use the new references rather than replacing published binaries.\r\n\r\nI tried to follow the [Developer Guide](https://github.com/dotnet/wpf/blob/master/Documentation/developer-guide.md), basically:\r\n\r\n1. forking and cloning the wpf repo\r\n2. importing wpf.vsconfig\r\n3. installing latest .NET Core SDK (5.0.100-preview.5.20279.10 from dotnet.microsoft.com)\r\n4. running `build` from command line, that succeeded\r\n5. running `bulid -test` from administrator command line, that failed, see below\r\n6. changing the code\r\n7. running `build -package`, that succeeded (created 5 files `.nupkg` after build)\r\n8. created a new WPF App (.NET Core)\r\n9. added the `<PropertyGroup>` and `<ItemGroup>`  with `WpfRepoRoot` etc. from _Testing API changes_ section of the _Developer Guide_ at the end of the .csproj file\r\n\r\nStill, the Visual Studio does not seem to be using the custom build (does not compile against the API changes). What I noticed is that\r\n\r\n```xml\r\n<ReferenceCopyLocalPaths Include=\"$(WpfRepoRoot)\\artifacts\\packaging\\$(WpfConfig)\\Microsoft.DotNet.Wpf.GitHub\\lib\\$(RuntimeIdentifier)\\*.dll\" />`\r\n```\r\n\r\ndoes not exist. there is only _netcoreapp5.0_ folder under the _lib_ folders.\r\n\r\nAnother suspicious thing is the beginning of the `build` output, which looks like this:\r\n```\r\nC:\\Users\\User\\Source\\WPF>build -pack\r\nProcessing C:\\Users\\User\\Source\\WPF\\global.json\r\nstrawberry-perl was not found in .\r\nnet-framework-48-ref-assemblies was not found in .\r\ndotnet-api-docs_netcoreapp3.0 was not found in .\r\nmsvcurt-c1xx was not found in .\r\nnet-framework-472-iltools was not found in .\r\nNative tools bootstrap failed\r\nDetecting WPF Git hooks...\r\nDetected existing WPF Git pre-commit hook.\r\nProcessing C:\\Users\\User\\Source\\WPF\\eng\\..\\global.json\r\nstrawberry-perl was not found in .\r\nnet-framework-48-ref-assemblies was not found in .\r\ndotnet-api-docs_netcoreapp3.0 was not found in .\r\nmsvcurt-c1xx was not found in .\r\nnet-framework-472-iltools was not found in .\r\nNative tools bootstrap failed\r\nC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\MSBuild\\Current\\Bin\\msbuild.exe ...\r\n```\r\n\r\nNot sure if that is OK or not.\r\n\r\nPossibly related, the `build -test` is failing with\r\n```\r\n...\r\n  PresentationFramework.Aero -> C:\\Users\\User\\Source\\WPF\\artifacts\\bin\\PresentationFramework.Aero\\Debug\\netcoreapp5.0\\PresentationFramework.Aero.dll\r\n  The system cannot find the path specified.\r\nC:\\Users\\User\\Source\\WPF\\eng\\WpfArcadeSdk\\tools\\RunDrtsLocal.targets(10,5): error MSB3073: The command \"C:\\Users\\User\\Source\\WPF\\\\artifacts\\test\\Debug\\x86\\runte\r\nsts.cmd\" exited with code 3. [C:\\Users\\User\\.nuget\\packages\\microsoft.dotnet.arcade.sdk\\5.0.0-beta.20309.1\\tools\\AfterSolutionBuild.proj]\r\n\r\nBuild FAILED.\r\n```\r\n\r\nWhat did I miss?","Url":"https://github.com/dotnet/wpf/issues/3132","RelatedDescription":"Open issue \"Local testing missing packages\" (#3132)"},{"Id":"637521581","IsPullRequest":true,"CreatedAt":"2020-06-12T06:38:00","Actor":"dotnet-maestro[bot]","Number":"3131","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"open","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: 256c8be3-de58-46f5-d219-08d6ba11f126\r\n- **Build**: 20200618.5\r\n- **Date Produced**: 6/19/2020 3:29 AM\r\n- **Commit**: 2a1ea08f677da3b9706378c5a109f2201f477ff7\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 5.0.0-preview.7.20311.7 to 5.0.0-preview.7.20318.5\r\n  - **Microsoft.Win32.Registry**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.CodeDom**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Configuration.ConfigurationManager**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Diagnostics.EventLog**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.DirectoryServices**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Drawing.Common**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Reflection.MetadataLoadContext**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Security.AccessControl**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Security.Cryptography.Xml**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Security.Permissions**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Security.Principal.Windows**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Windows.Extensions**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **Microsoft.NETCore.Platforms**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.IO.Packaging**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **Microsoft.NETCore.ILDAsm**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **Microsoft.NETCore.ILAsm**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **System.Resources.Extensions**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n  - **Microsoft.NETCore.App.Internal**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.Win32.Registry**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.CodeDom**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Configuration.ConfigurationManager**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Diagnostics.EventLog**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.DirectoryServices**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Drawing.Common**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Reflection.MetadataLoadContext**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.AccessControl**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Cryptography.Xml**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Permissions**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Principal.Windows**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Windows.Extensions**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.Platforms**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.IO.Packaging**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.ILDAsm**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.ILAsm**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Resources.Extensions**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.App.Internal**: from 5.0.0-preview.7.20311.2 to 5.0.0-preview.7.20318.2 (parent: Microsoft.Private.Winforms)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3131","RelatedDescription":"Open PR \"[master] Update dependencies from dotnet/winforms\" (#3131)"},{"Id":"637515681","IsPullRequest":true,"CreatedAt":"2020-06-12T06:37:11","Actor":"dotnet-maestro[bot]","Number":"3130","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: 256c8be3-de58-46f5-d219-08d6ba11f126\r\n- **Build**: 20200611.7\r\n- **Date Produced**: 6/12/2020 6:12 AM\r\n- **Commit**: 2343c3b1c43507fe60f07df1d62baa25ec996ee8\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 5.0.0-preview.7.20311.5 to 5.0.0-preview.7.20311.7\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3130","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#3130)"},{"Id":"637484958","IsPullRequest":true,"CreatedAt":"2020-06-12T05:15:37","Actor":"dotnet-maestro[bot]","Number":"3129","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: 256c8be3-de58-46f5-d219-08d6ba11f126\r\n- **Build**: 20200611.5\r\n- **Date Produced**: 6/12/2020 4:25 AM\r\n- **Commit**: 38b608ecd8cf587c89af49cb0853fdca143c3b46\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 5.0.0-preview.7.20311.4 to 5.0.0-preview.7.20311.5\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3129","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#3129)"},{"Id":"637476523","IsPullRequest":true,"CreatedAt":"2020-06-12T04:58:59","Actor":"dotnet-maestro[bot]","Number":"3128","RawContent":null,"Title":"[master] Update dependencies from dotnet/winforms","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n- **Microsoft.Win32.Registry**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.CodeDom**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Configuration.ConfigurationManager**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Diagnostics.EventLog**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.DirectoryServices**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Drawing.Common**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Reflection.MetadataLoadContext**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.AccessControl**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Cryptography.Xml**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Permissions**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Security.Principal.Windows**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Windows.Extensions**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.Platforms**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.IO.Packaging**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.ILDAsm**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.ILAsm**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **System.Resources.Extensions**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n- **Microsoft.NETCore.App.Internal**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2 (parent: Microsoft.Private.Winforms)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n[marker]: <> (Begin:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: 256c8be3-de58-46f5-d219-08d6ba11f126\r\n- **Build**: 20200611.4\r\n- **Date Produced**: 6/12/2020 4:23 AM\r\n- **Commit**: f5b8fcc2280a28c75486776f46ed2fa4335aa5e1\r\n- **Branch**: refs/heads/master\r\n- **Updates**:\r\n  - **Microsoft.Private.Winforms**: from 5.0.0-preview.7.20309.5 to 5.0.0-preview.7.20311.4\r\n  - **Microsoft.Win32.Registry**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.CodeDom**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Configuration.ConfigurationManager**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Diagnostics.EventLog**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.DirectoryServices**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Drawing.Common**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Reflection.MetadataLoadContext**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Security.AccessControl**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Security.Cryptography.Xml**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Security.Permissions**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Security.Principal.Windows**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Windows.Extensions**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **Microsoft.NETCore.Platforms**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.IO.Packaging**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **Microsoft.NETCore.ILDAsm**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **Microsoft.NETCore.ILAsm**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **System.Resources.Extensions**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n  - **Microsoft.NETCore.App.Internal**: from 5.0.0-preview.7.20308.8 to 5.0.0-preview.7.20311.2\r\n\r\n[marker]: <> (End:256c8be3-de58-46f5-d219-08d6ba11f126)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3128","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/winforms\" (#3128)"},{"Id":"637376161","IsPullRequest":false,"CreatedAt":"2020-06-11T23:16:12","Actor":"vsfeedback","Number":"3127","RawContent":null,"Title":"DragLeave event delivering wrong value for 'e.GetPosition(...)'","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/635146/dragleave-event-delivering-wrong-value-for-egetpos.html)._\n\n---\n<p>While doing Drag'n'Drop I tried to use the DragLeave event to determine, if mouse has left the my control. Problem is, that the DragLeave event is also fired, if mouse leaves toward a child visual of my control but does not leave my control's boundaries at all.</p> <p>Trying to use the 'getPosition(sender...)' method from DragEventArgs does not return a Point value related to my control, but rather a Point value related to the control it entered while leaving my control.</p> <p><strong>I would expect a value, that signals that it is out of bounds of the left control, e.g. negative values for leaving toward left and top and positive values greater than width/height for leaving the control toward bottom and right.</strong></p>\n\n---\n### Original Comments\n\n#### Visual Studio Feedback System on 7/8/2019, 02:43 AM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n#### Marie Shi [MSFT] on 7/8/2019, 07:31 PM: \n\n<p>Dear Customer,</p>\n<p>Thank you for your feedback! I am unable to reproduce your problem.<br>\nFor us to investigate this further, could you please provide your detail reproduce steps, sample app to reproduce this issue? We look forward to hearing from you!</p>\n<p>Thanks,<br>\nMarie</p>\n\n#### Sven Kämpf on 7/22/2019, 07:31 AM: \n\n<p>Hello Marie,</p><p>thank you very much for your answer and please excuse my late response (vacation offline :o) ).</p><p>Please find attached a sample app to show you the issue (<a target='_blank' href=\"https://developercommunity.visualstudio.com/storage/temp/84375-dragleaveissuereproductionapp.tar.gz\">dragleaveissuereproductionapp.tar.gz).<br></a></p><p>In that sample app I created a rectangle within a canvas. You can drag the rectangle towards the canvas (using left mouse button). If you leave the rectangle's boundaries while dragging, the DragLeave event is fired and handled in the related handler in code-behind:</p><pre>private void Rectangle_OnPreviewDragLeave(object sender, DragEventArgs e)\n{\n    ...\n\n}</pre><p>Here I try to retrieve the relative position of the mouse pointer with:</p><pre>var givenPoint = e.GetPosition(sender as IInputElement);<br></pre><p>Furthermore I relocate the position of the text box (with name \"GetPositionValue\") to display the coords from the 'givenPoint' and set it's Text property to the 'givenPoint' value:</p><pre>Canvas.SetLeft(this.GetPositionValue, givenPoint.X);\nCanvas.SetTop(this.GetPositionValue, givenPoint.Y);\nthis.GetPositionValue.Text = givenPoint.ToString();<br></pre><p>As you can see (after dragging the rectangle towards the canvas), the textbox is located right at that point, where the mouse left the rectangle on the canvas.</p><p>That is, the point given by e.GetPosition(...) is relative to the Canvas(!), even if I gave the sender(i.e. the rectangle) as the InputElement. But the givenPoint's X-value for instance should be negative for leaving the rectangle to the left, etc. Otherwise in my opinion I can not decide, if the drag has left the rectangle's boundaries.</p><p>I hope that helped.</p><p>PS: I made the app very simple and short. Please ignore code style here.</p>\n\n#### Blair Wang [MSFT] on 7/22/2019, 07:38 AM: \n\nWe will close this report in 7 days because we don’t have enough information to investigate further. To keep the problem open, please provide the requested details.\n#### Visual Studio Feedback System on 7/23/2019, 03:01 AM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n#### Sven Kämpf on 8/8/2019, 07:20 AM: \n\n<p>Hello there,</p><p>are there any news about this issue? Maybe workarounds or other ideas to avoid that DragLeave?</p>\n\n#### Sven Kämpf on 8/18/2019, 11:38 PM: \n\n<p>Hello again,</p><p>could you please tell me the status of my request or a timescale for the answer?</p>\n\n#### Visual Studio Feedback System on 10/8/2019, 02:21 AM: \n\nI have detected that for the last 35 days, this issue didn't have any product team activity and a very small amount of new votes or comments.&nbsp;Based on this, its severity, and affected area, it’s my experience that this issue is very unlikely to be fixed.\n#### Sven Kämpf on 10/8/2019, 04:21 AM: \n\n<p>Why? It's essential for Drag&Drop? At least an explanation beside that probably automated Visual Studio Feedback System message would be nice!</p>\n\n\n---\n### Original Solutions\n\n#### Martin Zindler solved on 12/30/2019, 05:00 AM, 0 votes: \n\n<p>Hi,</p><p>Described in </p><p>https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.mouse.getposition</p><p>you may read the section <em>Remarks.<br></em></p><p><em>&gt;&gt;&gt;<br></em></p><p>... </p><p>During drag-and drop operations, the position of the mouse cannot be reliably determined through <a target='_blank' href=\"https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.mouse.getposition?view=netframework-4.8\">GetPosition</a>.  </p><p>This is because control of the mouse (possibly including capture) is  held by the originating element of the drag </p><p>until the drop is completed,  with much of the behavior controlled by underlying Win32 calls. </p><p>Try the  following approaches instead:</p><p> \n</p><ul><li>Call the <a target='_blank' href=\"https://docs.microsoft.com/en-us/dotnet/api/system.windows.drageventargs.getposition?view=netframework-4.8\">GetPosition</a> method of the <a target='_blank' href=\"https://docs.microsoft.com/en-us/dotnet/api/system.windows.drageventargs?view=netframework-4.8\">DragEventArgs</a> that is passed to the drag events (<a target='_blank' href=\"https://docs.microsoft.com/en-us/dotnet/api/system.windows.contentelement.dragenter?view=netframework-4.8\">DragEnter</a>, <a target='_blank' href=\"https://docs.microsoft.com/en-us/dotnet/api/system.windows.contentelement.dragover?view=netframework-4.8\">DragOver</a>, <a target='_blank' href=\"https://docs.microsoft.com/en-us/dotnet/api/system.windows.contentelement.dragleave?view=netframework-4.8\">DragLeave</a>).</li><li>Call <a target='_blank' href=\"https://msdn.microsoft.com/library/default.asp?url=/library/winui/winui/windowsuserinterface/resources/cursors/cursorreference/cursorfunctions/getcursorpos.asp\">GetCursorPos</a>, using P/Invoke.</li></ul><p><em>&lt;&lt;&lt;<br></em></p><p>Another approach will be to use the <em>PreviewMouseMove </em>event.</p><p>kind regards // Martin</p>\n\n#### Sven Kämpf solved on 1/6/2020, 00:46 AM, 0 votes: \n\n<p>Hello Martin Zindler,</p><p>thank you very much for posting a solution to my issue.</p><p>I agree with you, that - using <a target='_blank' href=\"https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.mouse.getposition?view=netframework-4.8\" target=\"_blank\">Mouse.GetPosition(...)</a> isn't a good solution. That's why I didn't do it (see my post from july, 22). In my example I wrote \"e.GetPosition(...)\" where <em>e </em>is a variable containing the DragEventArgs.</p><p><strong>I still treat this issue as a bug in the Framework.<br></strong></p><p><strong><br></strong></p><p><em>For everybody looking for a workaround to use DragLeave:</em><br><strong></strong></p><p>Since the DragLeave event has another drawback(see below) I would recommend anyone asking me to use DragOver of a Parent in the VisualTree, since this is more reliable.</p><p>The other drawback of DragLeave is, that, if you move the mouse too fast over the border of the control you started to drag, the DragLeave event isn't fired sometimes (race condition?). Since this event is only fired once, that missing event distracted my whole application resulting in undefined state.</p><p>Using the DragOver event instead is more reliable, since this event is fired multiple times while moving the mouse and you can use a hit test to see, if you left your source control or not.</p><br>\n","Url":"https://github.com/dotnet/wpf/issues/3127","RelatedDescription":"Open issue \"DragLeave event delivering wrong value for 'e.GetPosition(...)'\" (#3127)"},{"Id":"637240448","IsPullRequest":true,"CreatedAt":"2020-06-11T19:47:40","Actor":"ryalanms","Number":"3126","RawContent":null,"Title":"Update branding for 3.1.6","State":"closed","Body":"Update branding for 3.1.6\r\n\r\nIncludes the merge from internal/release/3.1 (847da8feefa286affd3f458fc3fdcedcd0d93869) which resulted in no changes after resolving merge conflicts.  No MSRCs were taken for this release, so that is expected. ","Url":"https://github.com/dotnet/wpf/pull/3126","RelatedDescription":"Closed or merged PR \"Update branding for 3.1.6\" (#3126)"}],"ResultType":"GitHubIssue"}},"RunOn":"2020-06-19T05:30:51.2628327Z","RunDurationInMilliseconds":653}