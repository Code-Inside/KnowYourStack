{"Data":{"GitHub":{"Issues":[{"Id":"1176707071","IsPullRequest":true,"CreatedAt":"2022-03-22T12:50:56","Actor":"dotnet-maestro[bot]","Number":"6298","RawContent":null,"Title":"[main] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:840bf684-917a-4879-f62c-08d8e93a0c51)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 840bf684-917a-4879-f62c-08d8e93a0c51\r\n- **Build**: 20220321.2\r\n- **Date Produced**: March 21, 2022 6:59:55 PM UTC\r\n- **Commit**: c8a95297e2622251c125aa5c0ef7c822275a792d\r\n- **Branch**: refs/heads/main\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: [from 7.0.0-beta.22168.2 to 7.0.0-beta.22171.2][1]\r\n  - **Microsoft.DotNet.Arcade.Sdk**: [from 7.0.0-beta.22168.2 to 7.0.0-beta.22171.2][1]\r\n  - **Microsoft.DotNet.ApiCompat**: [from 7.0.0-beta.22168.2 to 7.0.0-beta.22171.2][1]\r\n  - **Microsoft.DotNet.GenAPI**: [from 7.0.0-beta.22168.2 to 7.0.0-beta.22171.2][1]\r\n  - **Microsoft.DotNet.Helix.Sdk**: [from 7.0.0-beta.22168.2 to 7.0.0-beta.22171.2][1]\r\n\r\n[1]: https://github.com/dotnet/arcade/compare/bafd559...c8a9529\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:840bf684-917a-4879-f62c-08d8e93a0c51)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/6298","RelatedDescription":"Closed or merged PR \"[main] Update dependencies from dotnet/arcade\" (#6298)"},{"Id":"1176503717","IsPullRequest":false,"CreatedAt":"2022-03-22T09:27:09","Actor":"jroessel","Number":"6297","RawContent":null,"Title":"VisualCollection.RemoveAt breaks when multiple null entries exist","State":"open","Body":"RemoveAt takes the entry at the specified index and delegates to RemoveInternal with that item. However, if there are multiple `null` entries in the collection, RemoveInternal then only removes the first, not the one at the requested index.\r\n\r\nThis likely necessitates inlining part of what RemoveInternal does into RemoveAt, since those two approaches are a bit incompatible with each other.","Url":"https://github.com/dotnet/wpf/issues/6297","RelatedDescription":"Open issue \"VisualCollection.RemoveAt breaks when multiple null entries exist\" (#6297)"},{"Id":"1176467116","IsPullRequest":false,"CreatedAt":"2022-03-22T08:59:51","Actor":"wstaelens","Number":"6296","RawContent":null,"Title":"XPS huge memory issues","State":"open","Body":"* .NET Core Version: 5, 6, ... every version. \r\n* Windows version: Windows 10 21H2 Windows 10 21H1, Windows 11 21H2\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes, I guess so.\r\n\r\n **Problem description:**\r\n \r\nOpening a large XPS document requires a huge amount of memory.\r\nSame situation when merging several XPS documents into one XPS documents (the total amount of merged pages is: 500 - 1.000 - 5.000 or even 10.000).\r\n\r\n1.000 pages can easily run up to 15 or 20GB of memory. Depending on the document content and fonts being used.\r\n\r\nThere are several problems:\r\n- XPS documents need to be fully loaded into memory when working with them. When for example converting XPS documents, you loop over every page. Once a page has been loaded in memory it is being kept there. There is no way to only load a Visual per Visual (e.g. FixedPage per FixedPage (page per page)) as there is no signal on when the Visual/FixedPage is not needed anymore in order to unload it from memory. \r\n(Besides this, is it even possible to unload a single Visual/FixedPage from memory?)\r\n\r\n- When processing a document (e.g. adding content, printing, converting, ...) the memory can increase very rapidly to several GB's of memory. Especially when the source documents contain TrueType CID fonts, as when converting these to XPS (e.g. converting PDF files and draw them to XPS) the font and character information is being converted to polygons (a lot of doubles) and huge strings because the XML of the XPS is fully loaded into memory.\r\n\r\n- XPS uses doubles (EMF uses floats), because the nature of XPS that everything is kept in memory, the doubles take also a huge amount of memory. Same for strings as XPS = XML file = strings.\r\n\r\n\r\n\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n \r\nUnable to process and/or merge thousands of XPS documents. Even 500 pages can be problematic. Running out of memory.\r\n\r\n![MicrosoftTeams-image (12)](https://user-images.githubusercontent.com/7447285/159434111-b5db3b45-83d8-4fb9-8664-e6fdeb48c847.png)\r\nThis screenshot is a view of the memory usage over a short time where several XPS documents of the XPS printer are being processed when being combined together. The huge string is because of the XML content being loaded all into memory (because documents need to be merged, meaning everything should be loaded into memory.) Once the document has been merged, the source documents can be unloaded from memory. \r\n\r\nsituation: 1000 documents of 2 (or 3 pages) need to be merged into a big document .\r\nThe pages to be merged, can be \"random\", according to the logic of the configured product. Meaning that e.g. from document1 we can use page 2 and 3, from document 2 we can use page 1, from document 3 we can use all pages, from document 4 we can use the last page, etc...\r\nPseudo-code:\r\n\r\n```\r\nforeach (doc in documents) { mergeIntoBigFile(doc); }\r\n```\r\n\r\nIt is also possible that we first merge e.g. document 3, document 1, document 999, again document 1, document 2, document 36, document 1000. \r\nThe final code that does the merging, doesn't need any knowlegde of the original document(s). \r\n\r\n\r\n **Expected behavior:**\r\nBeing able to at least process and/or merge several hundreds and thousands of XPS documents. 500 pages shouldn't be a problem. Memory should be better under control.\r\n\r\nIn case it is possible to process/merge/whatever big XPS documents without having huge memory issues or unload pages, please show code samples as it seems to be impossible.\r\n\r\n **Minimal repro:**\r\n/ (unable to repro, if someone of msft PM's me I can help configuring a product to demonstrate).\r\n\r\n**Question**\r\nOne of the biggest questions:\r\nIs there a way to unload a FixedPage/Visual from memory?\r\n\r\n\r\n**General XPS issues and :shit: that nobody seems to care about**\r\n\r\n- https://github.com/dotnet/runtime/issues/66756\r\n- https://github.com/dotnet/runtime/issues/51930\r\n- https://github.com/dotnet/wpf/issues/3546\r\n- https://github.com/dotnet/runtime/issues/51929#issuecomment-835808702\r\n- https://github.com/dotnet/wpf/issues/4000\r\n- https://github.com/dotnet/wpf/issues/4466 \r\n- https://github.com/dotnet/wpf/issues/2106 \r\n- https://github.com/dotnet/wpf/issues/2085 \r\n\r\n( related: https://stackoverflow.com/questions/2342623/how-to-generate-and-print-large-xps-documents-in-wpf  and https://social.msdn.microsoft.com/Forums/en-US/f3eeaf1e-e397-44b8-819a-8a79d1e5baa5/batch-printing-of-visuals-to-xps-leads-to-outofmemoryexception )","Url":"https://github.com/dotnet/wpf/issues/6296","RelatedDescription":"Open issue \"XPS huge memory issues\" (#6296)"},{"Id":"1176425017","IsPullRequest":true,"CreatedAt":"2022-03-22T08:18:56","Actor":"dipeshmsft","Number":"6295","RawContent":null,"Title":"Fixes rounding error while glyphrun serialization","State":"open","Body":"Fixes # <!-- Issue Number -->\r\n\r\nMain PR <!-- Link to PR if any that fixed this in the main branch. -->\r\n\r\n## Description\r\nWhen we serialize a GlyphRun to an XPS file, the advance widths for each glyph are rounded to an integer separately, thus producing a significant difference between the rendered output in the file and on the screen. This PR fixes the rounding, by taking into account the cumulative rounding error from the previous glyphs while rounding the current glyph.\r\n\r\n## Customer Impact\r\n\r\n<!-- What is the impact to customers of not taking this fix? -->\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nAd-Hoc testing. Tried with different sample apps.\r\n\r\n## Risk\r\n\r\n<!-- Please assess the risk of taking this fix. Provide details backing up your assessment. -->\r\n","Url":"https://github.com/dotnet/wpf/pull/6295","RelatedDescription":"Open PR \"Fixes rounding error while glyphrun serialization\" (#6295)"},{"Id":"1176412441","IsPullRequest":false,"CreatedAt":"2022-03-22T08:05:54","Actor":"aquinn39","Number":"6294","RawContent":null,"Title":"WindowsFormsHost does not scale children correctly when the DPI is changed","State":"open","Body":"* .NET Core Version:  .Net 6.0.3\r\n* Windows version: Windows 11 21H2 (OS Build 22000.556)\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes (Except for some of the issues with NumericUpDown - some of these issues did not exist in .Net Framework 4.8)\r\n\r\n\r\n \r\n **Problem description:**\r\nWhen scaling to a new DPI using Per Monitor V2, the contents of WindowsFormsHosts often do not scale correctly - this issue is worse in .Net 6 compared to .Net Framework 4.8 (I have not tested with .Net Core 3 or .Net 5). The main issue appears to be that the height and width of the child window hosting the Windows Forms control does not scale at all, and in .Net 6 the NumericUpDown control completely ignores DPI changes.\r\n\r\n\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n Below is a screenshot of a WPF window with some Forms controls in it, opened on a monitor with the DPI scaling set to 100% and set to the main monitor:\r\n![image](https://user-images.githubusercontent.com/43898231/159429999-4dde4b8e-6204-4530-8377-d05014adeba3.png)\r\nAfter moving the window over to a monitor with a scaling of 225%, it looks like this:\r\n![image](https://user-images.githubusercontent.com/43898231/159430096-1d7651d0-53e8-406c-8998-f16ec7dba3b8.png)\r\nNote that the height and width of all the Forms controls did not scale at all. While the font size scales fine on most of the controls in the screenshot, it completely fails on the NumericUpDown control - the control seems to ignore the change in DPI completely.\r\nIn regards to the NumericUpDown control, I made the exact same project in .Net Framework 4.8 and moved the window over from the 100% scaling monitor to the 225% scaling one and here is a screenshot of that:\r\n![image](https://user-images.githubusercontent.com/43898231/159430650-f1aa69dd-8c6e-4d85-bbad-5304b00ec9fc.png)\r\nNote that the text and up/down buttons do scale correctly for the NumericUpDown control in .Net Framework 4.8 - this seems to have been broken somewhere in between then and .Net 6. The other issues still seem to persist.\r\n\r\nIf I open the .Net 6 WPF window directly on the monitor with 225% scaling with that monitor set as my main one, it scales nicely:\r\n![image](https://user-images.githubusercontent.com/43898231/159431557-9dee000c-1eb0-499a-a213-f33537d2df38.png)\r\nBut then if I move it over to the 100% scaling monitor, I get this:\r\n![image](https://user-images.githubusercontent.com/43898231/159431633-1197fecb-9874-4259-acce-155372481316.png)\r\n\r\nSo to sum up, the physical height and width of these Windows Forms controls is not changing at all when the DPI changes. I have used Visual Studio to check the logical height and width of the WindowsFormsHost, and it remains correct after the DPI change, but the physical height and width of the child window hosting the Windows Forms content appears to not change.\r\n\r\nI have uploaded the demo project I used for the screenshots. Both are very basic apps with as many modern DPI scaling features enabled as I could (such as in the Manifest and App.config - see the minimal repo for specifics) and with the DPI scaling mode set to Per Monitor V2. Also note that the same issues seem to occur if the DPI for the monitor the WPF window is on is changed, not just if dragged to a new monitor.\r\n\r\n **Expected behavior:**\r\nWhen moving from the 100% DPI monitor to the 225% one, the controls should scale like so:\r\n![image](https://user-images.githubusercontent.com/43898231/159431557-9dee000c-1eb0-499a-a213-f33537d2df38.png)\r\n\r\nAlso for comparison, here is a .Net 6 Windows Form with the same controls on the 100% DPI monitor:\r\n![image](https://user-images.githubusercontent.com/43898231/159434552-f905acd8-c63b-4d9d-9741-888792529eff.png)\r\nAnd now moved over the the 225% one:\r\n![image](https://user-images.githubusercontent.com/43898231/159433331-e22971ec-3f6b-4263-98a8-106c6c1795d6.png)\r\nIt scales almost perfectly except for the up/down buttons in the NumericUpDown box.\r\n **Minimal repro:**\r\n[WpfApp1.zip](https://github.com/dotnet/wpf/files/8322247/WpfApp1.zip)\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/6294","RelatedDescription":"Open issue \"WindowsFormsHost does not scale children correctly when the DPI is changed\" (#6294)"},{"Id":"1176188836","IsPullRequest":true,"CreatedAt":"2022-03-22T06:46:40","Actor":"singhashish-wpf","Number":"6291","RawContent":null,"Title":"Update branding iteration to 4","State":"closed","Body":"\r\n## Description\r\nUpdate branding iteration to 4\r\n","Url":"https://github.com/dotnet/wpf/pull/6291","RelatedDescription":"Closed or merged PR \"Update branding iteration to 4\" (#6291)"},{"Id":"1176289218","IsPullRequest":true,"CreatedAt":"2022-03-22T05:34:40","Actor":"paulozemek","Number":"6293","RawContent":null,"Title":"Avoid excessive calls to the PropertyValues index getter.","State":"open","Body":"## Description\r\nIn some places the PropertyValues indexer was called multiple times. This change just stores the value into a local once then use the local variable instead.\r\n\r\n## Customer Impact\r\nNo noticeable difference.\r\n\r\n## Regression\r\nNo.\r\n","Url":"https://github.com/dotnet/wpf/pull/6293","RelatedDescription":"Open PR \"Avoid excessive calls to the PropertyValues index getter.\" (#6293)"},{"Id":"1176195684","IsPullRequest":true,"CreatedAt":"2022-03-22T02:49:44","Actor":"singhashish-wpf","Number":"6292","RawContent":null,"Title":"Test Internal pools for build","State":"open","Body":"General Testing of wpf build on Internal pool before rollout for errors\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/6292","RelatedDescription":"Open PR \"Test Internal pools for build\" (#6292)"},{"Id":"1175476599","IsPullRequest":true,"CreatedAt":"2022-03-21T14:33:06","Actor":"stephentoub","Number":"6288","RawContent":null,"Title":"Avoid unnecessary allocations/code in ReaderWriterLockWrapper","State":"open","Body":"## Description\r\n\r\nBy default the code was using structs as the IDisposables returned to the caller, resulting in those structs being boxed on every access.  The code was also for some reason maintaining two code paths based on a switch, but the only impact of that would be on whether new instances would be allocated on each call, which is not something we need to guard with a switch (that's seemingly unrelated).  The code is also allocating a new delegate for every enter and exit operation.  This commit simplifies all that and avoids all that unnecessary allocation and duplication.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary allocation and overhead\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal. Only issue would be if callers were for some reason depending on a different object reference being returned from the Read/WriteLock properties on every access.","Url":"https://github.com/dotnet/wpf/pull/6288","RelatedDescription":"Open PR \"Avoid unnecessary allocations/code in ReaderWriterLockWrapper\" (#6288)"},{"Id":"1174398602","IsPullRequest":true,"CreatedAt":"2022-03-20T00:00:25","Actor":"stephentoub","Number":"6285","RawContent":null,"Title":"Change most non-generic sorts to be generic","State":"open","Body":"## Description\r\n\r\nEspecially for the sorts based on int[], this avoids boxing potentially huge numbers of ints.  Even for classes, it avoids unnecessary casting and expensive Array.Get/SetValue calls, and switching to a delegate avoids a top-level allocation for the comparer inside the current Array.Sort implementation.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary allocation, interface dispatch, expensive Array.Get/SetValue calls, etc.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6285","RelatedDescription":"Open PR \"Change most non-generic sorts to be generic\" (#6285)"},{"Id":"1174253643","IsPullRequest":true,"CreatedAt":"2022-03-19T12:47:53","Actor":"dotnet-maestro[bot]","Number":"6284","RawContent":null,"Title":"[main] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:840bf684-917a-4879-f62c-08d8e93a0c51)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 840bf684-917a-4879-f62c-08d8e93a0c51\r\n- **Build**: 20220318.2\r\n- **Date Produced**: March 18, 2022 11:42:47 PM UTC\r\n- **Commit**: bafd55901b50d6fc3507c8ed96a7777fcca1796f\r\n- **Branch**: refs/heads/main\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: [from 7.0.0-beta.22167.4 to 7.0.0-beta.22168.2][1]\r\n  - **Microsoft.DotNet.Arcade.Sdk**: [from 7.0.0-beta.22167.4 to 7.0.0-beta.22168.2][1]\r\n  - **Microsoft.DotNet.ApiCompat**: [from 7.0.0-beta.22167.4 to 7.0.0-beta.22168.2][1]\r\n  - **Microsoft.DotNet.GenAPI**: [from 7.0.0-beta.22167.4 to 7.0.0-beta.22168.2][1]\r\n  - **Microsoft.DotNet.Helix.Sdk**: [from 7.0.0-beta.22167.4 to 7.0.0-beta.22168.2][1]\r\n\r\n[1]: https://github.com/dotnet/arcade/compare/251034e...bafd559\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:840bf684-917a-4879-f62c-08d8e93a0c51)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/6284","RelatedDescription":"Closed or merged PR \"[main] Update dependencies from dotnet/arcade\" (#6284)"},{"Id":"1173696442","IsPullRequest":false,"CreatedAt":"2022-03-18T15:06:59","Actor":"vijayarasan","Number":"6283","RawContent":null,"Title":"ToolTip immediately closed when showing in Button while project create with .Net 6","State":"open","Body":"* .NET Core Version: 6.0\r\n \r\n **Problem description:**\r\n I am using button and defined the tooltip like below mentioned code snippet,\r\n```XML  \r\n<Button x:Name=\"btn\"  Content=\"Button\"  Width=\"150\" Height=\"30\" >\r\n            <ToolTipService.ToolTip>\r\n                <ToolTip Background=\"#FFDB000C\" Content=\"Hello\" />\r\n            </ToolTipService.ToolTip>\r\n </Button>\r\n```\r\n\r\nWhen hovering to the button ToolTip immediately disappear. The reported problem occurs while using with VS2022 Preview, Scaling 150 and .Net 6.0. \r\n \r\n I have also set the ShowDuration and InitialDelayDuration, but no effect.\r\n \r\n **Note :** The reported problem does not occurs in .Net 5.0 \r\n \r\n **Actual behavior:** \r\n ToolTip immediately closed when showing in Button while project create with .Net 6\r\n \r\n **Expected behavior:**\r\n ToolTip properly display when showing in Button while project create with .Net 6\r\n\r\n**Sample Link:**  [ToolTipDemo.zip](https://github.com/dotnet/wpf/files/8305470/ToolTipDemo.zip)\r\n\r\nCan you please check and share any idea to resolve this issue?\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/6283","RelatedDescription":"Open issue \"ToolTip immediately closed when showing in Button while project create with .Net 6\" (#6283)"},{"Id":"1173641036","IsPullRequest":true,"CreatedAt":"2022-03-18T14:15:20","Actor":"stephentoub","Number":"6282","RawContent":null,"Title":"Avoid enumerator boxing in XamlSchemaContext.UpdateNamespaceByUriList","State":"open","Body":"## Description\r\n\r\nUpdateNamespaceByUriList has an `IList<T>` but is enumerating it with foreach, resulting in boxing the underlying list or array's enumerator.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary allocation.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6282","RelatedDescription":"Open PR \"Avoid enumerator boxing in XamlSchemaContext.UpdateNamespaceByUriList\" (#6282)"},{"Id":"1173634428","IsPullRequest":true,"CreatedAt":"2022-03-18T14:08:49","Actor":"stephentoub","Number":"6281","RawContent":null,"Title":"Avoid boxing list/array enumerator in CreateTextLSRuns","State":"open","Body":"## Description\r\n\r\nGetTextShapeableSymbols returns an `IList<T>`, but it's getting treated as an `ICollection<T>` and thus enumerated.  We can index into it instead to avoid some interface dispatch and boxing the enumerator of what's typically a `List<T>` or a `T[]`.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary allocation/overhead.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6281","RelatedDescription":"Open PR \"Avoid boxing list/array enumerator in CreateTextLSRuns\" (#6281)"},{"Id":"1173626013","IsPullRequest":true,"CreatedAt":"2022-03-18T14:00:25","Actor":"stephentoub","Number":"6280","RawContent":null,"Title":"Some improvements to FrugalList","State":"open","Body":"## Description\r\n\r\n- FrugalStructList's `ICollection<T>`-based constructor uses foreach to enumerate the contents of the collection.  If it's an `IList<T>`, we can instead index and avoid allocating the enumerator.\r\n- Avoid multiple interface calls to `ICollection<T>.Count` in FrugalStructList's ctor\r\n- Delete a dead ctor on `ArrayItemList<T>`.  That ctor was the only reason an array field may have been left null, so we can also remove subsequent null checks when accessing that array.\r\n- Use Span/Array in ArrayItemList for Clear, Contains, IndexOf, ToArray, and CopyTo rather than open-coding them\r\n\r\n## Customer Impact\r\n\r\nUnnecessary allocation and interface dispatch\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6280","RelatedDescription":"Open PR \"Some improvements to FrugalList\" (#6280)"},{"Id":"1173592096","IsPullRequest":true,"CreatedAt":"2022-03-18T13:27:50","Actor":"stephentoub","Number":"6279","RawContent":null,"Title":"Avoid boxing list enumerator in XamlObjectWriter.Logic_ConvertPositionalParamsToArgs","State":"open","Body":"## Description\r\n\r\nLogic_ConvertPositionalParamsToArgs is using foreach with an `IList<>` it gets back from `GetPositionalParameters`.  Doing so will end up boxing the enumerator, typically of a `List<T>`, when we can instead just use a for loop with the `IList<>`, avoiding the boxing and reducing interface calls.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary allocation and interface dispatch.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6279","RelatedDescription":"Open PR \"Avoid boxing list enumerator in XamlObjectWriter.Logic_ConvertPositionalParamsToArgs\" (#6279)"},{"Id":"1173534718","IsPullRequest":true,"CreatedAt":"2022-03-18T12:49:36","Actor":"dotnet-maestro[bot]","Number":"6278","RawContent":null,"Title":"[main] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:840bf684-917a-4879-f62c-08d8e93a0c51)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 840bf684-917a-4879-f62c-08d8e93a0c51\r\n- **Build**: 20220317.4\r\n- **Date Produced**: March 17, 2022 10:58:04 PM UTC\r\n- **Commit**: 251034e7687335886c3774a0138a8584a782b0eb\r\n- **Branch**: refs/heads/main\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: [from 7.0.0-beta.22166.1 to 7.0.0-beta.22167.4][1]\r\n  - **Microsoft.DotNet.Arcade.Sdk**: [from 7.0.0-beta.22166.1 to 7.0.0-beta.22167.4][1]\r\n  - **Microsoft.DotNet.ApiCompat**: [from 7.0.0-beta.22166.1 to 7.0.0-beta.22167.4][1]\r\n  - **Microsoft.DotNet.GenAPI**: [from 7.0.0-beta.22166.1 to 7.0.0-beta.22167.4][1]\r\n  - **Microsoft.DotNet.Helix.Sdk**: [from 7.0.0-beta.22166.1 to 7.0.0-beta.22167.4][1]\r\n\r\n[1]: https://github.com/dotnet/arcade/compare/c90e2d9...251034e\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:840bf684-917a-4879-f62c-08d8e93a0c51)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/6278","RelatedDescription":"Closed or merged PR \"[main] Update dependencies from dotnet/arcade\" (#6278)"},{"Id":"1173136380","IsPullRequest":true,"CreatedAt":"2022-03-18T03:07:35","Actor":"dotnet-maestro[bot]","Number":"6277","RawContent":null,"Title":"[main] Update dependencies from dotnet/winforms","State":"open","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:Coherency Updates)\r\n## Coherency Updates\r\n\r\nThe following updates ensure that dependencies with a *CoherentParentDependency*\r\nattribute were produced in a build used as input to the parent dependency's build.\r\nSee [Dependency Description Format](https://github.com/dotnet/arcade/blob/master/Documentation/DependencyDescriptionFormat.md#dependency-description-overview)\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Coherency Updates**:\r\n  - **System.CodeDom**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.Configuration.ConfigurationManager**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.Diagnostics.EventLog**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.DirectoryServices**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.Drawing.Common**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.Reflection.MetadataLoadContext**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.Security.Cryptography.Xml**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.Security.Permissions**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.Windows.Extensions**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **Microsoft.NETCore.Platforms**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.IO.Packaging**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **System.Resources.Extensions**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **Microsoft.NETCore.App.Ref**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **Microsoft.NETCore.App.Runtime.win-x64**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n  - **VS.Redist.Common.NetCore.SharedFramework.x64.7.0**: from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6 (parent: Microsoft.Private.Winforms)\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n[marker]: <> (End:Coherency Updates)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n[marker]: <> (Begin:dd483b3f-65b0-44ab-f62d-08d8e93a0c51)\r\n## From https://github.com/dotnet/winforms\r\n- **Subscription**: dd483b3f-65b0-44ab-f62d-08d8e93a0c51\r\n- **Build**: 20220322.10\r\n- **Date Produced**: March 23, 2022 2:53:36 AM UTC\r\n- **Commit**: 4b4c7d5002fdc3946a193e03e661cd31d50ccd2d\r\n- **Branch**: refs/heads/main\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.Dotnet.WinForms.ProjectTemplates**: [from 7.0.0-preview.3.22166.2 to 7.0.0-preview.4.22172.10][29]\r\n  - **Microsoft.Private.Winforms**: [from 7.0.0-preview.3.22166.2 to 7.0.0-preview.4.22172.10][29]\r\n  - **System.CodeDom**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.Configuration.ConfigurationManager**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.Diagnostics.EventLog**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.DirectoryServices**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.Drawing.Common**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.Reflection.MetadataLoadContext**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.Security.Cryptography.Xml**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.Security.Permissions**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.Windows.Extensions**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **Microsoft.NETCore.Platforms**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.IO.Packaging**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **System.Resources.Extensions**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **Microsoft.NETCore.App.Ref**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **Microsoft.NETCore.App.Runtime.win-x64**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n  - **VS.Redist.Common.NetCore.SharedFramework.x64.7.0**: [from 7.0.0-preview.3.22166.1 to 7.0.0-preview.3.22171.6][30]\r\n\r\n[29]: https://github.com/dotnet/winforms/compare/f2eb3f7...4b4c7d5\r\n[30]: https://github.com/dotnet/runtime/compare/a5f3f96...ce81388\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:dd483b3f-65b0-44ab-f62d-08d8e93a0c51)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/6277","RelatedDescription":"Open PR \"[main] Update dependencies from dotnet/winforms\" (#6277)"},{"Id":"1173098427","IsPullRequest":true,"CreatedAt":"2022-03-18T01:53:00","Actor":"stephentoub","Number":"6276","RawContent":null,"Title":"Avoid unnecessary byte[] allocation in Baml2006Reader.Process_Header","State":"open","Body":"## Description\r\n\r\nBaml2006Reader.Process_Header skips past data from the reader, but it does so by calling BinaryReader.ReadBytes, which allocates, fills, and returns an array, which Process_Header promptly ignores.  We can instead just change the position on the stream, or worst case if it's not seekable, read into a temporarily rented array.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary array allocations.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal.","Url":"https://github.com/dotnet/wpf/pull/6276","RelatedDescription":"Open PR \"Avoid unnecessary byte[] allocation in Baml2006Reader.Process_Header\" (#6276)"},{"Id":"1172934909","IsPullRequest":true,"CreatedAt":"2022-03-17T21:23:54","Actor":"stephentoub","Number":"6275","RawContent":null,"Title":"Remove some unnecessary StringBuilders","State":"open","Body":"## Description\r\n\r\nThere are a bunch of StringBuilders being created that aren't necessary.  This removes some of them.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary overheads.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal (basically just if there were typos)","Url":"https://github.com/dotnet/wpf/pull/6275","RelatedDescription":"Open PR \"Remove some unnecessary StringBuilders\" (#6275)"},{"Id":"1172852904","IsPullRequest":true,"CreatedAt":"2022-03-17T19:59:12","Actor":"stephentoub","Number":"6274","RawContent":null,"Title":"Run some built-in .NET SDK perf analyzers over several WPF assemblies","State":"open","Body":"## Description\r\n\r\nOver the last several releases of .NET, the SDK has added a multitude of analyzers to help find and flag opportunities for perf improvements.  I ran several of those analyzers over a few of the assemblies and applied the auto-fixers; I also code reviewed each fix and tweaked a handfull.\r\n\r\n## Customer Impact\r\n\r\nMany of these changes contribute small but meaningful reductions in overhead.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6274","RelatedDescription":"Open PR \"Run some built-in .NET SDK perf analyzers over several WPF assemblies\" (#6274)"},{"Id":"1172828356","IsPullRequest":false,"CreatedAt":"2022-03-17T19:31:21","Actor":"NWoodsman","Number":"6273","RawContent":null,"Title":"System.Windows.Media.Pen.DashCap uses PenLineCap instead of PenDashCap","State":"open","Body":"* .NET Core Version: 6.0\r\n* Windows version: 10 build 19043.1586\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? **No**\r\n\r\n **Problem description:**\r\n\r\n`System.Windows.Media.Pen.DashCap` is of type `enum` `System.Windows.Media.PenLineCap` . The namespace has `enum` `System.Windows.Media.PenDashCap` which by the name seems to be the correct enum for this property. \r\n\r\nThe reference source for .Net 4.8 has the following (internal) comment reinforcing the mismatched type.\r\n\r\n```\r\n/// <summary>\r\n        /// Pen - Initializes the brush from the parameters.\r\n        /// </summary>\r\n        /// <param name=\"brush\"> The Pen's Brush. </param>\r\n        /// <param name=\"thickness\"> The Pen's thickness. </param>\r\n        /// <param name=\"startLineCap\"> The PenLineCap which applies to the start of the stroke. </param>\r\n        /// <param name=\"endLineCap\"> The PenLineCap which applies to the end of the stroke. </param>\r\n        /// <param name=\"dashCap\"> The PenDashCap which applies to the ends of each dash. </param> //<--------- Incorrect\r\n        /// <param name=\"lineJoin\"> The PenLineJoin. </param>\r\n        /// <param name=\"miterLimit\"> The miter limit. </param>\r\n        /// <param name=\"dashStyle\"> The dash style. </param>\r\n```\r\n\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n \r\nUse the `PenLineCap`  enum in the property `Pen.DashCap`\r\n\r\n **Expected behavior:**\r\n\r\nExpected to use `System.Windows.Media.PenDashCap` in the property `Pen.DashCap` \r\n \r\n **Minimal repro:**\r\n\r\nSee the docs:\r\n\r\nhttps://referencesource.microsoft.com/#PresentationCore/Core/CSharp/System/Windows/Media/Pen.cs,abab5dce39ebd2ad\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pendashcap?view=windowsdesktop-6.0\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pen?view=windowsdesktop-6.0\r\n\r\nMaybe `PenDashCap` should be removed from the namespace, I can't find any used instances of the enum.\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/6273","RelatedDescription":"Open issue \"System.Windows.Media.Pen.DashCap uses PenLineCap instead of PenDashCap\" (#6273)"},{"Id":"1172682594","IsPullRequest":true,"CreatedAt":"2022-03-17T18:02:10","Actor":"stephentoub","Number":"6272","RawContent":null,"Title":"Use span slice instead of substring in AbbreviatedGeometryParser.ReadNumber","State":"open","Body":"## Description\r\n\r\nAbbreviatedGeometryParser.ReadNumber is using Substring to pass to Convert.ToDouble the relevant portion of the string to parse. We can instead just pass in a span slice to double.Parse (which Convert.ToDouble delegates to after a null check that's irrelevant here).\r\n\r\n## Customer Impact\r\n\r\nUnnecessary allocations.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6272","RelatedDescription":"Open PR \"Use span slice instead of substring in AbbreviatedGeometryParser.ReadNumber\" (#6272)"},{"Id":"1172532689","IsPullRequest":true,"CreatedAt":"2022-03-17T16:11:10","Actor":"stephentoub","Number":"6271","RawContent":null,"Title":"Remove substring allocation from Baml2006Reader.Logic_GetFullXmlns","State":"open","Body":"## Description\r\n\r\nWhen getting the assembly name, we can slice out the piece that's needed rather than allocating a substring.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary string allocations.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6271","RelatedDescription":"Open PR \"Remove substring allocation from Baml2006Reader.Logic_GetFullXmlns\" (#6271)"},{"Id":"1172494985","IsPullRequest":true,"CreatedAt":"2022-03-17T15:44:08","Actor":"stephentoub","Number":"6270","RawContent":null,"Title":"Don't allocate fallback name in XamlNamespace.GetXamlType unless it's needed","State":"open","Body":"## Description\r\n\r\nXamlNamespace.GetXamlType is always concatenating a string together, but that string is only used on a fallback path.  So only create it on the fallback path.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary string allocation.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6270","RelatedDescription":"Open PR \"Don't allocate fallback name in XamlNamespace.GetXamlType unless it's needed\" (#6270)"},{"Id":"1172487002","IsPullRequest":true,"CreatedAt":"2022-03-17T15:38:52","Actor":"stephentoub","Number":"6269","RawContent":null,"Title":"Avoid exceptional string allocation in StaticExtension.ProvideValue","State":"open","Body":"## Description\r\n\r\nProvideValue is frequently creating a string that only ends up being used to populate an exception.  We can just delay creating the string until the exception is thrown so that we don't create it in success cases.\r\n\r\n## Customer Impact\r\n\r\nUnnecessary allocations meant only for an exceptional path showing up in success paths.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal","Url":"https://github.com/dotnet/wpf/pull/6269","RelatedDescription":"Open PR \"Avoid exceptional string allocation in StaticExtension.ProvideValue\" (#6269)"},{"Id":"1172394936","IsPullRequest":true,"CreatedAt":"2022-03-17T13:33:31","Actor":"stephentoub","Number":"6268","RawContent":null,"Title":"Remove unnecessary string and string[] allocations from MS.Internal.ContentType","State":"open","Body":"## Description\r\n\r\nMS.Internal.ContentType is incurring a multitude of unnecessary allocations.  It's parsing input by Substring'ing along it and Trim'ing along it to find the next piece, but only a subset of those strings are actually saved. It's using string.Split just to get two strings, resulting in a string[].  Etc.\r\n\r\n## Customer Impact\r\n\r\nApps using this indirectly incur unnecessary overhead.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal.","Url":"https://github.com/dotnet/wpf/pull/6268","RelatedDescription":"Open PR \"Remove unnecessary string and string[] allocations from MS.Internal.ContentType\" (#6268)"},{"Id":"1172314379","IsPullRequest":true,"CreatedAt":"2022-03-17T12:46:11","Actor":"dotnet-maestro[bot]","Number":"6267","RawContent":null,"Title":"[main] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:840bf684-917a-4879-f62c-08d8e93a0c51)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 840bf684-917a-4879-f62c-08d8e93a0c51\r\n- **Build**: 20220316.1\r\n- **Date Produced**: March 16, 2022 4:58:30 PM UTC\r\n- **Commit**: c90e2d9f3d3e2b471a078f949f2a2fea6af2627d\r\n- **Branch**: refs/heads/main\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: [from 7.0.0-beta.22157.6 to 7.0.0-beta.22166.1][1]\r\n  - **Microsoft.DotNet.Arcade.Sdk**: [from 7.0.0-beta.22157.6 to 7.0.0-beta.22166.1][1]\r\n  - **Microsoft.DotNet.ApiCompat**: [from 7.0.0-beta.22157.6 to 7.0.0-beta.22166.1][1]\r\n  - **Microsoft.DotNet.GenAPI**: [from 7.0.0-beta.22157.6 to 7.0.0-beta.22166.1][1]\r\n  - **Microsoft.DotNet.Helix.Sdk**: [from 7.0.0-beta.22157.6 to 7.0.0-beta.22166.1][1]\r\n\r\n[1]: https://github.com/dotnet/arcade/compare/81001b4...c90e2d9\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:840bf684-917a-4879-f62c-08d8e93a0c51)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/6267","RelatedDescription":"Closed or merged PR \"[main] Update dependencies from dotnet/arcade\" (#6267)"},{"Id":"1171883806","IsPullRequest":true,"CreatedAt":"2022-03-17T03:20:56","Actor":"ThomasGoulet73","Number":"6266","RawContent":null,"Title":"Disable Indeterminate animation when hiding ProgressBar","State":"open","Body":"Fixes dotnet/wpf#6264\r\n\r\n## Description\r\nDisable Indeterminate animation when hiding ProgressBar. Fixes a performance regression introduced in Aero2 theme (Windows 8 or newer)\r\n\r\n## Customer Impact\r\nBetter performance when hiding an indeterminate progress bar with the theme Aero2.\r\n\r\n## Regression\r\nPerformance regression introduced in Aero2 theme (Windows 8 or newer).\r\n\r\n## Testing\r\nTested with the sample in #6264 and a combination of Visibility and Indeterminate to validate that this PR does not break existing behavior.\r\n\r\n## Risk\r\nLow.","Url":"https://github.com/dotnet/wpf/pull/6266","RelatedDescription":"Open PR \"Disable Indeterminate animation when hiding ProgressBar\" (#6266)"},{"Id":"1171606060","IsPullRequest":true,"CreatedAt":"2022-03-16T22:08:16","Actor":"stephentoub","Number":"6265","RawContent":null,"Title":"Avoid unnecessary enumerator allocations in XamlDirective.GetHashCode","State":"open","Body":"## Description\r\n\r\nWe can just index into the ReadOnlyCollection rather than iterating it via IEnumerator.  We can also avoid unnecessary collection allocations when all of our internal usage that already has an immutable ReadOnlyCollection goes through the internal constructor.\r\n\r\n## Customer Impact\r\n\r\nThese XamlDirective instances are frequently stored in Dictionary's, resulting in every GetHashCode call by the dictionary allocating an enumerator.\r\n\r\n## Regression\r\n\r\nNo\r\n\r\n## Testing\r\n\r\nCI\r\n\r\n## Risk\r\n\r\nMinimal.","Url":"https://github.com/dotnet/wpf/pull/6265","RelatedDescription":"Open PR \"Avoid unnecessary enumerator allocations in XamlDirective.GetHashCode\" (#6265)"}],"ResultType":"GitHubIssue"}},"RunOn":"2022-03-23T03:30:31.6448577Z","RunDurationInMilliseconds":561}