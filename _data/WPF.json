{"Data":{"GitHub":{"Issues":[{"Id":"673973657","IsPullRequest":false,"CreatedAt":"2020-08-06T02:50:38","Actor":"heartacker","Number":"3309","RawContent":null,"Title":"window can't show in win 10/(win7work)","State":"open","Body":"please help me, please ✋ \r\n* .NET Core Version: (e.g. 3.0 Preview1, or daily build number, use `dotnet --info`)\r\n```\r\n.NET Core SDK（反映任何 global.json）:\r\n Version:   3.1.400\r\n Commit:    035fb2aa2f\r\n\r\n运行时环境:\r\n OS Name:     Windows\r\n OS Version:  10.0.14393\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.1.400\\\r\n\r\nHost (useful for support):\r\n  Version: 3.1.6\r\n  Commit:  3acd9b0cd1\r\n\r\n.NET Core SDKs installed:\r\n  3.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.400 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\n```\r\n* Windows version: (`winver`)\r\n![image](https://user-images.githubusercontent.com/1876302/89484381-fe6dce80-d7d0-11ea-8c1d-5542de682a45.png)\r\n\r\n\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes/No\r\nI don't know\r\n\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? If yes, please file the issue via the instructions [here](https://docs.microsoft.com/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019).\r\n \r\n **Problem description:**\r\n app hangs because of one window can't  show.\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nAPP hang \r\n- blank window can show\r\n- the same bin file: win7 run well/ win10 hang\r\n- the same bin x86 file: win7 run well/ win10 hang\r\n- the special-window-code(xaml and cs) has no change to an Previous bin.exe but the Previous bin.exe work well in win7/win10\r\n![image](https://user-images.githubusercontent.com/1876302/89484821-ee0a2380-d7d1-11ea-89d6-74f936558b5b.png)\r\n\r\n![image](https://user-images.githubusercontent.com/1876302/89484875-0ed27900-d7d2-11ea-85d9-661b156971f3.png)\r\n```log\r\n未标记\t>\t0x000031B8\t0x00000001\t主线程\t主线程\tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics\r\n \t \t \t \t \t \t[托管到本机的转换]\r\n \t \t \t \t \t \tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics(ushort* pGlyphIndices, uint glyphCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GlyphMetrics(ushort* pGlyphIndices, int characterCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics, double emSize, float pixelsPerDip, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsAndIndicesOptimized(uint* pCodepoints, int characterCount, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsOptimized(System.Windows.Media.TextFormatting.CharacterBufferRange characters, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Media.Typeface.CheckFastPathNominalGlyphs(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double scalingFactor, double widthMax, bool keepAWord, bool numberSubstitution, System.Globalization.CultureInfo cultureInfo, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways, bool breakOnTabs, out int stringLengthFit)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.CreateSimpleTextRun(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, System.Windows.Media.TextFormatting.TextRun textRun, MS.Internal.TextFormatting.TextFormatterImp formatter, int widthLeft, bool emergencyWrap, bool breakOnTabs, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.Create(MS.Internal.TextFormatting.FormatSettings settings, System.Windows.Media.TextFormatting.CharacterBufferRange charString, System.Windows.Media.TextFormatting.TextRun textRun, int cp, int cpFirst, int runLength, int widthLeft, int idealRunOffsetUnRounded, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleTextLine.Create(MS.Internal.TextFormatting.FormatSettings settings, int cpFirst, int paragraphWidth, double pixelsPerDip)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLineInternal(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\r\n \t \t \t \t \t \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLine(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.DockPanel.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Decorator.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Documents.AdornerDecorator.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.MeasureOverrideHelper(System.Windows.Size constraint)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.MeasureOverride(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.SetLayoutSize()\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisual.set(System.Windows.Media.Visual value)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetRootVisual()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetRootVisualAndUpdateSTC()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindow(bool duringShow)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindowDuringShow()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.SafeCreateWindowDuringShow()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.ShowHelper(object booleanBox)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Window.Show()\r\n \t \t \t \t \t \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.MainTpms.OpenFlash_SramBoard(object sender, System.Windows.RoutedEventArgs e) 行 274\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\r\n \t \t \t \t \t \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Controls.MenuItem.InvokeClickAfterRender(object arg)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.CallbackWrapper(object obj)\r\n \t \t \t \t \t \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue()\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)\r\n \t \t \t \t \t \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam)\r\n \t \t \t \t \t \t[本机到托管的转换]\r\n \t \t \t \t \t \t[托管到本机的转换]\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)\r\n \t \t \t \t \t \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run()\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)\r\n \t \t \t \t \t \tPresentationFramework.dll!System.Windows.Application.Run()\r\n \t \t \t \t \t \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.App.Main()\r\n\r\n\r\n```\r\n![image](https://user-images.githubusercontent.com/1876302/89484949-36c1dc80-d7d2-11ea-826a-c4577ca79f3b.png)\r\n\r\n```log\r\n \t[托管到本机的转换]\t\r\n \tDirectWriteForwarder.dll!MS.Internal.Text.TextInterface.FontFace.GetDesignGlyphMetrics(ushort* pGlyphIndices, uint glyphCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GlyphMetrics(ushort* pGlyphIndices, int characterCount, MS.Internal.Text.TextInterface.GlyphMetrics* pGlyphMetrics, double emSize, float pixelsPerDip, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsAndIndicesOptimized(uint* pCodepoints, int characterCount, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.GlyphTypeface.GetGlyphMetricsOptimized(System.Windows.Media.TextFormatting.CharacterBufferRange characters, double emSize, float pixelsPerDip, ushort[] glyphIndices, MS.Internal.Text.TextInterface.GlyphMetrics[] glyphMetrics, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways)\t未知\r\n \tPresentationCore.dll!System.Windows.Media.Typeface.CheckFastPathNominalGlyphs(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double scalingFactor, double widthMax, bool keepAWord, bool numberSubstitution, System.Globalization.CultureInfo cultureInfo, System.Windows.Media.TextFormattingMode textFormattingMode, bool isSideways, bool breakOnTabs, out int stringLengthFit)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.CreateSimpleTextRun(System.Windows.Media.TextFormatting.CharacterBufferRange charBufferRange, System.Windows.Media.TextFormatting.TextRun textRun, MS.Internal.TextFormatting.TextFormatterImp formatter, int widthLeft, bool emergencyWrap, bool breakOnTabs, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleRun.Create(MS.Internal.TextFormatting.FormatSettings settings, System.Windows.Media.TextFormatting.CharacterBufferRange charString, System.Windows.Media.TextFormatting.TextRun textRun, int cp, int cpFirst, int runLength, int widthLeft, int idealRunOffsetUnRounded, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.SimpleTextLine.Create(MS.Internal.TextFormatting.FormatSettings settings, int cpFirst, int paragraphWidth, double pixelsPerDip)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLineInternal(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\t未知\r\n \tPresentationCore.dll!MS.Internal.TextFormatting.TextFormatterImp.FormatLine(System.Windows.Media.TextFormatting.TextSource textSource, int firstCharIndex, double paragraphWidth, System.Windows.Media.TextFormatting.TextParagraphProperties paragraphProperties, System.Windows.Media.TextFormatting.TextLineBreak previousLineBreak, System.Windows.Media.TextFormatting.TextRunCache textRunCache)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Control.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.DockPanel.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCell(int cell, bool forceInfinityV)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureCellsGroup(int cellsHead, System.Windows.Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, out bool hasDesiredSizeUChanged)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Grid.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!MS.Internal.Helper.MeasureElementWithSingleChild(System.Windows.UIElement element, System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.ContentPresenter.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Decorator.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Documents.AdornerDecorator.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.Border.MeasureOverride(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.MeasureOverrideHelper(System.Windows.Size constraint)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.MeasureOverride(System.Windows.Size availableSize)\t未知\r\n \tPresentationFramework.dll!System.Windows.FrameworkElement.MeasureCore(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.Measure(System.Windows.Size availableSize)\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.SetLayoutSize()\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisualInternal.set(System.Windows.Media.Visual value)\t未知\r\n \tPresentationCore.dll!System.Windows.Interop.HwndSource.RootVisual.set(System.Windows.Media.Visual value)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetRootVisual()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetRootVisualAndUpdateSTC()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindow(bool duringShow)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.CreateSourceWindowDuringShow()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.SafeCreateWindowDuringShow()\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.ShowHelper(object booleanBox)\t未知\r\n \tPresentationFramework.dll!System.Windows.Window.Show()\t未知\r\n>\tATC.TPMS.GUI.dll!ATC.TPMS.GUI.MainTpms.OpenFlash_SramBoard(object sender, System.Windows.RoutedEventArgs e) 行 274\tC#\r\n \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs)\t未知\r\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args)\t未知\r\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e)\t未知\r\n \tPresentationFramework.dll!System.Windows.Controls.MenuItem.InvokeClickAfterRender(object arg)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state)\t未知\r\n \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.CallbackWrapper(object obj)\t未知\r\n \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tSystem.Private.CoreLib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tWindowsBase.dll!MS.Internal.CulturePreservingExecutionContext.Run(MS.Internal.CulturePreservingExecutionContext executionContext, System.Threading.ContextCallback callback, object state)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue()\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.TryCatchWhen(object source, System.Delegate callback, object args, int numArgs, System.Delegate catchHandler)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.LegacyInvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs)\t未知\r\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam)\t未知\r\n \t[本机到托管的转换]\t\r\n \t[托管到本机的转换]\t\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame)\t未知\r\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run()\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore)\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window)\t未知\r\n \tPresentationFramework.dll!System.Windows.Application.Run()\t未知\r\n \tATC.TPMS.GUI.dll!ATC.TPMS.GUI.App.Main()\t未知\r\n\r\n```\r\n **Expected behavior:**\r\n window can show\r\n **Minimal repro:**\r\n","Url":"https://github.com/dotnet/wpf/issues/3309","RelatedDescription":"Open issue \"window can't show in win 10/(win7work)\" (#3309)"},{"Id":"673841140","IsPullRequest":false,"CreatedAt":"2020-08-05T22:56:30","Actor":"davkean","Number":"3308","RawContent":null,"Title":"WPF tmpproj is excluding Microsoft.Net.Compilers.Toolset package ","State":"closed","Body":"**Version Used**: \r\nVersion 16.8.0 Preview 2.0 [30404.163.master]\r\n\r\n**Steps to Reproduce**:\r\n[Build.zip](https://github.com/dotnet/roslyn/files/5026511/Build.zip)\r\n\r\nFrom a VS developer prompt from the above version:\r\n\r\n1. `git clone http://github.com/dotnet/project-system`\r\n2. `cd project-system`\r\n3. `git checkout 90acd3b85ed4fa5eaef154f71d480800332a9946`\r\n4. `build.cmd`\r\n \r\n**Expected Behavior**:\r\nNo errors\r\n\r\n**Actual Behavior**:\r\n\r\nErrors because we're picking up csc from the VS directory instead of the package we're using:\r\n\r\n```\r\nG:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\ProjectSystem\\VS\\Waiting\\VisualStudioWaitIndicator.cs(101,24): error CS8619: Nullability of reference types in value of type '\r\n(WaitIndicatorResult Canceled, T?)' doesn't match target type '(WaitIndicatorResult, T)'. [G:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\Microsoft.VisualStudio.ProjectSyste\r\nm.Managed.VS_jrfzhkfp_wpftmp.csproj]\r\nG:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\ProjectSystem\\VS\\Waiting\\VisualStudioWaitIndicator.cs(108,24): error CS8619: Nullability of reference types in value of type '\r\n(WaitIndicatorResult Canceled, T?)' doesn't match target type '(WaitIndicatorResult, T)'. [G:\\project-system\\src\\Microsoft.VisualStudio.ProjectSystem.Managed.VS\\Microsoft.VisualStudio.ProjectSyste\r\nm.Managed.VS_jrfzhkfp_wpftmp.csproj]\r\n```\r\n\r\nRelated part of the build log:\r\n\r\n![image](https://user-images.githubusercontent.com/1103906/89379155-9ff51180-d738-11ea-93eb-a19cfe7a73a7.png)\r\n","Url":"https://github.com/dotnet/wpf/issues/3308","RelatedDescription":"Closed issue \"WPF tmpproj is excluding Microsoft.Net.Compilers.Toolset package \" (#3308)"},{"Id":"673821938","IsPullRequest":true,"CreatedAt":"2020-08-05T20:19:40","Actor":"wli3","Number":"3307","RawContent":null,"Title":"Update to net5.0 template with backcompact","State":"open","Body":"Port https://github.com/dotnet/wpf/pull/3302","Url":"https://github.com/dotnet/wpf/pull/3307","RelatedDescription":"Open PR \"Update to net5.0 template with backcompact\" (#3307)"},{"Id":"673636398","IsPullRequest":false,"CreatedAt":"2020-08-05T16:08:02","Actor":"indinfer","Number":"3306","RawContent":null,"Title":"DataGrid bound to List does not allow adding new rows","State":"closed","Body":"* .NET Core Version: 3.1\r\n* Windows version: Microsoft Windows 10 Pro Version 10.0.19041 Build 19041\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g., XAML Designer, Code editing, etc...)? No\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n\r\nI do not believe this is an actual defect. I hope to learn what I am missing or to understand the behavior.\r\n\r\n **Problem description:**\r\nI run a DataGrid with ItemsSource = a List<>.\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nI run the program. DataGrid allows deleting and changing rows. DataGrid does not allow adding rows.\r\n \r\n **Expected behavior:**\r\nDataGrid should allow adding rows.\r\n \r\n **Minimal repro:**\r\nXaml:\r\n`<Window\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n        xmlns:local=\"clr-namespace:myNamespace\"\r\n        xmlns:Schema=\"clr-namespace:System.Xml.Schema;assembly=System.Xml.ReaderWriter\" x:Class=\"myNamespace.MainWindow\"\r\n        mc:Ignorable=\"d\"\r\n        Title=\"MainWindow\" Height=\"350\" Width=\"600\">\r\n    <Grid>\r\n        <DataGrid x:Name=\"dataGrid\" AutoGenerateColumns=\"False\" CanUserAddRows=\"True\"   >\r\n            <DataGrid.Columns>\r\n                <DataGridTextColumn x:Name=\"col_id\" Width=\"200\" Header=\"Col ID\"  Binding=\"{Binding value_id}\" />\r\n                <DataGridTextColumn x:Name=\"col_1\" Width=\"200\" Header=\"Col One\"  Binding=\"{Binding value_1}\" />\r\n                <DataGridTextColumn x:Name=\"col_2\" Width=\"200\" Header=\"Col Two\"  Binding=\"{Binding value_2}\" />\r\n            </DataGrid.Columns>\r\n        </DataGrid>\r\n\r\n    </Grid>\r\n</Window>\r\n`\r\n\r\nCode Behind:\r\n`using System.Collections.Generic;\r\nusing System.Collections.ObjectModel;\r\nusing System.Windows;\r\n\r\nnamespace myNamespace\r\n{\r\n    /// <summary>\r\n    /// Interaction logic for MainWindow.xaml\r\n    /// </summary>\r\n    public partial class MainWindow : Window\r\n    {\r\n        public MainWindow()\r\n        {\r\n            InitializeComponent();\r\n\r\n            init_item_list();\r\n            dataGrid.ItemsSource = _itemList;\r\n        }\r\n\r\n\r\n        private List<DataItem> _itemList = new List<DataItem>();\r\n        public List<DataItem> ItemList\r\n        {\r\n            get { return _itemList; }\r\n            set { _itemList = value; }\r\n        }\r\n\r\n        public void init_item_list()\r\n        {\r\n            _itemList.Add(new DataItem(1, \"one\", \"i\"));\r\n            _itemList.Add(new DataItem(2, \"two\", \"ii\"));\r\n            _itemList.Add(new DataItem(3, \"three\", \"ii\"));\r\n        }\r\n        public class DataItem\r\n        {\r\n            public DataItem(int id, string val_1, string val_2)\r\n            {\r\n                value_id = id;\r\n                value_1 = val_1;\r\n                value_2 = val_2;\r\n            }\r\n            private int _value_id;\r\n            public int value_id\r\n            {\r\n                get { return _value_id; }\r\n                set { _value_id = value; }\r\n            }\r\n\r\n            private string _value_1;\r\n            public string value_1\r\n            {\r\n                get { return _value_1; }\r\n                set { _value_1 = value; }\r\n            }\r\n\r\n            private string _value_2;\r\n            public string value_2\r\n            {\r\n                get { return _value_2; }\r\n                set { _value_2 = value; }\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n}\r\n`\r\n\r\nHere is how it appears:\r\n\r\n![DataGrid bound to List](https://user-images.githubusercontent.com/8902149/89432421-19780a00-d70f-11ea-972c-4a1583ce015e.png)\r\n\r\nThere is no blank line for adding a new row.\r\n\r\nNote that in Xaml, I explicitly set `CanUserAddRows=\"True\"` \r\n\r\nI thought I saw DataGrid bound to a List allowing adding rows. But I need some help to see what the difference is between what I did before or what I saw before and the code I have in this post. \r\n\r\nHow do I get DataGrid bound to a List to allow adding rows?","Url":"https://github.com/dotnet/wpf/issues/3306","RelatedDescription":"Closed issue \"DataGrid bound to List does not allow adding new rows\" (#3306)"},{"Id":"673518906","IsPullRequest":true,"CreatedAt":"2020-08-05T13:12:10","Actor":"dotnet-maestro[bot]","Number":"3305","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200805.2\r\n- **Date Produced**: 8/5/2020 12:48 PM\r\n- **Commit**: 71d8cb94ba1614d788967d95d34855b92c09d3e6\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20404.2 to 5.0.0-preview.8.20405.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3305","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3305)"},{"Id":"673004642","IsPullRequest":false,"CreatedAt":"2020-08-04T18:55:32","Actor":"Vafnir","Number":"3304","RawContent":null,"Title":"UI Bug","State":"open","Body":"* .NET Core Version: 5.0.100-preview.7.20366.6\r\n* Windows version: 1909\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?:  No\r\n\r\n![g54g](https://user-images.githubusercontent.com/37485150/89332765-9cac4800-d69c-11ea-97a8-8a15eb66c163.gif)\r\n \r\n **Actual behavior:** The board disappears when the window loses focus.\r\n","Url":"https://github.com/dotnet/wpf/issues/3304","RelatedDescription":"Open issue \"UI Bug\" (#3304)"},{"Id":"672829440","IsPullRequest":true,"CreatedAt":"2020-08-04T14:33:22","Actor":"dotnet-maestro[bot]","Number":"3303","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200804.2\r\n- **Date Produced**: 8/4/2020 2:07 PM\r\n- **Commit**: 7739bce4872714b7492280d7b33c08e83c436ee0\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20403.2 to 5.0.0-preview.8.20404.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3303","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3303)"},{"Id":"671747616","IsPullRequest":false,"CreatedAt":"2020-08-04T00:23:53","Actor":"indinfer","Number":"3299","RawContent":null,"Title":"DatePicker in DataGrid loses data","State":"closed","Body":"* .NET Core Version: 3.5\r\n* Windows version: Microsoft Windows 10 Pro\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? No.\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\nDataGrid has DatePicker embedded. Enter a date in the Date column (DatePicker). Tab to the next column. Enter data. Then observe that the Date column goes blank, losing the date. The date should stay.\r\n \r\n **Actual behavior:**\r\nDate column goes blank.\r\n \r\n **Expected behavior:**\r\nDate column should retain the entered date. \r\n\r\n **Minimal repro:**\r\nSteps to the problem.\r\n\r\n[iacc_core.zip](https://github.com/dotnet/wpf/files/5013526/iacc_core.zip)\r\nSetup:\r\n\r\nUnzip iacc_core.zip into a directory of your choosing.\r\n\r\nSubdirectory acc_db contains MySQL schema and data. Hopefully, you can do a data import in MySQL Workbench to load test scheme with test data. \r\n\r\nYou will need to adjust directory paths and set up database connections.\r\n\r\nSteps:\r\n\r\n1. Compile and Run (i.e. Press F5 in Visual Studio).\r\nObserve: The program opens. Focus is on the last row of the top DataGrid (Transactions).\r\n\r\n2. Tab twice, then enter date \"7/20/2020\".\r\nObserve date \"7/20/2020\" showing in DataPicker.\r\n\r\n3. Tab once to \"Ref\" column. Type \"2\".\r\nObserve the problem: DatePicker date disappears. The date should stay.\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/3299","RelatedDescription":"Closed issue \"DatePicker in DataGrid loses data\" (#3299)"},{"Id":"672403447","IsPullRequest":true,"CreatedAt":"2020-08-03T23:34:22","Actor":"wli3","Number":"3302","RawContent":null,"Title":"Update to net5.0 template with backcompact","State":"open","Body":"Works for\r\n\r\n```\r\n dotnet new wpf -n wpf1 -f netcoreapp3.1\r\n dotnet new wpf -n wpf2\r\n dotnet new wpf -n wpf3 -f netcoreapp3.1 --target-framework-override net461\r\n dotnet new wpf -n wpf3 -f net5.0 --target-framework-override net6.0\r\n dotnet new wpf -n wpf4 -f net5.0 --target-framework-override net6.0\r\n```","Url":"https://github.com/dotnet/wpf/pull/3302","RelatedDescription":"Open PR \"Update to net5.0 template with backcompact\" (#3302)"},{"Id":"672339239","IsPullRequest":true,"CreatedAt":"2020-08-03T23:33:53","Actor":"wli3","Number":"3301","RawContent":null,"Title":"[Sample no merge] Update to net5.0 template with back compact","State":"closed","Body":"","Url":"https://github.com/dotnet/wpf/pull/3301","RelatedDescription":"Closed or merged PR \"[Sample no merge] Update to net5.0 template with back compact\" (#3301)"},{"Id":"672156881","IsPullRequest":true,"CreatedAt":"2020-08-03T15:41:42","Actor":"dotnet-maestro[bot]","Number":"3300","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200803.2\r\n- **Date Produced**: 8/3/2020 3:18 PM\r\n- **Commit**: e5cdeaa164f2b1f14e79df05389d04195c4d18d6\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20401.2 to 5.0.0-preview.8.20403.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3300","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3300)"},{"Id":"670858507","IsPullRequest":true,"CreatedAt":"2020-08-01T13:19:55","Actor":"dotnet-maestro[bot]","Number":"3298","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200801.2\r\n- **Date Produced**: 8/1/2020 1:02 PM\r\n- **Commit**: f156a59f7e5bf708ca56f03bae698060ee9f014a\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20381.2 to 5.0.0-preview.8.20401.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3298","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3298)"},{"Id":"670253657","IsPullRequest":false,"CreatedAt":"2020-07-31T21:31:39","Actor":"NotThatBen","Number":"3297","RawContent":null,"Title":"Wrong behaviour of DataGridCellInfo Equality operator.","State":"open","Body":"* .NET Core Version: (e.g. 3.0 Preview1, or daily build number, use `dotnet --info`) - **Any**\r\n* Windows version: (`winver`) - **Win7**\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes/No - **Yes**\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? If yes, please file the issue via the instructions [here](https://docs.microsoft.com/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019). - **No**\r\n* Security issues and bugs should be reported privately, learn more via our [responsible disclosure guidelines](https://github.com/dotnet/wpf/blob/master/README.md#reporting-security-issues-and-security-bugs). - **Not Related**\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\nDataGridCellInfo equality operator returns wrong result when virtualization enabled.\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nEquality operator returns _false_ instead _true_ on the same cell. Disabling _RowVirtualization_ eliminate this issue.\r\n \r\n **Expected behavior:**\r\nObvious...\r\n \r\n **Minimal repro:**\r\n_DataGrid_ with _RowVirtualization_ enabled and enough items in source collection to run in virtualization. Create _DataGridCellInfo_ object for any cell, keep it, then scroll to hide that cell (virtualize). Then create another _CellInfo_ for any visible cell. Then scroll back to first cell, create _CellInfo_ again and make \"==\"-ing. \r\n \r\n","Url":"https://github.com/dotnet/wpf/issues/3297","RelatedDescription":"Open issue \"Wrong behaviour of DataGridCellInfo Equality operator.\" (#3297)"},{"Id":"669900980","IsPullRequest":false,"CreatedAt":"2020-07-31T14:54:39","Actor":"mrlacey","Number":"3296","RawContent":null,"Title":"Expose more AutomationProperties","State":"open","Body":"The currently available AutomationProperties require lots of work to fully control the UI Automation/Accessibility Tree and produce the best possible experience for ALL people using our software.\r\n\r\nAs an example, if I have a TextBlock containing a symbol (via an appropriate font) that is purely visual and next to another TextBlock that contains displayed text relating to the symbol, there is no easy way to hide the symbol TextBlock from the UIA tree.\r\nThe only way to do this seems to be to derive from the TextBlock and access the automation per directly to set `IsControl` and `IsContent` accordingly. That seems complex and unnecessary just to hide a symbol from the UIA Tree.\r\n\r\nIn UWP there is the [AccessibilityView](https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.automation.peers.accessibilityview) property that makes it easy to set this from XAML.\r\nThat would be a start.\r\nEven better would be exposing AutomationProperties for all the [AutomationElementIdentifiers](https://docs.microsoft.com/en-us/dotnet/api/system.windows.automation.automationelementidentifiers?view=netcore-3.1).\r\n\r\n\r\n\r\n","Url":"https://github.com/dotnet/wpf/issues/3296","RelatedDescription":"Open issue \"Expose more AutomationProperties\" (#3296)"},{"Id":"669779155","IsPullRequest":true,"CreatedAt":"2020-07-31T12:54:45","Actor":"dotnet-maestro[bot]","Number":"3295","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200731.2\r\n- **Date Produced**: 7/31/2020 12:35 PM\r\n- **Commit**: 4463395f711e9d2b7627864824457cc68c94e41c\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20380.2 to 5.0.0-preview.8.20381.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3295","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3295)"},{"Id":"669706931","IsPullRequest":false,"CreatedAt":"2020-07-31T11:15:21","Actor":"lindexi","Number":"3294","RawContent":null,"Title":"Enable DirectManipulation","State":"open","Body":"See: [Direct Manipulation - Win32 apps | Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/api/_directmanipulation/ )","Url":"https://github.com/dotnet/wpf/issues/3294","RelatedDescription":"Open issue \"Enable DirectManipulation\" (#3294)"},{"Id":"669075609","IsPullRequest":false,"CreatedAt":"2020-07-30T18:43:26","Actor":"vsfeedback","Number":"3293","RawContent":null,"Title":".NET Core 3.1 WPF Project build fails when project has a long path","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/1117902/net-core-31-wpf-project-build-fails-when-project-h.html)._\n\n---\nVS 2019 Pro\nCore 3.1\nWPF\n\nWhen building a WPF that is within a deep path, the build fails with the following:\n\n>C:\\Program Files\\dotnet\\sdk\\3.1.301\\Sdks\\Microsoft.NET.Sdk.WindowsDesktop\\targets\\Microsoft.WinFX.targets(225,9): error MC1000: Unknown build error, 'Could not find a part of the path 'C:\\<long project path>\\obj\\Debug\\netcoreapp3.1\\<project name>_MarkupCompile.cache'.'\n\nMy project root folder path is 142 chars.\nMy project name is 39 chars.\nThe resuling intermediate MarkupCompile.cache path is 267 chars.\n\nIf I change the path of the project, the compile succeeds. The project builds successfully directly from msbuild.\n\nThank you.\n\n---\n### Original Comments\n\n#### Feedback Bot on 7/19/2020, 07:03 PM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/3293","RelatedDescription":"Open issue \".NET Core 3.1 WPF Project build fails when project has a long path\" (#3293)"},{"Id":"669074315","IsPullRequest":false,"CreatedAt":"2020-07-30T18:42:11","Actor":"vsfeedback","Number":"3292","RawContent":null,"Title":"Unknown build error, 'An item with the same key has already been added.","State":"open","Body":"_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/content/problem/853708/unknown-build-error-an-item-with-the-same-key-has.html)._\n\n---\nWorking on WPF .NET Core 3.1 application and getting this error on first compile after edditing source code, no error if I rebuild it for the second time.  VS 16.4.0 Pro.\n\nError\tRG1000\tUnknown build error, 'An item with the same key has already been added.' \tVtsr\tC:\\Program Files\\dotnet\\sdk\\3.1.100\\Sdks\\Microsoft.NET.Sdk.WindowsDesktop\\targets\\Microsoft.WinFX.targets\t672\n\n---\n### Original Comments\n\n#### Feedback Bot on 12/11/2019, 11:27 PM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n\n#### Feedback Bot on 1/16/2020, 05:46 PM: \n\nI have detected that for the last 35 days, this issue didn't have much product team activity and a very small amount of new votes or comments. Based on this, its severity, and affected area, it’s my experience that this issue is very unlikely to be fixed.\n#### Peter Czurak on 1/16/2020, 06:13 PM: \n\n<p>Yeah, more bugs in the product. Just amazing!</p><p>A bug is not a bug if Visual Studio Team has to fix it.</p>\n\n#### Karlsson, Henrik on 6/17/2020, 10:48 AM: \n\n<p>It would be amazing if this error could give more information. I'm currently running in to the same problem (.net core 3.1 on visual studio 16.7.0 Preview 2.0 and I just can't figure out what it is.. I've more or less stripped my project down to the bones. Maybe the \"item\" could be named in that error?</p><p>C:\\Program Files\\dotnet\\sdk\\3.1.400-preview-015151\\Sdks\\Microsoft.NET.Sdk.WindowsDesktop\\targets\\Microsoft.WinFX.targets(672,5): error RG1000: Unknown build error, 'An item with the same key has already been added.'</p>\n\n#### Fabian Toader [MSFT] on 6/24/2020, 10:42 AM: \n\n<p>Can you please attach a simple repro project? Thanks!</p>\n\n#### Karlsson, Henrik on 6/25/2020, 02:26 PM: \n\n<p>ok, I figured out why this was happening in our projects.</p><p>It seems like .net core does not like xaml files with the same names inside the same csproj. I had to rename a bunch of xaml files to give them all unique names within the same csproj.</p><p>That's where I noticed that we had multiple Generic.xaml in the same csproj and the Themes one referenced the other.. somehow both got picked up independently so the referenced one was added twice and that way caused \"same key\" problem.</p><p>I renamed one of the Generic.xaml to some other name and referenced that instead and problem went away.</p><p>I don't know if this is the same problem <a rel=\"user\" href=\"https://developercommunity.visualstudio.com/users/1587/8adaea9a-8720-48a9-adba-5323b4521494.html\" nodeid=\"1587\">@Peter Czurak</a> had but it is not totally unlikely :-)</p><p>(The problem for generic.xaml actually goes away on second compile (somehow ends up hidden) but caused infinite loops during runtime load in some cases)</p>\n\n#### Karlsson, Henrik on 6/26/2020, 11:43 AM: \n\n<p>ok, I have even more info. We don't have our csproj files in the same path as the source code (the xaml and cs files) and it seems like if that is the case the intermediate files are just flattened in to one folder... causing problems when two files have the same name.</p><p>so example:</p><p>c:\\dev\\myproj\\myproj.csproj</p><p>have links to</p><p>c:\\dev\\mysource\\a.xaml</p><p>c:\\dev\\ mysource\\folder\\a.xaml</p><p>Both these files write intermediate files to the same folder and overwrite each other</p><p>It feels like maybe in these cases the path to the intermediate file should be based on the &lt;link&gt; metadata in the csproj file?</p>\n\n\n---\n### Original Solutions\n(no solutions)","Url":"https://github.com/dotnet/wpf/issues/3292","RelatedDescription":"Open issue \"Unknown build error, 'An item with the same key has already been added.\" (#3292)"},{"Id":"668702646","IsPullRequest":true,"CreatedAt":"2020-07-30T13:21:11","Actor":"dotnet-maestro[bot]","Number":"3291","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200730.2\r\n- **Date Produced**: 7/30/2020 12:55 PM\r\n- **Commit**: 02747e9978cc867fe424612c6c1851f38d7706ab\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20379.2 to 5.0.0-preview.8.20380.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3291","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3291)"},{"Id":"668616267","IsPullRequest":false,"CreatedAt":"2020-07-30T11:09:10","Actor":"usernamedd","Number":"3290","RawContent":null,"Title":"when debugging an error occurs System.IO.FileNotFoundException:“Could not load file or assembly 'PresentationFramework","State":"open","Body":"details below \r\nSystem.IO.FileNotFoundException:“Could not load file or assembly 'PresentationFramework, Version=42.42.42.42, Culture=neutral, PublicKeyToken=31bf3856ad364e35\r\n\r\n after building succefully , I add an project named wpfapp1 target netcore5.0 and then add references to other project in the wpf sln . Complie and run , it occurs that presentationFramework file could not loaded ,but the file is at the same directory with wpfapp1.exe\r\n\r\nsome suggest?","Url":"https://github.com/dotnet/wpf/issues/3290","RelatedDescription":"Open issue \"when debugging an error occurs System.IO.FileNotFoundException:“Could not load file or assembly 'PresentationFramework\" (#3290)"},{"Id":"668006740","IsPullRequest":true,"CreatedAt":"2020-07-29T17:26:10","Actor":"dotnet-maestro[bot]","Number":"3289","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200729.2\r\n- **Date Produced**: 7/29/2020 5:05 PM\r\n- **Commit**: 8cfe0dbe0710ff5064b4d418563c3d126f07887d\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20376.2 to 5.0.0-preview.8.20379.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3289","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3289)"},{"Id":"667961059","IsPullRequest":true,"CreatedAt":"2020-07-29T16:30:37","Actor":"dotnet-maestro[bot]","Number":"3288","RawContent":null,"Title":"[master] Update dependencies from dotnet/arcade","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n## From https://github.com/dotnet/arcade\r\n- **Subscription**: 3a1d3bb6-c64d-406d-e8f4-08d648cf64cb\r\n- **Build**: 20200724.1\r\n- **Date Produced**: 7/24/2020 3:41 PM\r\n- **Commit**: f6192d1e284a08ac05041d05fa6e60dec74b24f5\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.CodeAnalysis**: from 5.0.0-beta.20364.3 to 5.0.0-beta.20374.1\r\n  - **Microsoft.DotNet.GenAPI**: from 5.0.0-beta.20364.3 to 5.0.0-beta.20374.1\r\n  - **Microsoft.DotNet.Helix.Sdk**: from 5.0.0-beta.20364.3 to 5.0.0-beta.20374.1\r\n  - **Microsoft.DotNet.Arcade.Sdk**: from 5.0.0-beta.20364.3 to 5.0.0-beta.20374.1\r\n  - **Microsoft.DotNet.ApiCompat**: from 5.0.0-beta.20364.3 to 5.0.0-beta.20374.1\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:3a1d3bb6-c64d-406d-e8f4-08d648cf64cb)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3288","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dotnet/arcade\" (#3288)"},{"Id":"667102193","IsPullRequest":false,"CreatedAt":"2020-07-28T14:06:27","Actor":"manju-summoner","Number":"3287","RawContent":null,"Title":"Check mark of checked MenuItem on ToolBar is not visible","State":"open","Body":"* .NET Core Version: 3.1.302\r\n* Windows version: 19041.388\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? If yes, please file the issue via the instructions [here](https://docs.microsoft.com/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019). : No\r\n* Security issues and bugs should be reported privately, learn more via our [responsible disclosure guidelines](https://github.com/dotnet/wpf/blob/master/README.md#reporting-security-issues-and-security-bugs).\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\nCheckbox bakcground color of Checked MenuItem  placed on ToolBar is black.\r\n\r\nAero2 Theme (Windows10 Default Theme / PresentationFramework.Aero2)\r\n![image](https://user-images.githubusercontent.com/57256282/88674046-48491b80-d124-11ea-989c-d08a6b53d787.png)\r\n\r\nAero Theme (PresentationFramework.Aero)\r\n![image](https://user-images.githubusercontent.com/57256282/88686578-31a9c100-d132-11ea-8489-7619a7104504.png)\r\n\r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\nCheckbox is filled with black and the check mark is not visible\r\n\r\n **Expected behavior:**\r\nSpecify an appropriate color to `ToolBarMenuCheckFill`.\r\n\r\nhttps://github.com/dotnet/wpf/blob/8920b2d117e115edbb793fbe8bde28c8a36e3b2d/src/Microsoft.DotNet.Wpf/src/Themes/XAML/ToolBar.xaml#L280\r\n\r\n **Minimal repro:**\r\n```xaml\r\n<ToolBarTray>\r\n    <ToolBar>\r\n        <Menu>\r\n            <MenuItem Header=\"Menu\">\r\n                <MenuItem Header=\"CheckedMenuItem\" IsCheckable=\"True\" IsChecked=\"True\"/>\r\n            </MenuItem>\r\n        </Menu>\r\n    </ToolBar>\r\n</ToolBarTray>\r\n``` \r\n","Url":"https://github.com/dotnet/wpf/issues/3287","RelatedDescription":"Open issue \"Check mark of checked MenuItem on ToolBar is not visible\" (#3287)"},{"Id":"666694060","IsPullRequest":true,"CreatedAt":"2020-07-28T01:58:26","Actor":"benaadams","Number":"3286","RawContent":null,"Title":"Less allocatey GetFullXmlns","State":"open","Body":"From https://github.com/dotnet/wpf/pull/3278 /cc @pentp","Url":"https://github.com/dotnet/wpf/pull/3286","RelatedDescription":"Open PR \"Less allocatey GetFullXmlns\" (#3286)"},{"Id":"666680408","IsPullRequest":true,"CreatedAt":"2020-07-28T01:13:12","Actor":"benaadams","Number":"3285","RawContent":null,"Title":"Use char.{Last}IndexOf","State":"open","Body":"Follow up to https://github.com/dotnet/wpf/pull/3278","Url":"https://github.com/dotnet/wpf/pull/3285","RelatedDescription":"Open PR \"Use char.{Last}IndexOf\" (#3285)"},{"Id":"664899366","IsPullRequest":false,"CreatedAt":"2020-07-27T18:19:14","Actor":"jpapp05","Number":"3280","RawContent":null,"Title":"WPF Conversion issue to .NET Core 3.1","State":"closed","Body":"We are converting a large commercial WPF application over to .NET Core 3.1 and have run into a problem that I'm not sure how to resolve.   \r\n\r\n```error CS0433: The type 'ListBoxChrome' exists in both 'PresentationFramework.Aero, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35' and 'PresentationFramework.Aero2, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'```\r\n\r\n This error happens in .NET Core because by default it pulls in ALL of the WPF assembles as references.  Unfortunately, both PresentationFramework.Aero and PresentationFramework.Aero2 assemblies define the **same class** under the **same namespace**.\r\n\r\nOur xaml namespace looks like this:\r\n\r\n```xmlns:mwt=\"clr-namespace:Microsoft.Windows.Themes;assembly=PresentationFramework.Aero\"```\r\n\r\nI'm assuming the issue is that the C# generated by the \"code-behind\" process for our xaml, has no way of distinguishing which assembly this comes from as both assemblies use the same namespace.\r\n\r\nIn .NET Framework, this was never an issue because you had control over which assemblies were referenced by your projects.\r\n\r\nHow does one workaround this?  \r\n\r\nThanks much,\r\nJames\r\n","Url":"https://github.com/dotnet/wpf/issues/3280","RelatedDescription":"Closed issue \"WPF Conversion issue to .NET Core 3.1\" (#3280)"},{"Id":"665773077","IsPullRequest":true,"CreatedAt":"2020-07-26T12:56:22","Actor":"dotnet-maestro[bot]","Number":"3284","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200726.2\r\n- **Date Produced**: 7/26/2020 12:33 PM\r\n- **Commit**: 92707480ae59f710a54d49f367458d2eb2853d81\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20374.2 to 5.0.0-preview.8.20376.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3284","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3284)"},{"Id":"665730341","IsPullRequest":true,"CreatedAt":"2020-07-26T07:51:32","Actor":"ghost1372","Number":"3283","RawContent":null,"Title":"Fix typo in code comments","State":"open","Body":"Fix typo in code comments ","Url":"https://github.com/dotnet/wpf/pull/3283","RelatedDescription":"Open PR \"Fix typo in code comments\" (#3283)"},{"Id":"665572413","IsPullRequest":false,"CreatedAt":"2020-07-25T11:55:24","Actor":"yanxiaodi","Number":"3282","RawContent":null,"Title":"The TreeViewItem cannot stretch correctly","State":"open","Body":"* .NET Core Version: all \r\n* Windows version: all\r\n* Does the bug reproduce also in WPF for .NET Framework 4.8?: Yes\r\n* Is this bug related specifically to tooling in Visual Studio (e.g. XAML Designer, Code editing, etc...)? No.\r\n\r\n <!-- Read https://github.com/dotnet/wpf/blob/master/Documentation/issue-guide.md -->\r\n \r\n **Problem description:**\r\n Usually we can reset the style of the ItemContainer for some controls to reset some properties like HorizontalAlignment, but for TreeView, we can not stretch the TreeViewItem by setting the TreeViewItemContainer. We can find quite a few posts regarding this issue, eg:\r\nhttps://stackoverflow.com/questions/47258955/how-to-stretch-treeviewitem-width-to-fill-parent\r\nhttps://stackoverflow.com/questions/16374182/background-in-treeviewitem-not-full-width\r\nhttps://leecampbell.com/2009/01/14/horizontal-stretch-on-treeviewitems/\r\n\r\nThe reason has been described in the above post. Because the ControlTemplate of the TreeViewItem has a grid with a 3×2 Grid. \r\n The below content is copied from the [post](https://leecampbell.com/2009/01/14/horizontal-stretch-on-treeviewitems/)\r\n> Things to note here is that the layout is controlled with a 3×2 Grid. Now notice that the Border that encapsulates the ContentPresenter (the place holder for where your values will live) is set to live in column 1 (remember 0 based index rules apply here). Also notice that the ItemsPresenter (the place holder for all the children of a TreeViewItem) is set to row 1 and column 1 & 2 (Grid.Column=”1″ Grid.ColumnSpan=”2″). Ok, so now that we know that we look back up to the Grid and notice that the column definitions are such that Column 1 has Width=”Auto” and Column 2 has Width=”*”. This effectively says column 1 can never effectively stretch.\r\n \r\n **Actual behavior:** <!-- callstack for crashes / exceptions -->\r\n Even we reset the style of TreeViewItemContainer to make the `HorizontalAlignment` property as `Stretch`, it will not work because the width of third column is `*`.\r\n\r\n **Expected behavior:**\r\n The TreeView control should allow users to reset the ItemContainer style to stretch the item.\r\n\r\nThe reason I raise this issue is for some reason, I need to attach events to the TreeViewItem, eg. tapped, it only works when we click the TextBlock or Image controls in the TreeViewItem. The empty space in the TreeViewItem is not clickable. So we have to find a easy way to make the container to stretch but for this scenario, changing the style of the TreeViewItemContainer will not work.\r\n![image](https://user-images.githubusercontent.com/3395915/88456531-864f0100-ced2-11ea-8b8e-4b5be3aab28f.png)\r\n\r\n\r\nI think the easiest way is to re-design the layout of the ControlTemplate of the TreeView to allow users stretch the item content. eg. remove the third column and set the column width of column 2 as `*`. Not sure if we have better solutions. Thanks.\r\n","Url":"https://github.com/dotnet/wpf/issues/3282","RelatedDescription":"Open issue \"The TreeViewItem cannot stretch correctly\" (#3282)"},{"Id":"665151327","IsPullRequest":true,"CreatedAt":"2020-07-24T13:23:41","Actor":"dotnet-maestro[bot]","Number":"3281","RawContent":null,"Title":"[master] Update dependencies from dnceng/internal/dotnet-wpf-int","State":"closed","Body":"This pull request updates the following dependencies\r\n\r\n[marker]: <> (Begin:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n## From https://dev.azure.com/dnceng/internal/_git/dotnet-wpf-int\r\n- **Subscription**: 46a15fe4-6c2c-480d-9cdd-08d71053b252\r\n- **Build**: 20200724.2\r\n- **Date Produced**: 7/24/2020 12:46 PM\r\n- **Commit**: 65bd38a475eee5aeadb8707f194387fefa19ea68\r\n- **Branch**: refs/heads/master\r\n\r\n[DependencyUpdate]: <> (Begin)\r\n\r\n- **Updates**:\r\n  - **Microsoft.DotNet.Wpf.DncEng**: from 5.0.0-preview.8.20367.2 to 5.0.0-preview.8.20374.2\r\n\r\n[DependencyUpdate]: <> (End)\r\n\r\n\r\n[marker]: <> (End:46a15fe4-6c2c-480d-9cdd-08d71053b252)\r\n\r\n","Url":"https://github.com/dotnet/wpf/pull/3281","RelatedDescription":"Closed or merged PR \"[master] Update dependencies from dnceng/internal/dotnet-wpf-int\" (#3281)"}],"ResultType":"GitHubIssue"}},"RunOn":"2020-08-06T05:30:53.3454347Z","RunDurationInMilliseconds":735}