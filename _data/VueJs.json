{"Data":{"Vue-Issues":{"Issues":[{"Id":"770833068","IsPullRequest":false,"CreatedAt":"2020-12-18T12:08:45","Actor":"alaroma","Number":"11832","RawContent":null,"Title":"Slot content is not rendered in foreginObject, when forigenObject is root tag of separate component","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[https://codesandbox.io/s/epic-neumann-m8hqz](https://codesandbox.io/s/epic-neumann-m8hqz)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\nOpen link\r\n\r\n### What is expected?\r\nShould display button under the text\r\n\r\n### What is actually happening?\r\nButton is not displayed\r\n\r\n---\r\nI try to add separate vue component in svg. This component has foreginObject tag as root and contains button, wich was inserted thorought slot in another component. It do not work, I mean button is hidden in browser. However the button exist in DOM, more over has sizes\r\n\r\nAt the same time if forigenObject tag is declared in component with svg it is work. I can see button.\r\nexample: https://codesandbox.io/s/inspiring-mclaren-t1z09\r\n\r\nI supose, there is porblem with slot content rendering in foreginObject, when forigenObject is root tag of separate component\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11832","RelatedDescription":"Closed issue \"Slot content is not rendered in foreginObject, when forigenObject is root tag of separate component\" (#11832)"},{"Id":"770633634","IsPullRequest":true,"CreatedAt":"2020-12-18T07:25:19","Actor":"linxz-coder","Number":"11831","RawContent":null,"Title":"test","State":"closed","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n\r\n<!-- PULL REQUEST TEMPLATE -->\r\n<!-- (Update \"[ ]\" to \"[x]\" to check a box) -->\r\n\r\n**What kind of change does this PR introduce?** (check at least one)\r\n\r\n- [ ] Bugfix\r\n- [ ] Feature\r\n- [ ] Code style update\r\n- [ ] Refactor\r\n- [ ] Build-related changes\r\n- [ ] Other, please describe:\r\n\r\n**Does this PR introduce a breaking change?** (check one)\r\n\r\n- [ ] Yes\r\n- [ ] No\r\n\r\nIf yes, please describe the impact and migration path for existing applications:\r\n\r\n**The PR fulfills these requirements:**\r\n\r\n- [ ] It's submitted to the `dev` branch for v2.x (or to a previous version branch), _not_ the `master` branch\r\n- [ ] When resolving a specific issue, it's referenced in the PR's title (e.g. `fix #xxx[,#xxx]`, where \"xxx\" is the issue number)\r\n- [ ] All tests are passing: https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\r\n- [ ] New/updated tests are included\r\n\r\nIf adding a **new feature**, the PR's description includes:\r\n- [ ] A convincing reason for adding this feature (to avoid wasting your time, it's best to open a suggestion issue first and wait for approval before working on it)\r\n\r\n**Other information:**\r\n","Url":"https://github.com/vuejs/vue/pull/11831","RelatedDescription":"Closed or merged PR \"test\" (#11831)"},{"Id":"770029218","IsPullRequest":true,"CreatedAt":"2020-12-17T13:27:20","Actor":"javoski","Number":"11830","RawContent":null,"Title":"feat(v-model): add lazy modifier for v-model on components(close #6914)","State":"open","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n\r\n<!-- PULL REQUEST TEMPLATE -->\r\n<!-- (Update \"[ ]\" to \"[x]\" to check a box) -->\r\n\r\n**What kind of change does this PR introduce?** (check at least one)\r\n\r\n- [ ] Bugfix\r\n- [x] Feature\r\n- [ ] Code style update\r\n- [ ] Refactor\r\n- [ ] Build-related changes\r\n- [ ] Other, please describe:\r\n\r\n**Does this PR introduce a breaking change?** (check one)\r\n\r\n- [ ] Yes\r\n- [x] No\r\n\r\nIf yes, please describe the impact and migration path for existing applications:\r\n\r\n**The PR fulfills these requirements:**\r\n\r\n- [x] It's submitted to the `dev` branch for v2.x (or to a previous version branch), _not_ the `master` branch\r\n- [x] When resolving a specific issue, it's referenced in the PR's title (e.g. `fix #xxx[,#xxx]`, where \"xxx\" is the issue number)\r\n- [x] All tests are passing: https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\r\n- [x] New/updated tests are included\r\n\r\n**Other information:**\r\nclose #6914.","Url":"https://github.com/vuejs/vue/pull/11830","RelatedDescription":"Open PR \"feat(v-model): add lazy modifier for v-model on components(close #6914)\" (#11830)"},{"Id":"769084714","IsPullRequest":false,"CreatedAt":"2020-12-17T10:25:49","Actor":"yazfield","Number":"11827","RawContent":null,"Title":"Throw error when props validation fails","State":"closed","Body":"### What problem does this feature solve?\r\nCurrently props validation only issues a warning in non production environment.\r\n\r\nI was trying to create a component like react's error-boundary to handle invalid props and show fallback componentsusing `errorCaptured` but it is unfortunately not possible.\r\n\r\n### What does the proposed API look like?\r\nsomething like a callback to be called when validating props\r\n```\r\nVue.config.assertPropsHandler: Function;\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11827","RelatedDescription":"Closed issue \"Throw error when props validation fails\" (#11827)"},{"Id":"769732581","IsPullRequest":true,"CreatedAt":"2020-12-17T09:06:24","Actor":"katarzyna-stachura-orba","Number":"11829","RawContent":null,"Title":"fix(ssr): prevent rendering duplicate css references","State":"open","Body":"There is a chance that the same css file is included in initial and async array, causing a <link>\r\nelement pointing to the same stylesheet to be included multiple times. This fix ensures that cannot\r\nhappen. Since multiple build systems exist, this defensive approach avoids any issues with how files\r\nare generated regardless of which one is being used by a given project.\r\n\r\n<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n\r\n<!-- PULL REQUEST TEMPLATE -->\r\n<!-- (Update \"[ ]\" to \"[x]\" to check a box) -->\r\n\r\n**What kind of change does this PR introduce?** (check at least one)\r\n\r\n- [x] Bugfix\r\n- [ ] Feature\r\n- [ ] Code style update\r\n- [ ] Refactor\r\n- [ ] Build-related changes\r\n- [ ] Other, please describe:\r\n\r\n**Does this PR introduce a breaking change?** (check one)\r\n\r\n- [ ] Yes\r\n- [x] No\r\n\r\nIf yes, please describe the impact and migration path for existing applications:\r\n\r\n**The PR fulfills these requirements:**\r\n\r\n- [x] It's submitted to the `dev` branch for v2.x (or to a previous version branch), _not_ the `master` branch\r\n- [ ] When resolving a specific issue, it's referenced in the PR's title (e.g. `fix #xxx[,#xxx]`, where \"xxx\" is the issue number)\r\n- [x] All tests are passing: https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\r\n- [ ] New/updated tests are included\r\n\r\n**Other information:**\r\n","Url":"https://github.com/vuejs/vue/pull/11829","RelatedDescription":"Open PR \"fix(ssr): prevent rendering duplicate css references\" (#11829)"},{"Id":"769237629","IsPullRequest":false,"CreatedAt":"2020-12-16T20:08:49","Actor":"privatenumber","Number":"11828","RawContent":null,"Title":"Building to Vue 2 and 3: Version mismatch error from vue-template-compiler","State":"open","Body":"### What problem does this feature solve?\r\n`vue-template-compiler` runs a version check against the `vue` specifier Node.js resolves as soon as it's imported [here](https://github.com/vuejs/vue/blob/dev/packages/vue-template-compiler/index.js).\r\n\r\nBecause of this:\r\n1. I'm getting a vue-loader recommendation in a rollup build\r\n2. I can't have a setup that builds to both Vue 2 and 3. I think it's important to support this use-case for the eco-system as more apps migrate to Vue 3.\r\n\r\nI'm interested in building a component to both Vue 2 and 3, but the version mismatch error from above gets thrown as soon as `rollup-plugin-vue@5` is imported.\r\n\r\n\r\n<img width=\"824\" alt=\"Screen Shot 2020-12-16 at 3 06 55 PM\" src=\"https://user-images.githubusercontent.com/1075694/102400783-666ac780-3fb0-11eb-9d02-d2aa217f6929.png\">\r\n\r\n\r\n\r\nMy `package.json` looks like this:\r\n\r\n```json5\r\n{\r\n  ...,\r\n  \"devDependencies\": {\r\n    \"@vue/compiler-sfc\": \"^3.0.4\",\r\n    \"rollup\": \"^2.35.1\",\r\n    \"rollup-plugin-vue2\": \"npm:rollup-plugin-vue@^5.1.9\",\r\n    \"rollup-plugin-vue3\": \"npm:rollup-plugin-vue@^6.0.0\",\r\n    \"vue\": \"^3.0.4\",\r\n    \"vue-template-compiler\": \"^2.6.12\",\r\n    \"vue2\": \"npm:vue@^2.6.12\"\r\n  }\r\n}\r\n```\r\n\r\nMy `rollup.config.js` looks like this:\r\n\r\n```js\r\nimport vue2 from 'rollup-plugin-vue2';\r\nimport vue3 from 'rollup-plugin-vue3';\r\n\r\nconst rollupConfig = [\r\n    {\r\n        input: 'src/MyComponent.vue',\r\n        plugins: [\r\n            vue3(),\r\n        ],\r\n        output: {\r\n            format: 'es',\r\n            file: 'dist/my-component.vue3.esm.js',\r\n        },\r\n    },\r\n    {\r\n        input: 'src/MyComponent.vue',\r\n        plugins: [\r\n            vue2(),\r\n        ],\r\n        output: {\r\n            format: 'es',\r\n            file: 'dist/my-component.vue2.esm.js',\r\n        },\r\n    },\r\n];\r\n\r\nexport default rollupConfig;\r\n```\r\n\r\n\r\n### What does the proposed API look like?\r\nWondering if this can be changed to a run-time check or moved to the appropriate loader/plugin.\r\n\r\nA run-time check might be a good idea as I'm sure a lot of people may be accidentally trying to import Vue 2 components into a Vue 3 app and vice-versa.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11828","RelatedDescription":"Open issue \"Building to Vue 2 and 3: Version mismatch error from vue-template-compiler\" (#11828)"},{"Id":"768823885","IsPullRequest":true,"CreatedAt":"2020-12-16T12:42:52","Actor":"blake-newman","Number":"11826","RawContent":null,"Title":"feat(ssr): add csp nonce to all elements","State":"open","Body":"\r\n\r\n**What kind of change does this PR introduce?** (check at least one)\r\n\r\n- [ ] Bugfix\r\n- [x] Feature\r\n- [ ] Code style update\r\n- [ ] Refactor\r\n- [ ] Build-related changes\r\n- [ ] Other, please describe:\r\n\r\n**Does this PR introduce a breaking change?** (check one)\r\n\r\n- [ ] Yes\r\n- [x] No\r\n\r\nIf yes, please describe the impact and migration path for existing applications:\r\n\r\n**The PR fulfills these requirements:**\r\n\r\n- [x] It's submitted to the `dev` branch for v2.x (or to a previous version branch), _not_ the `master` branch\r\n- [x] When resolving a specific issue, it's referenced in the PR's title (e.g. `fix #xxx[,#xxx]`, where \"xxx\" is the issue number)\r\n- [x] All tests are passing: https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\r\n- [x] New/updated tests are included\r\n\r\n**Other information:**\r\n\r\n[CSPv3](https://csp.withgoogle.com/docs/strict-csp.html)  allows simple nonce based policies and directives such as `stict-dynamic`. Declaring a policy such as:\r\n\r\n```\r\nContent-Security-Policy:\r\n  object-src 'none';\r\n  script-src 'nonce-{random}' 'unsafe-inline' 'unsafe-eval' 'strict-dynamic' https: http:;\r\n  base-uri 'none';\r\n  report-uri https://your-report-collector.example.com/\r\n```\r\n\r\nWould not work with current nonce support with features such as resource hints. This policy creates errors such as \r\n\r\n```\r\nRefused to load the script 'http://localhost:8082/manifest.js' because it violates the following Content Security Policy directive: \"script-src 'self' 'nonce-68f9bed4d31fcde221e7b5e871860ff2' 'unsafe-inline' 'unsafe-eval' 'strict-dynamic' http:\". 'strict-dynamic' is present, so host-based allowlisting is disabled. Note that 'script-src-elem' was not explicitly set, so 'script-src' is used as a fallback.\r\n```\r\n\r\nThis is because not all rendered elements have an associated nonce. \r\n\r\nTo support stricter policies that only work scripts / resource hinting add `nonce` attribute to all element that could be affected via a nonce based policy. \r\n","Url":"https://github.com/vuejs/vue/pull/11826","RelatedDescription":"Open PR \"feat(ssr): add csp nonce to all elements\" (#11826)"},{"Id":"768815589","IsPullRequest":true,"CreatedAt":"2020-12-16T12:32:58","Actor":"vue-bot","Number":"11825","RawContent":null,"Title":"[automated] Patreon sponsors update","State":"open","Body":"This is an automated pull request.","Url":"https://github.com/vuejs/vue/pull/11825","RelatedDescription":"Open PR \"[automated] Patreon sponsors update\" (#11825)"},{"Id":"767816107","IsPullRequest":false,"CreatedAt":"2020-12-15T22:08:33","Actor":"kswizzlek","Number":"11824","RawContent":null,"Title":"In vue template lazy evaluation functions","State":"closed","Body":"### What problem does this feature solve?\r\nin a vue template using {{removeCertainElemntsFrom(addElementTo(originalDataSource))}} vs. {{modifiedVersionOfOriginalDataSource}} allows a more pure way of modifying our data for our view. My request is to have Pure functions in the view that are only re-rendered when the parameters for the function are changed. This will lead to less code to maintain as well as allowing for test cases on the way our data gets parsed for the view and ultimately less bugs.\r\n\r\n### What does the proposed API look like?\r\nI use typescript with vue-property decorators so it would look like:\r\n```\r\n@Pure()\r\nprivate combineFirstAndLastName(first: string, last: string) {\r\n      // You will not be allowed to access outside variables from this function, if you do an error will be thrown(\"pure functions must be pure\"))\r\n   return `${first} ${last}`\r\n}\r\n```\r\nWhen used in the html this function will only get called when the parameters passed into it change\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11824","RelatedDescription":"Closed issue \"In vue template lazy evaluation functions\" (#11824)"},{"Id":"767091624","IsPullRequest":true,"CreatedAt":"2020-12-15T02:30:49","Actor":"teach-tian","Number":"11823","RawContent":null,"Title":"2002a","State":"closed","Body":"来测试一下，\r\n","Url":"https://github.com/vuejs/vue/pull/11823","RelatedDescription":"Closed or merged PR \"2002a\" (#11823)"},{"Id":"766378802","IsPullRequest":false,"CreatedAt":"2020-12-14T21:54:06","Actor":"DebaPrasad14","Number":"11822","RawContent":null,"Title":"new content are not getting loaded without hard reload and empty cache in the browser after new deployment","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[https://Notavailable](https://Notavailable)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n1. create an app\r\n2. deploy that\r\n3. check the content\r\n4. make some changes\r\n5. again deploy the app\r\n6. now reload the page in the browser ( the new contents wouldn't be available)\r\n7. do empty cache and hard reload in the browser then new contents will be available\r\n\r\n### What is expected?\r\nafter the new deployment, the new contents should be available to the users once they reload the page in the browser.\r\n\r\n### What is actually happening?\r\nafter the new deployment, we are telling users to do a hard reload and empty cache in the browser to get the new contents of our application which is not good, what I want is if a user reloads their page after deployment then they should see the new contents of our Vue app.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11822","RelatedDescription":"Closed issue \"new content are not getting loaded without hard reload and empty cache in the browser after new deployment\" (#11822)"},{"Id":"765490376","IsPullRequest":false,"CreatedAt":"2020-12-13T15:59:38","Actor":"jiaolong1021","Number":"11821","RawContent":null,"Title":"vue","State":"closed","Body":"","Url":"https://github.com/vuejs/vue/issues/11821","RelatedDescription":"Closed issue \"vue\" (#11821)"},{"Id":"764553003","IsPullRequest":true,"CreatedAt":"2020-12-12T23:12:49","Actor":"kevinlens","Number":"11820","RawContent":null,"Title":"Update README.md","State":"closed","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n\r\n<!-- PULL REQUEST TEMPLATE -->\r\n<!-- (Update \"[ ]\" to \"[x]\" to check a box) -->\r\n\r\n**What kind of change does this PR introduce?** (check at least one)\r\n\r\n- [ ] Bugfix\r\n- [ ] Feature\r\n- [ ] Code style update\r\n- [ ] Refactor\r\n- [ ] Build-related changes\r\n- [ ] Other, please describe:\r\n\r\n**Does this PR introduce a breaking change?** (check one)\r\n\r\n- [ ] Yes\r\n- [ ] No\r\n\r\nIf yes, please describe the impact and migration path for existing applications:\r\n\r\n**The PR fulfills these requirements:**\r\n\r\n- [ ] It's submitted to the `dev` branch for v2.x (or to a previous version branch), _not_ the `master` branch\r\n- [ ] When resolving a specific issue, it's referenced in the PR's title (e.g. `fix #xxx[,#xxx]`, where \"xxx\" is the issue number)\r\n- [ ] All tests are passing: https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\r\n- [ ] New/updated tests are included\r\n\r\nIf adding a **new feature**, the PR's description includes:\r\n- [ ] A convincing reason for adding this feature (to avoid wasting your time, it's best to open a suggestion issue first and wait for approval before working on it)\r\n\r\n**Other information:**\r\n","Url":"https://github.com/vuejs/vue/pull/11820","RelatedDescription":"Closed or merged PR \"Update README.md\" (#11820)"},{"Id":"762138159","IsPullRequest":true,"CreatedAt":"2020-12-11T09:29:12","Actor":"dependabot[bot]","Number":"11819","RawContent":null,"Title":"build(deps): bump ini from 1.3.5 to 1.3.7","State":"open","Body":"Bumps [ini](https://github.com/isaacs/ini) from 1.3.5 to 1.3.7.\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/npm/ini/commit/c74c8af35f32b801a7e82a8309eab792a95932f6\"><code>c74c8af</code></a> 1.3.7</li>\n<li><a href=\"https://github.com/npm/ini/commit/024b8b55ac1c980c6225607b007714c54eb501ba\"><code>024b8b5</code></a> update deps, add linting</li>\n<li><a href=\"https://github.com/npm/ini/commit/032fbaf5f0b98fce70c8cc380e0d05177a9c9073\"><code>032fbaf</code></a> Use Object.create(null) to avoid default object property hazards</li>\n<li><a href=\"https://github.com/npm/ini/commit/2da90391ef70db41d10f013e3a87f9a8c5d01a72\"><code>2da9039</code></a> 1.3.6</li>\n<li><a href=\"https://github.com/npm/ini/commit/cfea636f534b5ca7550d2c28b7d1a95d936d56c6\"><code>cfea636</code></a> better git push script, before publish instead of after</li>\n<li><a href=\"https://github.com/npm/ini/commit/56d2805e07ccd94e2ba0984ac9240ff02d44b6f1\"><code>56d2805</code></a> do not allow invalid hazardous string as section name</li>\n<li>See full diff in <a href=\"https://github.com/isaacs/ini/compare/v1.3.5...v1.3.7\">compare view</a></li>\n</ul>\n</details>\n<details>\n<summary>Maintainer changes</summary>\n<p>This version was pushed to npm by <a href=\"https://www.npmjs.com/~isaacs\">isaacs</a>, a new releaser for ini since your current version.</p>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=ini&package-manager=npm_and_yarn&previous-version=1.3.5&new-version=1.3.7)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language\n- `@dependabot use these reviewers` will set the current reviewers as the default for future PRs for this repo and language\n- `@dependabot use these assignees` will set the current assignees as the default for future PRs for this repo and language\n- `@dependabot use this milestone` will set the current milestone as the default for future PRs for this repo and language\n\nYou can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/vuejs/vue/network/alerts).\n\n</details>","Url":"https://github.com/vuejs/vue/pull/11819","RelatedDescription":"Open PR \"build(deps): bump ini from 1.3.5 to 1.3.7\" (#11819)"},{"Id":"761949613","IsPullRequest":true,"CreatedAt":"2020-12-11T08:42:37","Actor":"Pabitra-26","Number":"11818","RawContent":null,"Title":"Update README.md","State":"closed","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n\r\n<!-- PULL REQUEST TEMPLATE -->\r\n<!-- (Update \"[ ]\" to \"[x]\" to check a box) -->\r\n\r\n**What kind of change does this PR introduce?** (check at least one)\r\n\r\n- [ ] Bugfix\r\n- [ ] Feature\r\n- [ ] Code style update\r\n- [ ] Refactor\r\n- [ ] Build-related changes\r\n- [ ] Other, please describe:\r\n\r\n**Does this PR introduce a breaking change?** (check one)\r\n\r\n- [ ] Yes\r\n- [ ] No\r\n\r\nIf yes, please describe the impact and migration path for existing applications:\r\n\r\n**The PR fulfills these requirements:**\r\n\r\n- [ ] It's submitted to the `dev` branch for v2.x (or to a previous version branch), _not_ the `master` branch\r\n- [ ] When resolving a specific issue, it's referenced in the PR's title (e.g. `fix #xxx[,#xxx]`, where \"xxx\" is the issue number)\r\n- [ ] All tests are passing: https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\r\n- [ ] New/updated tests are included\r\n\r\nIf adding a **new feature**, the PR's description includes:\r\n- [ ] A convincing reason for adding this feature (to avoid wasting your time, it's best to open a suggestion issue first and wait for approval before working on it)\r\n\r\n**Other information:**\r\n","Url":"https://github.com/vuejs/vue/pull/11818","RelatedDescription":"Closed or merged PR \"Update README.md\" (#11818)"},{"Id":"760515760","IsPullRequest":true,"CreatedAt":"2020-12-09T17:16:59","Actor":"vue-bot","Number":"11817","RawContent":null,"Title":"[automated] Patreon sponsors update","State":"open","Body":"This is an automated pull request.","Url":"https://github.com/vuejs/vue/pull/11817","RelatedDescription":"Open PR \"[automated] Patreon sponsors update\" (#11817)"},{"Id":"760189668","IsPullRequest":false,"CreatedAt":"2020-12-09T11:28:45","Actor":"Jemory-git","Number":"11816","RawContent":null,"Title":"a bug for cached page instance or the component(keep-alive) --- $destory","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[http://thisIssueNeednotLink.com](http://thisIssueNeednotLink.com)\r\n\r\n\r\nthis is another same issue : https://github.com/vuejs/vue/issues/6509#issuecomment-347787474\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n1、use <keep-alive> cache pages \r\n2、click btn to close the page， and destory the instance\r\n3、when reopen the page ，it will never be cached\r\n\r\n### What is expected?\r\nit is the most elegant method to cache pages with tab-tags。\r\nbut can not achieve cause this bug\r\n\r\n### What is actually happening?\r\nrepair\r\n\r\n---\r\nrepair\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11816","RelatedDescription":"Closed issue \"a bug for cached page instance or the component(keep-alive) --- $destory\" (#11816)"},{"Id":"760166673","IsPullRequest":false,"CreatedAt":"2020-12-09T09:36:55","Actor":"Jemory-git","Number":"11815","RawContent":null,"Title":"after cached page instance exec $destory,the page will never be cached; this bug existing many years??","State":"closed","Body":"看到$destroy这个方法，我觉得这就是正确的用法，通过组件里不同的用户行为决定离开页面时是否缓存组件。\r\n（比如一个留言组件，留言提交成功后这个组件应该销毁，如果没有提交，则应该保留缓存，让用户下次进来继续。）\r\n然而，destroy之后，再次重复进入这个组件会出现奇怪的结果，组件不能再被缓存了，我觉得这是bug吧。\r\n\r\n_Originally posted by @wanyaxing in https://github.com/vuejs/vue/issues/6509#issuecomment-347787474_","Url":"https://github.com/vuejs/vue/issues/11815","RelatedDescription":"Closed issue \"after cached page instance exec $destory,the page will never be cached; this bug existing many years??\" (#11815)"},{"Id":"759946153","IsPullRequest":false,"CreatedAt":"2020-12-09T08:42:50","Actor":"lynn-Chin","Number":"11813","RawContent":null,"Title":"Get same value on several items in a v-for loop","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[https://codepen.io/lynn-chin/pen/xxEEZgR](https://codepen.io/lynn-chin/pen/xxEEZgR)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\nI have an object array like this: [ { name: '01.jpg', id: 1234, url: '/example/01.jpg' }, { name: '02.jpg', id: 2345, url: '/example/02.jpg' } ];\r\nWhen I use v-for to render HTML structure, items in the object got same value for item.id:\r\n\r\nMy HTML structure is:\r\n           <div\r\n                class=\"single_image\"\r\n                v-for=\"(item, index) in images\"\r\n                :key=\"index\"\r\n              >\r\n                <img :src=\"item.url\" alt=\"\" />\r\n                <div class=\"image_title\">\r\n                  <input\r\n                    type=\"checkbox\"\r\n                    @change=\"checkboxChange($event, item)\"\r\n                    ref=\"imgCheckBox\"\r\n                  />\r\n                  {{ item.name }}\r\n                </div>\r\n              </div>\r\nThe result of console.log(item.id, item.name) for each item:\r\n          12345678987654324  \"02.jpg\"    (wrong id)\r\n          12345678987654324  \"03.jpg\"    (wrong id)\r\n          12345678987654324  \"04.jpg\"\r\n          12345678987654326  \"05.jpg\"\r\n          12345678987654328  \"06.jpg\"    (wrong id)\r\n          12345678987654328  \"07.jpg\"    (wrong id)\r\n\r\nIf I change item.id's type from Number to String, this will not happen.\r\nI wanna know what is happen and how can I avoid this situation.  Does that mean I cannot use Number values in a v-for loop?\r\n\r\n### What is expected?\r\nI expect each item got its right id value.\r\n\r\n### What is actually happening?\r\nMost values for item.id are wrong.\r\n\r\n---\r\nMy Vue version is 2.6.12, but there's not such a choice.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11813","RelatedDescription":"Closed issue \"Get same value on several items in a v-for loop\" (#11813)"},{"Id":"760028517","IsPullRequest":true,"CreatedAt":"2020-12-09T06:01:42","Actor":"lduoduo","Number":"11814","RawContent":null,"Title":"fix: make ssr-build-plugin compatible with webpack4/5 (fix #11718)","State":"open","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n\r\nfixed issue [here](https://github.com/vuejs/vue/issues/11718)\r\n\r\n<!-- PULL REQUEST TEMPLATE -->\r\n<!-- (Update \"[ ]\" to \"[x]\" to check a box) -->\r\n\r\n**What kind of change does this PR introduce?** (check at least one)\r\n\r\n- [x] Bugfix\r\n- [ ] Feature\r\n- [ ] Code style update\r\n- [ ] Refactor\r\n- [ ] Build-related changes\r\n- [ ] Other, please describe:\r\n\r\n**Does this PR introduce a breaking change?** (check one)\r\n\r\n- [ ] Yes\r\n- [x] No\r\n\r\nIf yes, please describe the impact and migration path for existing applications:\r\n\r\n**The PR fulfills these requirements:**\r\n\r\n- [ ] It's submitted to the `dev` branch for v2.x (or to a previous version branch), _not_ the `master` branch\r\n- [ ] When resolving a specific issue, it's referenced in the PR's title (e.g. `fix #xxx[,#xxx]`, where \"xxx\" is the issue number)\r\n- [ ] All tests are passing: https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\r\n- [ ] New/updated tests are included\r\n\r\nIf adding a **new feature**, the PR's description includes:\r\n- [ ] A convincing reason for adding this feature (to avoid wasting your time, it's best to open a suggestion issue first and wait for approval before working on it)\r\n\r\n**Other information:**\r\n","Url":"https://github.com/vuejs/vue/pull/11814","RelatedDescription":"Open PR \"fix: make ssr-build-plugin compatible with webpack4/5 (fix #11718)\" (#11814)"},{"Id":"759428039","IsPullRequest":false,"CreatedAt":"2020-12-08T14:25:53","Actor":"gh-xiaoxiao","Number":"11812","RawContent":null,"Title":"\"watch\" always listen for an unchanged array !","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[https://codepen.io/gh-xiaoxiao/pen/ExgyewZ](https://codepen.io/gh-xiaoxiao/pen/ExgyewZ)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\nEnter text1 or text2, and then view the print information\r\n\r\n### What is expected?\r\nPrint \"form.text1\" or \"form.text2\" only\r\n\r\n### What is actually happening?\r\n\"form.arr\" is also printed out\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11812","RelatedDescription":"Closed issue \"\"watch\" always listen for an unchanged array !\" (#11812)"},{"Id":"757041371","IsPullRequest":false,"CreatedAt":"2020-12-08T09:37:18","Actor":"pndllxzzy","Number":"11805","RawContent":null,"Title":"sameVNode无法区分emptyVNode和AsyncPlaceholder","State":"closed","Body":"### Version\r\n2.6.10\r\n\r\n### Reproduction link\r\n[https://codesandbox.io/s/wonderful-ardinghelli-5fi3f?file=/src/views/same-vnode.vue](https://codesandbox.io/s/wonderful-ardinghelli-5fi3f?file=/src/views/same-vnode.vue)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n1. 打开页面https://5fi3f.sse.codesandbox.io/same-vnode\r\n2. 打开devtools在console中发现报错信息\r\n\r\n### What is expected?\r\n无报错信息\r\n\r\n### What is actually happening?\r\nsameVnode方法判断emptyVNode与AsyncPlaceholder相等导致\r\npatchVnode isDef(vnode.asyncFactory.resolved)报错\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11805","RelatedDescription":"Closed issue \"sameVNode无法区分emptyVNode和AsyncPlaceholder\" (#11805)"},{"Id":"758778857","IsPullRequest":false,"CreatedAt":"2020-12-07T20:22:16","Actor":"StefanCardnell","Number":"11811","RawContent":null,"Title":"Default slots using functional components still call functional's render() when something else is slotted.","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[https://codesandbox.io/s/happy-pascal-reiyx?fontsize=14&hidenavigation=1&theme=dark](https://codesandbox.io/s/happy-pascal-reiyx?fontsize=14&hidenavigation=1&theme=dark)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n1.  Please see linked minimal example.\r\n2. Create a component A which uses a functional component B inside a default slot.\r\n3. Use Component A, but slot in something else so the functional component B does not appear.\r\n\r\n### What is expected?\r\nThe render() function of the functional component should not be called. As it does not appear, I shouldn't expect its render function to be called.\r\n\r\n### What is actually happening?\r\nThe render() function is called, as seen by the console output which logs when the function is called.\r\n\r\n---\r\nIssues:\r\n    I encountered this when I was creating a table with 10,000 cells and each \\<\\td\\> was a functional component. However the table was able to slot in its own component over the \\<\\td\\>. Doing so meant the slotted clotted was created along with 10,000 unnecessary renders() from the functional component. This added about ~1s load time.\r\n\r\nWorkarounds:\r\n    Don't put the functional component inside the slot. Instead, the functional component should be used outside and have a v-if on it checking if the slot has not been used. It is the same end result, but render() is not called.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11811","RelatedDescription":"Closed issue \"Default slots using functional components still call functional's render() when something else is slotted.\" (#11811)"},{"Id":"758697253","IsPullRequest":false,"CreatedAt":"2020-12-07T17:58:00","Actor":"jrgleason","Number":"11810","RawContent":null,"Title":"Getting \"Uncaught DOMException: Operation is not supported\" when using Web Component inside Vue Component using ESM and Browser.","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[https://github.com/jrgleason/jrg/blob/EXAMPLES_FRAMEWORK_INT/jrg-ui/examples/vue/index.html](https://github.com/jrgleason/jrg/blob/EXAMPLES_FRAMEWORK_INT/jrg-ui/examples/vue/index.html)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\nThis is a basic HTML page and should \"just work\". What would be expected is that the web component is embedded in the Vue Component, however, only the vue on renders. If I move the Web Component outside of the Vue component it renders as expected. \r\n\r\n### What is expected?\r\nThe custom element (web component) renders inside the Vue component.\r\n\r\n### What is actually happening?\r\nI get \"Uncaught DOMException: Operation is not supported\"\r\n\r\n---\r\nSO Available here https://stackoverflow.com/questions/65182891/how-do-i-use-a-non-vue-custom-web-component-in-a-vue-component-without-webpack. Answer does not solve the issues as can be seen by my updated version.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11810","RelatedDescription":"Closed issue \"Getting \"Uncaught DOMException: Operation is not supported\" when using Web Component inside Vue Component using ESM and Browser.\" (#11810)"},{"Id":"758293140","IsPullRequest":false,"CreatedAt":"2020-12-07T08:46:22","Actor":"FranciscoJavierMartin","Number":"11808","RawContent":null,"Title":"Show warning on console when developer names a component with the same name that a native HTML tag","State":"closed","Body":"### What problem does this feature solve?\r\nI try to create a component called \"Map\" that its name collide with the native HTML tag \"map\". I did not know this tag and did not see any warning or error on the console, simply the component is not showed on the page and I was wondering what was happening.\r\n\r\n### What does the proposed API look like?\r\nI want some warning on the console that show a message like \"You 'Map' component name collide with a native HTML tag. Please rename it\" to avoid these kind of errors. I think that it is useful specially for beginners developers.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11808","RelatedDescription":"Closed issue \"Show warning on console when developer names a component with the same name that a native HTML tag\" (#11808)"},{"Id":"757925761","IsPullRequest":true,"CreatedAt":"2020-12-06T13:27:43","Actor":"mangalan516","Number":"11807","RawContent":null,"Title":"added message","State":"closed","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n\r\n<!-- PULL REQUEST TEMPLATE -->\r\n<!-- (Update \"[ ]\" to \"[x]\" to check a box) -->\r\n\r\n**What kind of change does this PR introduce?** (check at least one)\r\n\r\n- [ ] Bugfix\r\n- [ ] Feature\r\n- [ ] Code style update\r\n- [ ] Refactor\r\n- [ ] Build-related changes\r\n- [ ] Other, please describe:\r\n\r\n**Does this PR introduce a breaking change?** (check one)\r\n\r\n- [ ] Yes\r\n- [ ] No\r\n\r\nIf yes, please describe the impact and migration path for existing applications:\r\n\r\n**The PR fulfills these requirements:**\r\n\r\n- [ ] It's submitted to the `dev` branch for v2.x (or to a previous version branch), _not_ the `master` branch\r\n- [ ] When resolving a specific issue, it's referenced in the PR's title (e.g. `fix #xxx[,#xxx]`, where \"xxx\" is the issue number)\r\n- [ ] All tests are passing: https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\r\n- [ ] New/updated tests are included\r\n\r\nIf adding a **new feature**, the PR's description includes:\r\n- [ ] A convincing reason for adding this feature (to avoid wasting your time, it's best to open a suggestion issue first and wait for approval before working on it)\r\n\r\n**Other information:**\r\n","Url":"https://github.com/vuejs/vue/pull/11807","RelatedDescription":"Closed or merged PR \"added message\" (#11807)"},{"Id":"757685620","IsPullRequest":false,"CreatedAt":"2020-12-05T16:01:36","Actor":"Tzdy","Number":"11806","RawContent":null,"Title":"Prop default value cannot be set correctly","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[https://codepen.io/Tsdy/pen/vYXGXEr](https://codepen.io/Tsdy/pen/vYXGXEr)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n```\r\nfunction fun() {}\r\n        const vm = new Vue({\r\n            el: '#App',\r\n            components: {\r\n                MyComponent: {\r\n                    props: {\r\n                        text: {\r\n                            type: [Boolean, Function],\r\n                            default: fun\r\n                        }\r\n                    },\r\n                    template: `<div></div>`\r\n                }\r\n            }\r\n        })\r\n        console.log(vm.$children[0].text)\r\n    // undefined\r\n\r\n```\r\n\r\n### What is expected?\r\nI can find the text property in the vm.$children[0]\r\n\r\n### What is actually happening?\r\nvm.$children[0].text is undefined\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11806","RelatedDescription":"Closed issue \"Prop default value cannot be set correctly\" (#11806)"},{"Id":"756582943","IsPullRequest":false,"CreatedAt":"2020-12-03T21:49:18","Actor":"ottonomous","Number":"11804","RawContent":null,"Title":"Passing Boolean Prop With No value Without Type Validation on Child Component Is Interpreted as an Empty String Instead of True","State":"closed","Body":"### Version\r\n2.6.11\r\n\r\n### Reproduction link\r\n[https://codesandbox.io/s/tender-meitner-bpvvl](https://codesandbox.io/s/tender-meitner-bpvvl)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n1. Create a child component\r\n2. Pass a boolean prop `boolean-prop` with no value\r\n3. Check the value of the prop in the child component\r\n\r\n### What is expected?\r\nThe prop value should be `true` and the type should be a boolean\r\n\r\n### What is actually happening?\r\nthe prop value is \"\" (an empty string) and the type is string\r\n\r\n---\r\nWORKAROUND: Adding type validation to the prop solves the issue.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11804","RelatedDescription":"Closed issue \"Passing Boolean Prop With No value Without Type Validation on Child Component Is Interpreted as an Empty String Instead of True\" (#11804)"},{"Id":"755881378","IsPullRequest":false,"CreatedAt":"2020-12-03T05:40:13","Actor":"crutchcorn","Number":"11803","RawContent":null,"Title":"FLIP Animation not applied when first item spliced","State":"closed","Body":"### Version\r\n3.0.4\r\n\r\n### Reproduction link\r\n[https://codepen.io/crutchcorn/pen/ZEpbZKX](https://codepen.io/crutchcorn/pen/ZEpbZKX)\r\n\r\n\r\n![working_vs_broke](https://user-images.githubusercontent.com/9100169/100968687-acbb2380-34e6-11eb-91de-c36c6ab0898a.gif)\r\n\r\n### Steps to reproduce\r\nTake the example from:\r\n\r\nhttps://v3.vuejs.org/guide/transitions-list.html#list-move-transitions\r\n\r\nThat's at this link:\r\n\r\nhttps://codepen.io/team/Vue/pen/373b4429eb5769ae2e6d097fd954fd08\r\n\r\nChange the `remove` method to match:\r\n\r\n```js\r\n      this.items.splice(0, 1)\r\n```\r\n\r\n### What is expected?\r\nThe first item in the array is removed and an animation smooths out the other items moving into the first spot\r\n\r\n### What is actually happening?\r\nIt jerkily moves the items to the first index\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11803","RelatedDescription":"Closed issue \"FLIP Animation not applied when first item spliced\" (#11803)"},{"Id":"755840479","IsPullRequest":false,"CreatedAt":"2020-12-03T05:08:52","Actor":"pndllxzzy","Number":"11802","RawContent":null,"Title":"about function sameVnode","State":"closed","Body":"### What problem does this feature solve?\r\nsameVnode对emptyVNode和AsyncPlaceholder VNode进行区分\r\n\r\n### What does the proposed API look like?\r\nVNodeA: v-if=\"false\"产生的emptyVNode\r\nVNodeB: asyncComponentB在resolve前产生的AsyncPlaceholder\r\nVNodeC: asyncComponentC在resolve前产生的AsyncPlaceholder\r\n\r\nsameVnode(VNodeA, VNodeB) 返回的是true\r\nsameVnode(VNodeB, VNodeC) 返回的是true\r\n\r\n返回true的话容易导致一些错误，期望sameVnode以上情况返回false\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue/issues/11802","RelatedDescription":"Closed issue \"about function sameVnode\" (#11802)"}],"ResultType":"GitHubIssue"},"Router-Issues":{"Issues":[{"Id":"767931895","IsPullRequest":true,"CreatedAt":"2020-12-18T08:49:58","Actor":"champkeh","Number":"3416","RawContent":null,"Title":"docs(zh): translate navigation-failures.md to chinese.","State":"closed","Body":"","Url":"https://github.com/vuejs/vue-router/pull/3416","RelatedDescription":"Closed or merged PR \"docs(zh): translate navigation-failures.md to chinese.\" (#3416)"},{"Id":"768294496","IsPullRequest":false,"CreatedAt":"2020-12-16T12:49:28","Actor":"martinmckenna","Number":"3417","RawContent":null,"Title":"Recognize Props Passed to router-view As Reactive","State":"closed","Body":"### What problem does this feature solve?\r\nCurrently having an issue where I want to\r\n\r\n1. Create a nested router-view\r\n2. Do some API fetching in the parent\r\n3. Pass down data to all the children components\r\n4. Have the children re-render when the reactive values update\r\n\r\nWhat I tried was this\r\n\r\n```vue\r\n/* my-view.vue */\r\n\r\n<template>\r\n  <router-view\r\n    :data=\"data\"\r\n    :loading=\"loading\"\r\n    :error=\"error\"\r\n    :lastUpdated=\"lastUpdated\"\r\n  />\r\n</template>\r\n\r\n<script>\r\nimport { useAPIRequest } from '@/hooks/useAPIRequest';\r\n\r\nexport default {\r\n  setup() {\r\n   /* this will make the API request on mount and update the appropriate values on resolve/reject */\r\n    const {\r\n      data,\r\n      loading,\r\n      error,\r\n      lastUpdated,\r\n    } = useAPIRequest(\r\n      () => Promise.resolve([]),\r\n    );\r\n\r\n    return {\r\n      data,\r\n      loading,\r\n      error,\r\n      lastUpdated,\r\n    };\r\n  },\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\" scoped></style>\r\n```\r\n\r\n```js\r\n/* useAPIRequest.js */\r\n\r\nimport { ref } from '@vue/composition-api';\r\n/**\r\n *\r\n * @param { () => Promise<any> } request\r\n * @param { any } initialData\r\n *\r\n * @returns {\r\n *  loading: boolean;\r\n *  error: any;\r\n *  lastUpdated: number;\r\n *  data: any;\r\n * }\r\n */\r\nexport const useAPIRequest = (\r\n  request,\r\n  initialData,\r\n) => {\r\n  const data = ref(initialData || null);\r\n  const loading = ref(true);\r\n  const error = ref(null);\r\n  const lastUpdated = ref(0);\r\n\r\n  const handleRequest = () => {\r\n    if (!request) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    if (lastUpdated.value === 0) {\r\n      loading.value = true;\r\n    }\r\n    return request()\r\n      .then((response) => {\r\n        data.value = response;\r\n        loading.value = false;\r\n        lastUpdated.value = Date.now();\r\n        error.value = null;\r\n      })\r\n      .catch((err) => {\r\n        error.value = err;\r\n        loading.value = false;\r\n      });\r\n  };\r\n\r\n  handleRequest();\r\n\r\n  return {\r\n    data,\r\n    loading,\r\n    error,\r\n    lastUpdated,\r\n    update: handleRequest,\r\n  };\r\n};\r\n\r\nexport default useAPIRequest;\r\n```\r\n\r\nBut this doesn't work because the components that are rendered in the nested routes have access to these values through `attrs.data`, `attrs.loading`, `attrs.lastUpdated`, etc. They are not reactive and the children components don't re-render when these values change\r\n\r\nWhat ended up working for me was passing the values down as refs, like so\r\n\r\n```vue\r\n/* my-view.vue */\r\n\r\n<template>\r\n  <router-view\r\n    :data=\"data\"\r\n    :loading=\"loading\"\r\n    :error=\"error\"\r\n    :lastUpdated=\"lastUpdated\"\r\n  />\r\n</template>\r\n\r\n<script>\r\nimport { computed } from '@vue/composition-api';\r\nimport { useAPIRequest } from '@/hooks/useAPIRequest';\r\n\r\nexport default {\r\n  setup() {\r\n    const {\r\n      data,\r\n      loading,\r\n      error,\r\n      lastUpdated,\r\n    } = useAPIRequest(\r\n      () => Promise.resolve([]),\r\n    );\r\n\r\n    return {\r\n      data: computed(() => data),\r\n      loading: computed(() => loading),\r\n      error: computed(() => error),\r\n      lastUpdated: computed(() => lastUpdated),\r\n    };\r\n  },\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\" scoped></style>\r\n```\r\n\r\nBut I'm assuming passing down refs is an anti-pattern and probably isn't recommended.\r\n\r\nMy ask is that I want the ability to pass down reactive values to `<router-view />` children and have them re-render when these values change\r\n\r\n### What does the proposed API look like?\r\nPossibly `<router-view render=\"(Component => <Component myProp=\"something\" />)\" />`\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3417","RelatedDescription":"Closed issue \"Recognize Props Passed to router-view As Reactive\" (#3417)"},{"Id":"768735562","IsPullRequest":true,"CreatedAt":"2020-12-16T11:19:55","Actor":"baranelitez","Number":"3418","RawContent":null,"Title":"Update dynamic-matching.md. Adding optional parameters example.","State":"closed","Body":"The docs never mention optional parameters for paths. This PR adds an example.\r\n\r\n<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n","Url":"https://github.com/vuejs/vue-router/pull/3418","RelatedDescription":"Closed or merged PR \"Update dynamic-matching.md. Adding optional parameters example.\" (#3418)"},{"Id":"767110580","IsPullRequest":false,"CreatedAt":"2020-12-15T08:50:39","Actor":"dshvv","Number":"3415","RawContent":null,"Title":"chrome-headless(chromeDriver) mode，Abnormal performance","State":"closed","Body":"### Version\r\n3.2.0\r\n\r\n### Reproduction link\r\n[https://router.vuejs.org/zh/](https://router.vuejs.org/zh/)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n无头浏览器模式下，官方demo的history模式路由，会被重定向，并且自动添加“#”\r\nIn chrome-headless(chromeDriver) mode, \r\nthe history mode route of the official demo-- will be redirected, --and the \"#\" will be automatically added\r\n![history-model](https://user-images.githubusercontent.com/18003391/102161354-25948500-3ec2-11eb-9280-c6fcef7c152f.gif)\r\n\r\n\r\n### What is expected?\r\nnormal using\r\n\r\n### What is actually happening?\r\n will be redirected, --and the \"#\" will be automatically added\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3415","RelatedDescription":"Closed issue \"chrome-headless(chromeDriver) mode，Abnormal performance\" (#3415)"},{"Id":"767107517","IsPullRequest":false,"CreatedAt":"2020-12-15T02:49:50","Actor":"dshvv","Number":"3414","RawContent":null,"Title":"chrome-headless(chromeDriver) mode","State":"closed","Body":"### Version\r\n3.2.0\r\n\r\n### What is actually happening?\r\n无头浏览器模式下，官方demo的history模式路由，会被重定向，并且自动添加“#”\r\nIn chrome-headless(chromeDriver) mode, \r\nthe history mode route of the official demo-- will be redirected, --and the \"#\" will be automatically added\r\n![history-model](https://user-images.githubusercontent.com/18003391/102161354-25948500-3ec2-11eb-9280-c6fcef7c152f.gif)\r\n\r\n### What is expected?\r\nnormal useing\r\n","Url":"https://github.com/vuejs/vue-router/issues/3414","RelatedDescription":"Closed issue \"chrome-headless(chromeDriver) mode\" (#3414)"},{"Id":"767106048","IsPullRequest":false,"CreatedAt":"2020-12-15T02:46:56","Actor":"dshvv","Number":"3413","RawContent":null,"Title":"chrome-headless(chromeDriver) mode","State":"closed","Body":"Version\r\n3.2.0\r\n\r\n无头浏览器模式下，官方demo的history模式路由，会被重定向，并且自动添加“#”\r\nIn chrome-headless(chromeDriver) mode, \r\nthe history mode route of the official demo-- will be redirected, --and the \"#\" will be automatically added\r\n![history-model](https://user-images.githubusercontent.com/18003391/102161354-25948500-3ec2-11eb-9280-c6fcef7c152f.gif)\r\n\r\n","Url":"https://github.com/vuejs/vue-router/issues/3413","RelatedDescription":"Closed issue \"chrome-headless(chromeDriver) mode\" (#3413)"},{"Id":"767104257","IsPullRequest":false,"CreatedAt":"2020-12-15T02:43:19","Actor":"dshvv","Number":"3412","RawContent":null,"Title":" chrome-headless(chromeDriver) mode","State":"closed","Body":"无头浏览器模式下，官方demo的history模式路由，会被重定向，并且自动添加“#”\r\nIn chrome-headless(chromeDriver) mode, \r\nthe history mode route of the official demo-- will be redirected, --and the \"#\" will be automatically added\r\n![history-model](https://user-images.githubusercontent.com/18003391/102161354-25948500-3ec2-11eb-9280-c6fcef7c152f.gif)\r\n\r\n","Url":"https://github.com/vuejs/vue-router/issues/3412","RelatedDescription":"Closed issue \" chrome-headless(chromeDriver) mode\" (#3412)"},{"Id":"767102032","IsPullRequest":false,"CreatedAt":"2020-12-15T02:39:17","Actor":"dshvv","Number":"3411","RawContent":null,"Title":"chrome-headless&&history-model","State":"closed","Body":"无头浏览器模式下，官方demo的history模式路由，会被重定向，并且自动添加“#”\r\nIn chrome-headless(chromeDriver) mode, \r\nthe history mode route of the official demo-- will be redirected, --and the \"#\" will be automatically added\r\n![history-model](https://user-images.githubusercontent.com/18003391/102161354-25948500-3ec2-11eb-9280-c6fcef7c152f.gif)\r\n","Url":"https://github.com/vuejs/vue-router/issues/3411","RelatedDescription":"Closed issue \"chrome-headless&&history-model\" (#3411)"},{"Id":"765181931","IsPullRequest":false,"CreatedAt":"2020-12-13T08:22:32","Actor":"ThanhTruc3294","Number":"3410","RawContent":null,"Title":"how can i cccess VueRouter outside Vue components in vue 3","State":"closed","Body":"interceptor.ts\r\n`import CommonService from '@/services/CommonService';\r\nimport axios from \"axios\";\r\nimport RoutePath from '@/commons/RoutePath';\r\nimport router from '@/presentation/router/index';\r\n\r\nconst axiosApiInstance = axios.create();\r\n// Request interceptor for API calls\r\naxiosApiInstance.interceptors.request.use(\r\n    async config => {\r\n\r\n        config.headers = {\r\n            \"Content-type\": \"application/json; charset=UTF-8\",\r\n            Accept: \"application/json\",\r\n            lang: \"ja\"\r\n        };\r\n        return config;\r\n    },\r\n    error => {\r\n        Promise.reject(error);\r\n    }\r\n);\r\n\r\n// Response interceptor for API calls\r\naxiosApiInstance.interceptors.response.use(\r\n    response => {\r\n        router.push(RoutePath.TIME_OUT);\r\n        return response.data;\r\n    },\r\n    async function(error) {\r\n        const BAD_REQUEST = 400;\r\n        const UNAUTHORIZED = 401;\r\n        const FORBIDDEN = 403;\r\n        const NOT_FOUND = 404;\r\n        const SERVER_ERROR = 500;\r\n        const response = error.response;\r\n        if (response.status === BAD_REQUEST) {\r\n            return Promise.reject(response.data);\r\n        }\r\n        if (response.status === FORBIDDEN) {\r\n            return Promise.reject(response.data);\r\n        }\r\n        if (response.status === UNAUTHORIZED) {\r\n            if (response.request.responseURL.includes(\"/auth/check\")) {\r\n                return Promise.reject(response.data);\r\n            }\r\n            CommonService.deleteCookie(\"is_login\");\r\n            CommonService.deleteCookie(\"user\");\r\n            CommonService.deleteCookie(\"user_roles\");\r\n            localStorage.removeItem(\"accountName\");\r\n        }\r\n        if (response.status === NOT_FOUND) {\r\n            return Promise.reject(response.data);\r\n        }\r\n        if (response.status === SERVER_ERROR) {\r\n            return Promise.reject(response);\r\n        }\r\n        return Promise.reject(response);\r\n    }\r\n);\r\n\r\nexport default axiosApiInstance;\r\n`\r\nhow can i use router in this file? ","Url":"https://github.com/vuejs/vue-router/issues/3410","RelatedDescription":"Closed issue \"how can i cccess VueRouter outside Vue components in vue 3\" (#3410)"},{"Id":"763954978","IsPullRequest":false,"CreatedAt":"2020-12-12T15:25:18","Actor":"ivanjaros","Number":"3409","RawContent":null,"Title":"Router link access","State":"closed","Body":"I am trying to add access control to links. I can do some basic control in router.beforeEach but that does not prevent links to be rendered. So I need to hook into links and prevent them from being rendered if some conditions are not met. In order to do that I need some way into the router link component + access to the params/props being passed to it.\r\n\r\nIs that possible somehow or do I have to create some sort of wrapper component and put the logic in there?","Url":"https://github.com/vuejs/vue-router/issues/3409","RelatedDescription":"Closed issue \"Router link access\" (#3409)"},{"Id":"761850126","IsPullRequest":true,"CreatedAt":"2020-12-11T03:29:56","Actor":"dependabot[bot]","Number":"3408","RawContent":null,"Title":"build(deps): bump ini from 1.3.5 to 1.3.7","State":"open","Body":"Bumps [ini](https://github.com/isaacs/ini) from 1.3.5 to 1.3.7.\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/npm/ini/commit/c74c8af35f32b801a7e82a8309eab792a95932f6\"><code>c74c8af</code></a> 1.3.7</li>\n<li><a href=\"https://github.com/npm/ini/commit/024b8b55ac1c980c6225607b007714c54eb501ba\"><code>024b8b5</code></a> update deps, add linting</li>\n<li><a href=\"https://github.com/npm/ini/commit/032fbaf5f0b98fce70c8cc380e0d05177a9c9073\"><code>032fbaf</code></a> Use Object.create(null) to avoid default object property hazards</li>\n<li><a href=\"https://github.com/npm/ini/commit/2da90391ef70db41d10f013e3a87f9a8c5d01a72\"><code>2da9039</code></a> 1.3.6</li>\n<li><a href=\"https://github.com/npm/ini/commit/cfea636f534b5ca7550d2c28b7d1a95d936d56c6\"><code>cfea636</code></a> better git push script, before publish instead of after</li>\n<li><a href=\"https://github.com/npm/ini/commit/56d2805e07ccd94e2ba0984ac9240ff02d44b6f1\"><code>56d2805</code></a> do not allow invalid hazardous string as section name</li>\n<li>See full diff in <a href=\"https://github.com/isaacs/ini/compare/v1.3.5...v1.3.7\">compare view</a></li>\n</ul>\n</details>\n<details>\n<summary>Maintainer changes</summary>\n<p>This version was pushed to npm by <a href=\"https://www.npmjs.com/~isaacs\">isaacs</a>, a new releaser for ini since your current version.</p>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=ini&package-manager=npm_and_yarn&previous-version=1.3.5&new-version=1.3.7)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language\n- `@dependabot use these reviewers` will set the current reviewers as the default for future PRs for this repo and language\n- `@dependabot use these assignees` will set the current assignees as the default for future PRs for this repo and language\n- `@dependabot use this milestone` will set the current milestone as the default for future PRs for this repo and language\n\nYou can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/vuejs/vue-router/network/alerts).\n\n</details>","Url":"https://github.com/vuejs/vue-router/pull/3408","RelatedDescription":"Open PR \"build(deps): bump ini from 1.3.5 to 1.3.7\" (#3408)"},{"Id":"757252718","IsPullRequest":true,"CreatedAt":"2020-12-10T07:41:34","Actor":"nazarepiedady","Number":"3399","RawContent":null,"Title":"Portuguese translation of documentation","State":"closed","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n\r\n#### Motivation\r\nIt's true that it's more comfortable and easy to learn something in our first language,\r\nbased in this reality I translated the all parts of documentation to Portuguese, to give\r\nthe opportunity to learn Vue Router for people that speak portuguese and do not have\r\nso much skill in the English.\r\n\r\nNow I'm submitting all parts translated into Portuguese of the documentation.","Url":"https://github.com/vuejs/vue-router/pull/3399","RelatedDescription":"Closed or merged PR \"Portuguese translation of documentation\" (#3399)"},{"Id":"758828259","IsPullRequest":true,"CreatedAt":"2020-12-07T20:34:37","Actor":"Roriz","Number":"3407","RawContent":null,"Title":"docs(dynamic-matching): add optional param on docs","State":"open","Body":"## Motivation\r\nMake explicit the optional condition to params on path.\r\nThis behavior already is explicit on examples: https://github.com/vuejs/vue-router/blob/dev/examples/route-matching/app.js","Url":"https://github.com/vuejs/vue-router/pull/3407","RelatedDescription":"Open PR \"docs(dynamic-matching): add optional param on docs\" (#3407)"},{"Id":"758817835","IsPullRequest":false,"CreatedAt":"2020-12-07T20:25:49","Actor":"FluencyMatt","Number":"3406","RawContent":null,"Title":"Make RouterLink a functional component","State":"closed","Body":"### What problem does this feature solve?\r\nWhen there are hundreds of RouterLink components on a page (in table columns for instance), page performance suffers due to the overhead of maintaining all those instances. In our app, Vue dev tools Performance tab puts RouterLink at or near the top of the list. This feature will significantly reduce the render cost of RouterLink. \r\n\r\n### What does the proposed API look like?\r\nSwitching RouterLink to `functional: true` should be backwards compatible without adding anything to the API. I propose something like the following. My initial testing is promising. Happy to submit the PR.\r\n\r\n    functional: true,\r\n    render: function render (h, context) {\r\n        const router = context.parent.$router\r\n        const current = context.parent.$route\r\n        ... <etc. following all the functional component rules>\r\n        const data: any = { class: [classes, context.data.staticClass, context.data.class] }\r\n        ...\r\n        return h(context.props.tag, data, context.$slots.default)\r\n    }\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3406","RelatedDescription":"Closed issue \"Make RouterLink a functional component\" (#3406)"},{"Id":"758565587","IsPullRequest":false,"CreatedAt":"2020-12-07T15:01:33","Actor":"ivanushkaPr","Number":"3404","RawContent":null,"Title":"exports is not defined","State":"closed","Body":"### Version\r\n4.0.0-0\r\n\r\n### Reproduction link\r\n[https://codesandbox.io/s/vue-router-nodod?file=/src/App.vue](https://codesandbox.io/s/vue-router-nodod?file=/src/App.vue)\r\n\r\n### Steps to reproduce\r\nI have this file structure and files on my local computer - https://codesandbox.io/s/vue-router-nodod?file=/src/App.vue\r\nUnfortunately, this files work only in codesanbox. If start dev build via npm run serve on local computer, i get a following error in browser console:\r\n\r\nUncaught ReferenceError: exports is not defined\r\n    at Module.eval (vue-router.esm-bundler.js?6c02:2306)\r\n    at eval (vue-router.esm-bundler.js:3375)\r\n    at Module../node_modules/vue-router/dist/vue-router.esm-bundler.js (chunk-vendors.js:1247)\r\n    at __webpack_require__ (app.js:849)\r\n    at fn (app.js:151)\r\n    at eval (main.js:11)\r\n    at Module../src/main.js (app.js:1513)\r\n    at __webpack_require__ (app.js:849)\r\n    at fn (app.js:151)\r\n    at Object.1 (app.js:1526)\r\n\r\n\r\n\r\n\r\n\r\n\r\n### What is expected?\r\nexpecting the program to run correctly\r\n\r\n### What is actually happening?\r\nvue router doesnt work correctly\r\n\r\n---\r\nCan it be because i have old version of webpack or typescript installed globally on local machine? \r\nIf yes, why vue cli working correctly, but not vue-router.\r\nThis is my repository with all the files https://github.com/ivanushkaPr/vueRouting\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3404","RelatedDescription":"Closed issue \"exports is not defined\" (#3404)"},{"Id":"758578260","IsPullRequest":false,"CreatedAt":"2020-12-07T14:49:45","Actor":"Menna-Elgohary","Number":"3405","RawContent":null,"Title":"How to create sitemap file to my Vue application?","State":"closed","Body":"How to create sitemap file to my Vue application?","Url":"https://github.com/vuejs/vue-router/issues/3405","RelatedDescription":"Closed issue \"How to create sitemap file to my Vue application?\" (#3405)"},{"Id":"758542545","IsPullRequest":false,"CreatedAt":"2020-12-07T14:17:06","Actor":"huajianreno","Number":"3403","RawContent":null,"Title":"The callback passed to next is executed before mounted","State":"closed","Body":"### Version\r\n3.4.6\r\n\r\n### Reproduction link\r\nno link\r\n\r\n\r\n### Steps to reproduce\r\n1. have beforeRouteEnter and mounted hooks in a component\r\n2. have next() with callback in beforeRouteEnter\r\n3. use different version of vue-router before(3.4.5 or other) and after 3.4.6\r\n\r\n### What is expected?\r\nThe callback passed to next in beforeRouteEnter is executed after mounted.\r\n\r\n### What is actually happening?\r\nThe callback passed to next in beforeRouteEnter is executed before mounted.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3403","RelatedDescription":"Closed issue \"The callback passed to next is executed before mounted\" (#3403)"},{"Id":"758184886","IsPullRequest":false,"CreatedAt":"2020-12-07T08:53:41","Actor":"huajianreno","Number":"3402","RawContent":null,"Title":"A callback to next() of beforeRouteEnter executed before mounted()","State":"closed","Body":"### Version\r\n3.4.6\r\n\r\n### Reproduction link\r\nno reproduction link\r\nmust compile more than once\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n1. have beforeRouteEnter and mounted hooks in a component\r\n2. have next() with callback in beforeRouteEnter\r\n3. use different version of vue-router before(3.4.5 or other) and after 3.4.6\r\n\r\n### What is expected?\r\nthe order of the executions of callback in next() of beforeRouteEnter and mounted are same in different version of view-router\r\n\r\n### What is actually happening?\r\nthe order of the executions of callback in next() of beforeRouteEnter and mounted are different in different version of view-router\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3402","RelatedDescription":"Closed issue \"A callback to next() of beforeRouteEnter executed before mounted()\" (#3402)"},{"Id":"758182267","IsPullRequest":false,"CreatedAt":"2020-12-07T05:49:31","Actor":"huajianreno","Number":"3401","RawContent":null,"Title":"A callback to next() of beforeRouteEnter executed before mounted()","State":"closed","Body":"**Steps to reproduce**\r\n1. have beforeRouteEnter and mounted hooks in a component\r\n2. have next() with callback in beforeRouteEnter\r\n3. use different version of vue-router before(3.4.5 or other) and after 3.4.6\r\n\r\n**What is expected?**\r\nthe order of the executions of callback in next() of beforeRouteEnter and mounted is same in different version of view-router\r\n\r\n**What is actually happening?**\r\nthe order of the executions of callback in next() of beforeRouteEnter and mounted is different in different version of view-router\r\n\r\n","Url":"https://github.com/vuejs/vue-router/issues/3401","RelatedDescription":"Closed issue \"A callback to next() of beforeRouteEnter executed before mounted()\" (#3401)"},{"Id":"757952987","IsPullRequest":true,"CreatedAt":"2020-12-06T17:30:22","Actor":"FrancoisCapon","Number":"3400","RawContent":null,"Title":"docs: typo","State":"closed","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\n","Url":"https://github.com/vuejs/vue-router/pull/3400","RelatedDescription":"Closed or merged PR \"docs: typo\" (#3400)"},{"Id":"755390750","IsPullRequest":false,"CreatedAt":"2020-12-02T16:40:33","Actor":"lgmf-daitan","Number":"3398","RawContent":null,"Title":"Navigation Resolution Flow - AfterRouteLeave","State":"closed","Body":"### What problem does this feature solve?\r\nI have a Vue mixin that is used to register/unregister Vuex's store modules that is intimately connected to the navigation flow.\r\n\r\n```javascript\r\n\r\nimport store from '@/store';\r\n\r\nexport default ({ modulePath, module }) => ({\r\n  beforeRouteEnter(to, from, next) {\r\n    if (!store.hasModule(modulePath)) {\r\n      store.registerModule(modulePath, module);\r\n    }\r\n    next();\r\n  },\r\n  beforeRouteLeave(to, from, next) {\r\n    if (store.hasModule(modulePath)) {\r\n      store.unregisterModule(modulePath);\r\n    }\r\n    next();\r\n  },\r\n});\r\n```\r\n\r\nI need to do that because we have a HUGE app and I want to decrease the size of our Store is in memory, its the same purpose as lazy loading components\r\n\r\nThe problem is that the \"beforeRouteLeave\" is being executed before the \"beforeDestroy\" lifecycle and because of that I'm facing a memory leak problem because in a particular case we use a WebSocket connect that was supposed to be disconnected when the page component was about to be destroyed.\r\n\r\n### What does the proposed API look like?\r\nMy suggestion would be to add another navigation lifecycle that would guarantee that the component was already destroyed.\r\nAdd a navigation guard that would guarantee that the activated component was already destroyed.\r\n\r\n```javascript\r\nconst Foo = {\r\n  template: `...`,\r\n  beforeRouteEnter (to, from, next) {\r\n    // called before the route that renders this component is confirmed.\r\n    // does NOT have access to `this` component instance,\r\n    // because it has not been created yet when this guard is called!\r\n  },\r\n  beforeRouteUpdate (to, from, next) {\r\n    // called when the route that renders this component has changed.\r\n    // This component being reused (by using an explicit `key`) in the new route or not doesn't change anything.\r\n    // For example, for a route with dynamic params `/foo/:id`, when we\r\n    // navigate between `/foo/1` and `/foo/2`, the same `Foo` component instance\r\n    // will be reused (unless you provided a `key` to `<router-view>`), and this hook will be called when that happens.\r\n    // has access to `this` component instance.\r\n  },\r\n  beforeRouteLeave (to, from, next) {\r\n    // called when the route that renders this component is about to\r\n    // be navigated away from.\r\n    // has access to `this` component instance.\r\n  },\r\n  afterRouteLeave(to, from, next) {\r\n    // called after the destroy the route activated component \r\n  }\r\n}\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3398","RelatedDescription":"Closed issue \"Navigation Resolution Flow - AfterRouteLeave\" (#3398)"},{"Id":"755383453","IsPullRequest":false,"CreatedAt":"2020-12-02T15:39:28","Actor":"lgmf-daitan","Number":"3397","RawContent":null,"Title":"Navigation Resolution Flow - AfterRouteLeave","State":"closed","Body":"Hello,\r\n\r\nI have a Vue mixin that is used to register/unregister Vuex store modules that is intimally connected to the navigation flow.\r\n\r\n```javascript\r\nimport store from '@/store';\r\n\r\nexport default ({ modulePath, module }) => ({\r\n  beforeRouteEnter(to, from, next) {\r\n    if (!store.hasModule(modulePath)) {\r\n      store.registerModule(modulePath, module);\r\n    }\r\n    next();\r\n  },\r\n  beforeRouteLeave(to, from, next) {\r\n    if (store.hasModule(modulePath)) {\r\n      store.unregisterModule(modulePath);\r\n    }\r\n    next();\r\n  },\r\n});\r\n```\r\n\r\nThe problem is that the `beforeRouteLeave` is beeing executed before the `beforeDestroy` lifecycle and because of that I'm facing a memory leak problem, because on a particular case we use an websocket connect that was suppose to be disconnected when the page component was about to be destroyed.\r\n\r\nIs there a nicer way of doing that? \r\n\r\nIf there isnt my suggestion would be to add another navigation lifecycle that would guarenteed that the component was already destroed.","Url":"https://github.com/vuejs/vue-router/issues/3397","RelatedDescription":"Closed issue \"Navigation Resolution Flow - AfterRouteLeave\" (#3397)"},{"Id":"755273578","IsPullRequest":false,"CreatedAt":"2020-12-02T14:01:58","Actor":"Gokhank58","Number":"3396","RawContent":null,"Title":"Vue JS Dynamic Routes","State":"closed","Body":"### What problem does this feature solve?\r\nI want to redirect the whole system with a system tree coming from restful api. I would like to add localstorage or json data coming directly from apiden into the vue router in a similar way to addRoutes.\r\n\r\n### What does the proposed API look like?\r\n```javascript\r\nasync function loadView(view) {\r\n  return () => import(/* webpackChunkName: \"view-[request]\" */ '@/views/'   view)\r\n}\r\n\r\nfunction parseSystemTree(item) {\r\n  let nav = []\r\n  Object.keys(item).forEach(key => {\r\n    \r\n    if (item[key].link !== '') {\r\n      let navData = {\r\n        path: item[key].link,\r\n        name: item[key].name,\r\n        meta: {title: item[key].name},\r\n        component: loadView(item[key].view.toString()), /* import('@/views/Settings/UserOperations/AddNewUser.vue') */\r\n        children: Object.keys(item[key].child).length > 0 ? parseSystemTree(item[key].child) : []\r\n      }\r\n\r\n      nav.push(navData)\r\n    }\r\n  })\r\n  return nav\r\n}\r\n\r\nvar navigations = []\r\n\r\nif (typeof localStorage.getItem('system_tree') !== 'object') {\r\n  const systemTree = JSON.parse(localStorage.getItem('system_tree'))\r\n  navigations = parseSystemTree(systemTree)\r\n}\r\n\r\nconst router = new VueRouter({\r\n  mode: 'history',\r\n  base: process.env.BASE_URL,\r\n  // routes\r\n  routes: routes.concat(navigations)\r\n})\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3396","RelatedDescription":"Closed issue \"Vue JS Dynamic Routes\" (#3396)"},{"Id":"755266201","IsPullRequest":false,"CreatedAt":"2020-12-02T13:17:11","Actor":"Gokhank58","Number":"3395","RawContent":null,"Title":"Vue JS Dynamic Router No Response","State":"closed","Body":"I want to use the router dynamically. I installed the babel-dynamic-import plug-in. I don't get any errors, but when it switches to the page, it can't render the component.\r\n\r\n`async function loadView(view) {\r\n  return () => import(/* webpackChunkName: \"view-[request]\" */ `@/views/${view}`)\r\n}\r\n\r\nfunction parseSystemTree(item) {\r\n  let nav = []\r\n  Object.keys(item).forEach(key => {\r\n    \r\n    if (item[key].link !== '') {\r\n      let navData = {\r\n        path: item[key].link,\r\n        name: item[key].name,\r\n        meta: {title: item[key].name},\r\n        component: loadView(item[key].view.toString()), /* import('@/views/Settings/UserOperations/AddNewUser.vue') */\r\n        children: Object.keys(item[key].child).length > 0 ? parseSystemTree(item[key].child) : []\r\n      }\r\n\r\n      nav.push(navData)\r\n    }\r\n  })\r\n  return nav\r\n}\r\n\r\nvar navigations = []\r\n\r\nif (typeof localStorage.getItem('system_tree') !== 'object') {\r\n  const systemTree = JSON.parse(localStorage.getItem('system_tree'))\r\n  navigations = parseSystemTree(systemTree)\r\n}\r\n\r\nconst router = new VueRouter({\r\n  mode: 'history',\r\n  base: process.env.BASE_URL,\r\n  // routes\r\n  routes: routes.concat(navigations)\r\n})`","Url":"https://github.com/vuejs/vue-router/issues/3395","RelatedDescription":"Closed issue \"Vue JS Dynamic Router No Response\" (#3395)"},{"Id":"754594200","IsPullRequest":false,"CreatedAt":"2020-12-01T18:18:34","Actor":"realnot","Number":"3394","RawContent":null,"Title":"Multiple paths for single route","State":"closed","Body":"### What problem does this feature solve?\r\nThis one:  https://github.com/pillarjs/path-to-regexp/issues/235\r\n\r\nCurrent error:\r\n\r\n```console\r\nvue-router.esm.js?8c4f:1495 Uncaught TypeError: path.replace is not a function\r\n    at normalizePath (vue-router.esm.js?8c4f:1495)\r\n    at addRouteRecord (vue-router.esm.js?8c4f:1372)\r\n    at eval (vue-router.esm.js?8c4f:1422)\r\n    at Array.forEach (<anonymous>)\r\n    at addRouteRecord (vue-router.esm.js?8c4f:1418)\r\n    at eval (vue-router.esm.js?8c4f:1422)\r\n    at Array.forEach (<anonymous>)\r\n    at addRouteRecord (vue-router.esm.js?8c4f:1418)\r\n    at eval (vue-router.esm.js?8c4f:1422)\r\n    at Array.forEach (<anonymous>)\r\n```\r\n\r\n### What does the proposed API look like?\r\n\r\n```javascript\r\npath: ['create', ':id'] \r\n```\r\n\r\nApply the first one if no argument is passed and the second one in other case.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3394","RelatedDescription":"Closed issue \"Multiple paths for single route\" (#3394)"},{"Id":"752675978","IsPullRequest":false,"CreatedAt":"2020-11-28T22:57:27","Actor":"tstriker","Number":"3393","RawContent":null,"Title":"route change should not be changing state until the previous component has been unmounted","State":"closed","Body":"### What problem does this feature solve?\r\nWhen navigating between routes, the changes to state happen before the previous component has been unmounted.\r\n\r\nThis results in recalculation of any computed properties that rely on the state, even though we'll remove this component a millisecond later.\r\n\r\nRoute change should fire all relevant navigation signals, but it shouldn't change the state until the old component has been unmounted, as otherwise it's creating side-effects\r\n\r\n### What does the proposed API look like?\r\nthe step 11 \"dom updates triggered\" here https://next.router.vuejs.org/guide/advanced/navigation-guards.html#the-full-navigation-resolution-flow should be split up into \r\nunmount old component -> update route state -> mount new component\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3393","RelatedDescription":"Closed issue \"route change should not be changing state until the previous component has been unmounted\" (#3393)"},{"Id":"752230384","IsPullRequest":true,"CreatedAt":"2020-11-27T15:08:16","Actor":"syu93","Number":"3392","RawContent":null,"Title":"docs: comma","State":"closed","Body":"Fix #3391","Url":"https://github.com/vuejs/vue-router/pull/3392","RelatedDescription":"Closed or merged PR \"docs: comma\" (#3392)"},{"Id":"752229260","IsPullRequest":false,"CreatedAt":"2020-11-27T15:08:16","Actor":"syu93","Number":"3391","RawContent":null,"Title":"Missing column in code snippet in scroll behavior documentation (Smooth Scrolling)","State":"closed","Body":"### Version\r\n3.4.9\r\n\r\n### Reproduction link\r\n[https://router.vuejs.org/guide/advanced/scroll-behavior.html#smooth-scrolling](https://router.vuejs.org/guide/advanced/scroll-behavior.html#smooth-scrolling)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\nI spotted a missing column in code snippet in scroll behavior documentation (Smooth Scrolling)\r\n\r\nhttps://router.vuejs.org/guide/advanced/scroll-behavior.html#smooth-scrolling\r\n\r\n### What is expected?\r\nA column should be present after `selector: to.hash`\r\n\r\n### What is actually happening?\r\nNo column after `selector: to.hash`\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3391","RelatedDescription":"Closed issue \"Missing column in code snippet in scroll behavior documentation (Smooth Scrolling)\" (#3391)"},{"Id":"751532182","IsPullRequest":true,"CreatedAt":"2020-11-26T14:45:41","Actor":"ylc395","Number":"3390","RawContent":null,"Title":"fix(type): use any for Location.params","State":"closed","Body":"<!--\r\nPlease make sure to read the Pull Request Guidelines:\r\nhttps://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#pull-request-guidelines\r\n-->\r\nWhen passing props to route components, params are props, and props can be \"any\" type. For example:\r\n\r\nin route config:\r\n```js\r\nconst routes = [{\r\n    name: 'a',\r\n    path: '/a',\r\n    props: true,\r\n    component: A, // component A has a `aPropObject` prop \r\n}];\r\n```\r\n\r\nin component:\r\n```js\r\nthis.$router.push({\r\n    name: 'xxxx',\r\n    params: {\r\n        aPropObject: {}, // an object or anything else\r\n    },\r\n});\r\n```","Url":"https://github.com/vuejs/vue-router/pull/3390","RelatedDescription":"Closed or merged PR \"fix(type): use any for Location.params\" (#3390)"},{"Id":"751218186","IsPullRequest":false,"CreatedAt":"2020-11-26T08:45:07","Actor":"sqcrh","Number":"3389","RawContent":null,"Title":"Add a clear before handler that is called any time url navigation matches a route (not a route resolution / component).","State":"closed","Body":"### What problem does this feature solve?\r\nIt is a common need to create a route guard that checks if a user or resource is authorized or authenticated activating a *route*.  This currently does not exist, and the existing per route beforeEnter handler really aligns with component activation not route activation.  I think it makes more sense to include auth type guards in the url/routing module and not the component because the guard logic is shared among some large percentage of the routes and doesn't have relate specifically to component logic.  And often you want this logic to apply to some routes not all routes. Currently to meet this need you have to:\r\n\r\n  1. Watch $route.  Not ideal, because you have to roll your own logic to match the guard to the route.  \r\n  2. Use the global beforeEach.  Again, not ideal because you have to roll your own logic to apply guard to selected routes.  \r\n  3. Use beforeRouteUpdate and beforeRouteEnter in the component.  This isn't ideal because the global auth guards should not be buried in a component and they don't use any component logic.  The guard is related to the route.  \r\n  4. Reach for the beforeEnter handler, which only activates when the route resolution is changed but many people expect it to be called when the the route is matched\r\n\r\nI think there is a need for this based the necessity of a call out in the documentation, a handful of issues in the repo, and questions on the forum.  The current route paradigm makes sense and has parity when you are talking about a component (enter, update, leave).  But when you talk about a **route** there is a parity mismatch.  You would expect a route handler to be called an time the route url changes and a route is matched.\r\n\r\nI see there is was a proposal to add a beforeUpdate, which I think was rightfully closed with an addition to the component.\r\nhttps://github.com/vuejs/vue-router/issues/1577\r\n\r\nThere was also a proposal to deprecate beforeEnter, which I think actually makes sense because again beforeEnter is confusing, but without a replacement i understand why it was closed. \r\nhttps://github.com/vuejs/vue-router/issues/2540\r\n\r\nSome more relevant issues and questions:\r\n  * https://github.com/vuejs/vue-router/issues/2600\r\n  * https://github.com/vuejs/vue-router/issues/1012\r\n  * https://forum.vuejs.org/t/beforeenter-doesnt-catch-param-changes/97451\r\n  * https://forum.vuejs.org/t/how-to-invoke-beforeenter-everytime-route-param-changes-in-the-same-path/97551\r\n  * https://forum.vuejs.org/t/vue-router-beforeenter-guard-not-working-on-url-change/42300\r\n  * https://forum.vuejs.org/t/vue-router-beforeenter-doesnt-work-properly-for-children-path/20019\r\n  * https://forum.vuejs.org/t/vue-router-trigger-beforeenter-in-all-segments-of-the-url/37462\r\n\r\n\r\n\r\n\r\n### What does the proposed API look like?\r\nDeprecate confusing beforeEnter that really aligns with the component not the route and create a handler called before, beforeNavigate, or beforeMatch that is called before a *route* is matched and pushed onto the stack.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vue-router/issues/3389","RelatedDescription":"Closed issue \"Add a clear before handler that is called any time url navigation matches a route (not a route resolution / component).\" (#3389)"}],"ResultType":"GitHubIssue"},"Vuex-Issues":{"Issues":[{"Id":"771006334","IsPullRequest":true,"CreatedAt":"2020-12-18T16:15:21","Actor":"fangbinwei","Number":"1907","RawContent":null,"Title":"fix: webpack bundle with 'vuex.esm-bundler.js'","State":"open","Body":"fixes #1906","Url":"https://github.com/vuejs/vuex/pull/1907","RelatedDescription":"Open PR \"fix: webpack bundle with 'vuex.esm-bundler.js'\" (#1907)"},{"Id":"770995445","IsPullRequest":false,"CreatedAt":"2020-12-18T15:59:52","Actor":"fangbinwei","Number":"1906","RawContent":null,"Title":"tree shaking not work because of vuex.mjs","State":"open","Body":"### Version\r\n4.0.0-rc.2\r\n\r\n### Reproduction link\r\n[https://github.com/fangbinwei/vuex-next-issue](https://github.com/fangbinwei/vuex-next-issue)\r\n\r\n### Steps to reproduce\r\n1. yarn build\r\n2. search `prev state` in dist/main.js to validate if bundle contains `createLogger`\r\n\r\nhttps://github.com/vuejs/vuex/blob/bb7885700d7bd7afd4d12fc8be7f5b3eeaa58b0e/src/plugins/logger.js#L33\r\n\r\n**main.js**\r\n```js\r\n// tree shaking not work because of vuex.mjs\r\nimport {Store} from 'vuex'\r\n\r\nconsole.log(Store)\r\n```\r\noutput(external vue)\r\n```bash\r\n[webpack-cli] Compilation finished\r\nasset main.js 12.1 KiB [emitted] [minimized] (name: main) 2 related assets\r\norphan modules 400 bytes [orphan] 1 module\r\nruntime modules 221 bytes 1 module\r\nbuilt modules 35.6 KiB [built]\r\n  ./src/index.js   1 modules 567 bytes [built] [code generated]\r\n  ./node_modules/vuex/dist/vuex.cjs.js 35 KiB [built] [code generated]\r\n  external \"Vue\" 42 bytes [built] [code generated]\r\nwebpack 5.11.0 compiled successfully in 713 ms\r\n✨  Done in 3.59s.\r\n```\r\n\r\n**main.js**\r\n```js\r\n// tree shaking work\r\nimport {Store} from 'vuex/dist/vuex.esm-bundler.js'\r\n\r\nconsole.log(Store)\r\n```\r\noutput(external vue)\r\n\r\n```bash\r\n[webpack-cli] Compilation finished\r\nasset main.js 9.8 KiB [emitted] [minimized] (name: main) 2 related assets\r\norphan modules 35.1 KiB [orphan] 2 modules\r\nruntime modules 221 bytes 1 module\r\n./src/index.js   2 modules 35.3 KiB [not cacheable] [built] [code generated]\r\nwebpack 5.11.0 compiled successfully in 797 ms\r\n✨  Done in 2.47s.\r\n```\r\n\r\n### What is expected?\r\n drop `createLogger` from the bundle\r\n\r\n### What is actually happening?\r\nbundle contains `createLogger`\r\n\r\n---\r\nI think tree shaking not work because of  two reasons, (I know vuex.mjs wrap vuex.cjs.js because of some rules in node)\r\n\r\n1. vuex.mjs use `default import`\r\n2. vuex.mjs import CommonJS(vuex.cjs.js) \r\n\r\nMaybe we can do like below\r\n```diff\r\n  \"exports\": {\r\n    \".\": {\r\n+      \"module\": \"./dist/vuex.esm-bundler.js\",\r\n      \"require\": \"./dist/vuex.cjs.js\",\r\n      \"import\": \"./dist/vuex.mjs\"\r\n    },\r\n    \"./\": \"./\"\r\n  },\r\n```\r\n\r\nnodejs don't support `module` in `exports`, so it can execute `dist/vuex.mjs`\r\n\r\n[webpack support `module` in `exports`](https://webpack.js.org/guides/package-exports/#conditions), it will use `dist/vuex.esm-bundler.js` first if it is valid, since the order of `\"module\"` is in front of the `\"import\"`\r\n\r\n### Moreover\r\nsince `vuex.mjs` wrap CommonJS which contains `require('vue')` and it let vuex doesn't compatiable with [webpack externals script](https://webpack.js.org/configuration/externals/#script), check [this issue](https://github.com/vuejs/vue-cli/issues/6149). [Reproduction link](https://github.com/fangbinwei/vuex-next-issue-external-script)\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1906","RelatedDescription":"Open issue \"tree shaking not work because of vuex.mjs\" (#1906)"},{"Id":"769800857","IsPullRequest":false,"CreatedAt":"2020-12-18T02:19:37","Actor":"uinio","Number":"1903","RawContent":null,"Title":"StoreApp and Namespace","State":"closed","Body":"### What problem does this feature solve?\r\nstoreApp\r\n```ts\r\nimport { App } from 'vue';\r\nimport { Store } from 'vuex';\r\n\r\nexport interface StoreAppOptions<S = any> {\r\n  stores: Store<S>[];\r\n}\r\n\r\nexport class StoreApp<S = any> {\r\n  readonly stores: Store<S>[];\r\n\r\n  constructor(stores: StoreAppOptions) {\r\n    this.stores = stores.stores;\r\n  }\r\n  install(app: App): void {\r\n    this.stores.forEach((store) => store.install(app));\r\n  }\r\n}\r\n\r\nexport function createStoreApp(app: StoreAppOptions): StoreApp {\r\n  return new StoreApp(app);\r\n}\r\n\r\n```\r\nnamespace\r\n```ts\r\nexport function createNamespace<S>(): InjectionKey<Store<S>> {\r\n  return Symbol('vuex');\r\n}\r\nexport interface StoreOptions<S> {\r\n  namespace: InjectionKey<Store<S>>;\r\n  state: S | (() => S);\r\n  getters?: GetterTree<S, S>;\r\n  actions?: ActionTree<S, S>;\r\n  mutations?: MutationTree<S>;\r\n  plugins?: Plugin<S>[];\r\n  strict?: boolean;\r\n  devtools?: boolean;\r\n}\r\n\r\nexport class Store<S> {\r\n   readonly namespace: InjectionKey<Store<S>>;\r\n   ...\r\n  install(app: App): void {\r\n    app.provide(this.namespace, this);\r\n  }\r\n}\r\n\r\nexport function useStore<S>(store: InjectionKey<Store<S>>): Store<S>;\r\n```\r\n\r\n\r\n### What does the proposed API look like?\r\nstoreApp can be split into multiple independent stores (remove RootState)\r\nnamespace better ts inference\r\n\r\n```ts\r\nexport interface CountState {\r\n  count: boolean;\r\n}\r\nexport const  COUNT_STORE = createNamespace<CountState >();\r\n\r\nexport default createStore({\r\n  namespace: COUNT_STORE ,\r\n  state,\r\n  getters,\r\n  mutations,\r\n  actions,\r\n});\r\n```\r\n\r\n```ts\r\nimport count from './count';\r\nimport { createStoreApp } from 'vuex';\r\n\r\nconst store = createStoreApp({\r\n  stores: [count],\r\n});\r\nexport default store;\r\n```\r\n```ts\r\nimport { useStore } from 'vuex';\r\nimport  {COUNT_STORE } from './count';\r\nconst store=useStore(COUNT_STORE);\r\nstore.useActions();\r\nstore.useState();\r\nstore.useGetter();\r\n....\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1903","RelatedDescription":"Closed issue \"StoreApp and Namespace\" (#1903)"},{"Id":"770361044","IsPullRequest":false,"CreatedAt":"2020-12-17T20:54:42","Actor":"hackel","Number":"1905","RawContent":null,"Title":"feat: Allow plugins in modules","State":"open","Body":"### What problem does this feature solve?\r\nCurrently plugins are only loaded in the root store instance and are silently ignored in modules.  It would be convenient and consistent to be able to register plugins within a module.  The plugin should receive a store with module-scoped state, getters, rootState, etc. just like an action.  This would allow for better separation of concerns and avoid having to modify the root store for things that are specific to a single module.\r\n\r\n### What does the proposed API look like?\r\nContrived example:\r\n```js\r\nconst store = new Vuex.Store({\r\n  modules: {\r\n    Module: {\r\n      namespaced: true,\r\n      state: { count: 0, countPlusOne: 1 },\r\n      mutations: {\r\n        setCountPlusOne: (state, count) => (state.countPlusOne = count),\r\n      },\r\n      plugins: [\r\n        store => {\r\n          store.watch(\r\n            (state, getters) => state.count,\r\n            (newVal, oldVal) => store.commit('setCountPlusOne', newVal)\r\n          );\r\n        },\r\n      ],\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1905","RelatedDescription":"Open issue \"feat: Allow plugins in modules\" (#1905)"},{"Id":"769824040","IsPullRequest":true,"CreatedAt":"2020-12-17T10:21:14","Actor":"JASONPANGGO","Number":"1904","RawContent":null,"Title":"fix a little typo in the comment","State":"open","Body":"anthor params => another params","Url":"https://github.com/vuejs/vuex/pull/1904","RelatedDescription":"Open PR \"fix a little typo in the comment\" (#1904)"},{"Id":"769755460","IsPullRequest":false,"CreatedAt":"2020-12-17T09:24:44","Actor":"uinio","Number":"1902","RawContent":null,"Title":"store splits a single node","State":"closed","Body":"","Url":"https://github.com/vuejs/vuex/issues/1902","RelatedDescription":"Closed issue \"store splits a single node\" (#1902)"},{"Id":"769589045","IsPullRequest":false,"CreatedAt":"2020-12-17T06:37:13","Actor":"uinio","Number":"1901","RawContent":null,"Title":"vue3 design reference","State":"closed","Body":"","Url":"https://github.com/vuejs/vuex/issues/1901","RelatedDescription":"Closed issue \"vue3 design reference\" (#1901)"},{"Id":"767223376","IsPullRequest":false,"CreatedAt":"2020-12-15T06:21:17","Actor":"tobiberlin","Number":"1900","RawContent":null,"Title":"Vuex - check if data really can be stored in localstorage","State":"open","Body":"### What problem does this feature solve?\r\nWe run into the following issue: \r\n\r\n - An app built with Vue/ vuex works fine\r\n - The issue appears when the app is embedded into another third party page with an iframe\r\n - when the user configured the browser to reject third party cookies the browser also rejects third parties (our app) from saving data in localstorage\r\n - this leads to an error in browser's console and the app is not rendered, the iframe stays empty\r\n\r\nIs there a way to check if localstorage can be used by the app? It would be helpful to avoid vuex to try to use the localstorage before really saving anything to it to avoid such problems.\r\n\r\n### What does the proposed API look like?\r\nNo idea\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1900","RelatedDescription":"Open issue \"Vuex - check if data really can be stored in localstorage\" (#1900)"},{"Id":"767132090","IsPullRequest":false,"CreatedAt":"2020-12-15T03:29:18","Actor":"Alanscut","Number":"1899","RawContent":null,"Title":"The test case fails to pass the test in the local environment.","State":"open","Body":"### Version\r\n4.0.0-rc.2\r\n\r\n### Reproduction link\r\n[https://github.com/vuejs/vuex/tree/v4.0.0-rc.2](https://github.com/vuejs/vuex/tree/v4.0.0-rc.2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n1. `npm install` \r\n2. `npm run test:e2e`  or   `yarn test:e2e`\r\n\r\n### What is expected?\r\nAll test cases pass in local environment.\r\n\r\n### What is actually happening?\r\ntest case todomvc failed\r\n\r\n---\r\nENV: <br >Ubuntu 18.04.5 LTS<br >\r\n          node: v12.20.0<br >\r\n          npm: v6.14.8<br >\r\n          yarn: 1.22.10<br >\r\n\r\nit's show failed by this:\r\n```shell\r\nFAIL test/e2e/todomvc.spec.js\r\n          e2e/todomvc > todomvc app\r\n          expect(received).toBe(expected) //  Object.is equality\r\n\r\n          Expect: \"edited!\"\r\n          Received: \"test\"\r\n\r\n               123 |            await click('footer') //  blur\r\n               124 |            expect(await count(' .todo.editing')).toBe(0)\r\n               125 |            expect(await text('.todo:nth-child(1) label')).toBe('edited')\r\n```\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1899","RelatedDescription":"Open issue \"The test case fails to pass the test in the local environment.\" (#1899)"},{"Id":"763289638","IsPullRequest":false,"CreatedAt":"2020-12-12T19:19:51","Actor":"millansingh","Number":"1898","RawContent":null,"Title":"Vuex fails to update state object with new object","State":"closed","Body":"### Version\r\n3.5.1\r\n\r\n### Reproduction link\r\n[https://codepen.io/millansingh/pen/dypOBjb](https://codepen.io/millansingh/pen/dypOBjb)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\nJust hit the button to run the mutation, but nothing will change which is the issue.\r\n\r\n### What is expected?\r\nThe mutation should change the object in store, making the \"output\" div show 3 instead of 1.\r\n\r\n### What is actually happening?\r\nNothing changes.\r\n\r\n---\r\nIn my personal project, the state itself is unchanged, rather than a reactivity issue. I couldn't open the Vue dev tools on Codepen to check this, but I think the same thing is happening. I would expect the object in the state to be replaced with the new object, but instead it doesn't change. I've tried the Object.assign method, object destructuring, and a simple stateObj = newObj type statement. All do nothing.\r\n\r\nNote that I can effectively get around this by looping through Object.keys of the state object and replacing them with the new object keys, but this should be possible by just replacing the object instead of using my workaround.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1898","RelatedDescription":"Closed issue \"Vuex fails to update state object with new object\" (#1898)"},{"Id":"761884373","IsPullRequest":true,"CreatedAt":"2020-12-11T04:28:49","Actor":"dependabot[bot]","Number":"1897","RawContent":null,"Title":"build(deps): bump ini from 1.3.5 to 1.3.7","State":"open","Body":"Bumps [ini](https://github.com/isaacs/ini) from 1.3.5 to 1.3.7.\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/npm/ini/commit/c74c8af35f32b801a7e82a8309eab792a95932f6\"><code>c74c8af</code></a> 1.3.7</li>\n<li><a href=\"https://github.com/npm/ini/commit/024b8b55ac1c980c6225607b007714c54eb501ba\"><code>024b8b5</code></a> update deps, add linting</li>\n<li><a href=\"https://github.com/npm/ini/commit/032fbaf5f0b98fce70c8cc380e0d05177a9c9073\"><code>032fbaf</code></a> Use Object.create(null) to avoid default object property hazards</li>\n<li><a href=\"https://github.com/npm/ini/commit/2da90391ef70db41d10f013e3a87f9a8c5d01a72\"><code>2da9039</code></a> 1.3.6</li>\n<li><a href=\"https://github.com/npm/ini/commit/cfea636f534b5ca7550d2c28b7d1a95d936d56c6\"><code>cfea636</code></a> better git push script, before publish instead of after</li>\n<li><a href=\"https://github.com/npm/ini/commit/56d2805e07ccd94e2ba0984ac9240ff02d44b6f1\"><code>56d2805</code></a> do not allow invalid hazardous string as section name</li>\n<li>See full diff in <a href=\"https://github.com/isaacs/ini/compare/v1.3.5...v1.3.7\">compare view</a></li>\n</ul>\n</details>\n<details>\n<summary>Maintainer changes</summary>\n<p>This version was pushed to npm by <a href=\"https://www.npmjs.com/~isaacs\">isaacs</a>, a new releaser for ini since your current version.</p>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=ini&package-manager=npm_and_yarn&previous-version=1.3.5&new-version=1.3.7)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language\n- `@dependabot use these reviewers` will set the current reviewers as the default for future PRs for this repo and language\n- `@dependabot use these assignees` will set the current assignees as the default for future PRs for this repo and language\n- `@dependabot use this milestone` will set the current milestone as the default for future PRs for this repo and language\n\nYou can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/vuejs/vuex/network/alerts).\n\n</details>","Url":"https://github.com/vuejs/vuex/pull/1897","RelatedDescription":"Open PR \"build(deps): bump ini from 1.3.5 to 1.3.7\" (#1897)"},{"Id":"760995269","IsPullRequest":true,"CreatedAt":"2020-12-10T07:40:57","Actor":"mat813","Number":"1896","RawContent":null,"Title":"Add a generic type for getters too.","State":"open","Body":"This allows you to write something like this, for example, in a vuex\r\nmodule, that lives in a subdirectory of the store, where it is most\r\ninteresting:\r\n\r\n```ts\r\nimport { GetterTree } from 'vuex';\r\n\r\nimport type { State as RootState, Getters as RootGetters } from '../';\r\nimport type { State } from './state';\r\n\r\nexport type Getters = {\r\n  loggedIn: boolean;\r\n  roles: string[];\r\n  isAdmin: boolean;\r\n};\r\n\r\nexport const getters: GetterTree<State, RootState, Getters, RootGetters> = {\r\n```\r\n\r\nAnd you get correct type inference in your editor.","Url":"https://github.com/vuejs/vuex/pull/1896","RelatedDescription":"Open PR \"Add a generic type for getters too.\" (#1896)"},{"Id":"760326276","IsPullRequest":false,"CreatedAt":"2020-12-09T13:23:20","Actor":"Slender1808","Number":"1895","RawContent":null,"Title":"bug store typescript","State":"open","Body":"### Version\r\n4.0.0-rc.2\r\n\r\n### Reproduction link\r\n[https://codesandbox.io/s/romantic-margulis-hq4nb?file=/src/main.js](https://codesandbox.io/s/romantic-margulis-hq4nb?file=/src/main.js)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n```\r\nimport { MutationTree } from 'vuex'\r\nimport { State } from './type'\r\n\r\nconst mutations: MutationTree<State> = {\r\n  search(state, payload: any) {\r\n    state.search = payload;\r\n  },\r\n}\r\n```\r\n\r\n### What is expected?\r\nstate.search is equal to payload\r\n\r\n### What is actually happening?\r\nstate.search remains the same\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1895","RelatedDescription":"Open issue \"bug store typescript\" (#1895)"},{"Id":"760321195","IsPullRequest":false,"CreatedAt":"2020-12-09T13:16:56","Actor":"Slender1808","Number":"1894","RawContent":null,"Title":"bug store typescript","State":"closed","Body":"I'm not able to change the status of my store\r\n```\r\nimport { MutationTree } from 'vuex'\r\nimport { State } from './type'\r\n\r\nconst mutations: MutationTree<State> = {\r\n  search(state, payload: any) {\r\n    state.search = payload;\r\n  },\r\n}\r\n```\r\n","Url":"https://github.com/vuejs/vuex/issues/1894","RelatedDescription":"Closed issue \"bug store typescript\" (#1894)"},{"Id":"760092068","IsPullRequest":true,"CreatedAt":"2020-12-09T07:47:57","Actor":"royhuang813","Number":"1893","RawContent":null,"Title":"Update getters.md","State":"open","Body":"缺少一个`return`","Url":"https://github.com/vuejs/vuex/pull/1893","RelatedDescription":"Open PR \"Update getters.md\" (#1893)"},{"Id":"757966318","IsPullRequest":true,"CreatedAt":"2020-12-06T16:37:07","Actor":"huaxhe","Number":"1892","RawContent":null,"Title":"docs(zh): add vuex translations for vuex 4","State":"open","Body":"1. Translated into Chinese based on previous version of the document.\r\n2. Add menu configuration.","Url":"https://github.com/vuejs/vuex/pull/1892","RelatedDescription":"Open PR \"docs(zh): add vuex translations for vuex 4\" (#1892)"},{"Id":"755102771","IsPullRequest":false,"CreatedAt":"2020-12-02T09:31:34","Actor":"gyjtiancai","Number":"1891","RawContent":null,"Title":"how to use the mapGetters, mapActions, mapMutations in vue3.0 setup()","State":"closed","Body":"### Version  \r\n\"vuex\": \"^4.0.0-0\",\r\n\r\n```javascript\r\nimport { mapGetters, useStore } from \"vuex\";\r\nexport default defineComponent({\r\n  name: \"vuex\",\r\n  setup(props, context) {\r\n    const store = useStore();\r\n    //  ok\r\n    console.log('userInfo',store.getters.userInfo);\r\n   \r\n   //how to use the mapGetters\r\n\r\n    return {\r\n      store,\r\n    };\r\n  },\r\n});\r\n```","Url":"https://github.com/vuejs/vuex/issues/1891","RelatedDescription":"Closed issue \"how to use the mapGetters, mapActions, mapMutations in vue3.0 setup()\" (#1891)"},{"Id":"751525209","IsPullRequest":false,"CreatedAt":"2020-11-26T11:43:50","Actor":"songololo","Number":"1890","RawContent":null,"Title":"v4 reactive getters behaviour appears to have changed for nested methods?","State":"open","Body":"### What problem does this feature solve?\r\nI used to be able to apply a reactive getter to a nested method inside an object instance stored in my v3 `vuex` state, but this doesn't appear to work anymore in v4.\r\n\r\nIn my case it was a `mapbox` instance which was created and then stored inside the `vuex` v3 store's state. I could then share this instance amongst various components and could also watch the instance for changes via reactive getters.\r\n\r\nFor example:\r\n```js\r\nstate: {\r\n  mapInstance: null, // <- gets assigned with a mapbox instance\r\n  // mapInstance contains a method called \"getZoom()\"\r\n},\r\ngetters: {\r\n  zoom: (state) => (state.mapInstance ? state.mapInstance.getZoom() : null),\r\n}\r\n```\r\n\r\nThe same approach no longer works in `vuex` v4.\r\n\r\n### What does the proposed API look like?\r\nI'm assuming something has changed in the internals of `vuex` v3 vs. v4: is there a way to deliberately expose certain nested properties or methods to reactive getters in `vuex` v4? Or else to enable the previous functionality?\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1890","RelatedDescription":"Open issue \"v4 reactive getters behaviour appears to have changed for nested methods?\" (#1890)"},{"Id":"751221578","IsPullRequest":false,"CreatedAt":"2020-11-26T08:16:27","Actor":"aleksey-hoffman","Number":"1889","RawContent":null,"Title":"Mutation handlers need some serious re-evaluation 🐒","State":"closed","Body":"### What problem does this feature solve?\r\nHey guys, can we discuss Vuex mutation handlers - arguably the most nonsensical thing in Vuex?\r\n\r\nI've been developing a big complex app for 2+ years with Vue and I still haven't found good reasons to keep using mutation handlers. According to Vuex docs and my experience, the only thing they do is make debugging a little bit easier in some situations, while over-complicating the codebase and making development process undoubtedly a lot more annoying for no good reason.\r\n\r\n### Examples: \r\nCompare the 2 examples demonstrated below, look at how much less code it takes to open a dialog and to change some of its properties by using the 1st method, compared to the 2nd method.\r\n\r\n## Method 1: direct mutation\r\nThis method achieves the same thing as the 2nd method, but requires **hundreds of times** less code (when app has a lot of components), which in itself makes code cleaner and less susceptible to bugs, which results in much more enjoyable development experience.\r\n\r\n### `App.vue`\r\n\r\n```html\r\n<v-btn @click=\"createNewItem({ type: 'file', extension: 'txt' })\">\r\n  Create new item\r\n</v-btn>\r\n```\r\n```js\r\nwatch: {\r\n  // Creating a global store watcher that handles actions, required for specific store properties\r\n  dialogs () {\r\n    handler (value) {\r\n      const propertyShouldBeWrittenToDrive = ...\r\n      if (propertyShouldBeWrittenToDrive) {\r\n        this.$store.dispatch('WRITE_TO_DRIVE', propertyShouldBeWrittenToDrive)\r\n      }\r\n    },\r\n    deep: true\r\n  }\r\n},\r\nmethods: {\r\n  createNewItem (params) {\r\n    // Set dialog data\r\n    this.$store.state.dialogs.createNewItemDialog.data = { \r\n      ...this.$store.state.dialogs.createNewItemDialog.data,\r\n      ...params \r\n    }\r\n    // Open dialog\r\n    this.$store.state.dialogs.createNewItemDialog.isOpened = true\r\n  }\r\n}\r\n```\r\n\r\n### `Dialogs.vue`\r\n```html\r\n<v-dialog v-model=\"$store.state.dialogs.createNewItemDialog.isOpened\">\r\n  <div class=\"title\">\r\n    Create new {{$store.state.dialogs.createNewItemDialog.data.type}}\r\n  </div>\r\n  <v-text-field\r\n    v-model=\"createNewItemDialog.data.name\"\r\n  />\r\n  <v-btn @click=\"$store.state.dialogs.createNewItemDialog.isOpened = false\">\r\n    close dialog\r\n  </v-btn>\r\n</v-dialog>\r\n```\r\n```js\r\n// NO COMPUTED PROPERTIES NEEDED\r\n```\r\n\r\n### `store.js`\r\n```js\r\nstate = {\r\n  dialogs: {\r\n    createNewItemDialog: {\r\n      value: false,\r\n      data: {\r\n        type: 'file',\r\n        name: '',\r\n        extension: ''\r\n      }\r\n    } \r\n  }\r\n}\r\n\r\n// NO MUTATIONS AND ACTIONS NEEDED\r\n```\r\n\r\nI know this method might, in theory, make it more difficult to track down the source of errors, but in practice, if there's only 3-5 functions that change a specific state property, it's pretty easy to determine which one of them caused the error by following the event logic. Mutations are always caused by some sort of known event (button press, input change, etc), so when an error appears during a specific event, it's not that difficult to track down the function that caused it, without using mutation handlers anyway.\r\n\r\n## Method 2: mutation handlers\r\n\r\nThis method is considered to be \"the best practice\" just because it improves debugging, while requiring a ton more work. Here's all the code you will need to set up the same dialog using this method.\r\n\r\nThis example is written with the official Vuex guidelines in mind (create getters, setters, create a separate action and mutation for each property, etc) to additionally demonstrate the absurdity of the current Vuex implementation.\r\n\r\n### `App.vue`\r\n\r\n```html\r\n<v-btn @click=\"createNewItem({ type: 'file', extension: 'txt' })\">\r\n  Create new item\r\n</v-btn>\r\n```\r\n\r\n```js\r\ncomputed: {\r\n  createNewItemDialogIsOpened: {\r\n    get () {\r\n      return this.$store.state.dialogs.createNewItemDialog.isOpened\r\n    },\r\n    set (value) {\r\n      this.$store.dispatch('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_IS_OPENED', value)\r\n    }\r\n  },\r\n  createNewItemDialogData: {\r\n    get () {\r\n      return this.$store.state.dialogs.createNewItemDialog.data\r\n    },\r\n    set (value) {\r\n      this.$store.dispatch('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA', value)\r\n    }\r\n  },\r\n  // 100 more similar computed properties for all the baseline properties of the other 50 dialogs\r\n  // ... {1,000 lines of code} ...\r\n},\r\nmethods: {\r\n  createNewItem (params) {\r\n    // Set dialog data\r\n    this.createNewItemDialogData = { ...this.createNewItemDialogData, ...params }\r\n    // Open dialog\r\n    this.createNewItemDialogIsOpened = true\r\n  }\r\n}\r\n```\r\n\r\n### `Dialogs.vue`\r\n\r\n```html\r\n<v-dialog v-model=\"createNewItemDialogIsOpened\">\r\n  <div class=\"title\">\r\n    Create new {{createNewItemDialogDataType}}\r\n  </div>\r\n  <v-text-field\r\n    v-model=\"createNewItemDialogDataName\"\r\n  />\r\n  <v-text-field\r\n    v-model=\"createNewItemDialogDataExtension\"\r\n  />\r\n  <v-btn @click=\"createNewItemDialogIsOpened = false\">\r\n    close dialog\r\n  </v-btn>\r\n</v-dialog>\r\n```\r\n\r\n```js\r\ncomputed: {\r\n  createNewItemDialogIsOpened: {\r\n    get () {\r\n      return this.$store.state.dialogs.createNewItemDialog.isOpened\r\n    },\r\n    set (value) {\r\n      this.$store.dispatch('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_IS_OPENED', value)\r\n    }\r\n  },\r\n  createNewItemDialogDataType: {\r\n    get () {\r\n      return this.$store.state.dialogs.createNewItemDialog.data.type\r\n    },\r\n    set (value) {\r\n      this.$store.dispatch('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_TYPE', value)    \r\n    }\r\n  },\r\n  createNewItemDialogDataName: {\r\n    get () {\r\n      return this.$store.state.dialogs.createNewItemDialog.data.name\r\n    },\r\n    set (value) {\r\n      this.$store.dispatch('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_NAME', value)\r\n    }\r\n  },\r\n  createNewItemDialogDataExtension: {\r\n    get () {\r\n      return this.$store.state.dialogs.createNewItemDialog.data.extension\r\n    },\r\n    set (value) {\r\n       this.$store.dispatch('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_EXTENSION', value)\r\n    }\r\n  },\r\n  // 300 more similar computed properties for all the properties of the other 50 dialogs\r\n  // ... {3,000 lines of code} ...\r\n}\r\n```\r\n\r\n### `store.js`\r\n```js\r\nconst state = {\r\n  dialogs: {\r\n    createNewItemDialog: {\r\n      value: false,\r\n      data: {\r\n        type: 'file',\r\n        name: '',\r\n        extension: ''\r\n      }\r\n    } \r\n  }\r\n}\r\n\r\nmutations: {\r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_IS_OPENED (state, value) {\r\n    state.dialogs.createNewItemDialog.isOpened = value\r\n  },\r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA (state, value) {\r\n    state.dialogs.createNewItemDialog.data = value\r\n  },\r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_TYPE (state, value) {\r\n    state.dialogs.createNewItemDialog.data.type = value\r\n  },\r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_NAME (state, value) {\r\n    state.dialogs.createNewItemDialog.data.name= value\r\n  },\r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_EXTENSION (state, value) {\r\n    state.dialogs.createNewItemDialog.data.extension= value\r\n  },\r\n  // 5000 more similar Vuex mutations for all the properties of the other 50 dialogs and other components\r\n  // ... {50,000 lines of code} ...\r\n},\r\nactions: {\r\n  WRITE_TO_DRIVE (state, params) {\r\n    ...\r\n  },\r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_IS_OPENED ({state, dispatch}, value) {\r\n    commit('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_IS_OPENED', value)\r\n    dispatch('WRITE_TO_DRIVE', value)\r\n  },\r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA ({state, dispatch}, value) {\r\n    commit('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA', value)\r\n  },\r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_TYPE ({state, dispatch}, value) {\r\n    commit('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_TYPE ', value)\r\n  }, \r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_NAME ({state, dispatch}, value) {\r\n    commit('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_NAME ', value)\r\n  }, \r\n  SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_EXTENSION ({state, dispatch}, value) {\r\n    commit('SET_DIALOGS_CREATE_NEW_ITEM_DIALOG_DATA_EXTENSION', value)\r\n  }, \r\n  // 5000 more similar Vuex actions for all the properties of the other 50 dialogs and other components\r\n  // ... {50,000 lines of code} ...\r\n}\r\n```\r\n\r\nAnd you have to do this for every single component of the app.\r\n\r\nAdd to that the inability to mutate properties from within a Vuex action and the fact that direct mutations are 10 - 500 times faster than the mutation handlers in cases where properties is mutated rapidly (once every few milliseconds), e.g. a slider without a debouncer / throttle, and it becomes clear that this insanity needs a re-evaluation.\r\n\r\nIn the real code, I managed to reduce the amount of computed properties by generating them dynamically for every nested property in `beforeCreated` hook of every component, and reduced the amount of mutations by creating a single generalized custom mutation function that sets specified deep properties automatically from the specified `'dot.notation.property.path'` string. But if this kind of heavy lifting is supposed be implemented manually by every developer for every new project, Vuex shouldn't really be considered a library then.\r\n\r\n### What does the proposed API look like?\r\nAnything but this. Surely there is a better / smarter / simpler way to do traceable mutations.\r\n\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1889","RelatedDescription":"Closed issue \"Mutation handlers need some serious re-evaluation 🐒\" (#1889)"},{"Id":"748443435","IsPullRequest":true,"CreatedAt":"2020-11-25T15:19:22","Actor":"kiaking","Number":"1884","RawContent":null,"Title":"fix: fix getters stop working when component is destroyed","State":"closed","Body":"ref #1878 #1883\r\n\r\nThis PR temporarily fixes the issue where getters (`computed`) get destroyed when components get destroyed. The limitation is that with this fix, getters will get re-evaluated each time it gets accessed regardless of whether dependencies have got updated or not.\r\n\r\nIt's not an ideal fix, but we have to wait for Vue 3.1 release to fix this issue completely. Learn more at #1883.","Url":"https://github.com/vuejs/vuex/pull/1884","RelatedDescription":"Closed or merged PR \"fix: fix getters stop working when component is destroyed\" (#1884)"},{"Id":"750605030","IsPullRequest":false,"CreatedAt":"2020-11-25T08:36:27","Actor":"maartenvanasperen","Number":"1888","RawContent":null,"Title":"add config to index types, this.$config from Nuxt is not recognised in the store (typescript).","State":"closed","Body":"### What problem does this feature solve?\r\nIn Vuex the config values from Nuxt are not recognised in Typescript: https://nuxtjs.org/blog/moving-from-nuxtjs-dotenv-to-runtime-config#using-your-config-values. So this.$config is available in the Vuex store and I can access the values, but it says property '$config' does not exist on type 'store'\r\n\r\nIn any vue component (with TS) it gets recognised and works as intended, but not in the Vuex store.\r\n\r\n### What does the proposed API look like?\r\nin vuex/types/index.d.ts add:\r\n`config: any;\r\n`\r\nThis resolves the problem and $config gets recognised in the Vuex store. Or is there a better way to extend the index.d.ts? I couldn't find how.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1888","RelatedDescription":"Closed issue \"add config to index types, this.$config from Nuxt is not recognised in the store (typescript).\" (#1888)"},{"Id":"750108597","IsPullRequest":true,"CreatedAt":"2020-11-24T22:28:09","Actor":"loongye","Number":"1887","RawContent":null,"Title":"Update index.md","State":"closed","Body":"Add missing mutation","Url":"https://github.com/vuejs/vuex/pull/1887","RelatedDescription":"Closed or merged PR \"Update index.md\" (#1887)"},{"Id":"749093713","IsPullRequest":true,"CreatedAt":"2020-11-24T02:17:28","Actor":"periscuelo","Number":"1885","RawContent":null,"Title":"(Some fixes for Vuex 3 ptbr docs)","State":"closed","Body":"@kiaking when you could merge I'll be glad. Thanks.","Url":"https://github.com/vuejs/vuex/pull/1885","RelatedDescription":"Closed or merged PR \"(Some fixes for Vuex 3 ptbr docs)\" (#1885)"},{"Id":"749096916","IsPullRequest":true,"CreatedAt":"2020-11-24T02:16:21","Actor":"periscuelo","Number":"1886","RawContent":null,"Title":"(docs 4.0 ptbr fix)","State":"closed","Body":"A little translation fix\r\n\r\n@kiaking when you could merge I'll be glad. Thanks.","Url":"https://github.com/vuejs/vuex/pull/1886","RelatedDescription":"Closed or merged PR \"(docs 4.0 ptbr fix)\" (#1886)"},{"Id":"748309109","IsPullRequest":true,"CreatedAt":"2020-11-22T18:18:50","Actor":"kiaking","Number":"1883","RawContent":null,"Title":"fix: fix getters being destroyed on component destroy (#1878)","State":"open","Body":"fix #1878\r\n\r\nThis PR aims to fix #1878, but at the moment this is just adding failing test case.\r\n\r\nThe problem we have is that when component gets destroyed, the getters (`computed`) get's destroyed via Vue. Hence if we call `registerModule` inside a component, any newly registered `computed` will disappear when that component gets destroyed, for example, when switching route.\r\n\r\nThe issue: vuejs/vue-next#1532\r\nSolution RFC: vuejs/rfcs#212\r\n\r\nWe have to wait for Vue 3.1 to completely resolve this issue.","Url":"https://github.com/vuejs/vuex/pull/1883","RelatedDescription":"Open PR \"fix: fix getters being destroyed on component destroy (#1878)\" (#1883)"},{"Id":"748211412","IsPullRequest":true,"CreatedAt":"2020-11-22T13:43:36","Actor":"periscuelo","Number":"1882","RawContent":null,"Title":"(docs ptBR fixes 4.0)","State":"closed","Body":"Some fixes found\r\n\r\n@ktsn I'll make reviews of translation 3.0 after too.\r\nThanks.","Url":"https://github.com/vuejs/vuex/pull/1882","RelatedDescription":"Closed or merged PR \"(docs ptBR fixes 4.0)\" (#1882)"},{"Id":"748201196","IsPullRequest":false,"CreatedAt":"2020-11-22T09:07:54","Actor":"weishijun14","Number":"1881","RawContent":null,"Title":"memory leak with socket.io and vue devtools ","State":"open","Body":"### Version\r\nvuex 4.0.0-beta.4\r\nvue 3.0.0\r\nsocket.io 2.3.1\r\n\r\n### Reproduction link\r\n\r\n**no links**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\nI'm use socket.io , and I have a big Json data, more than 100kb per 3 second,\r\n```javascript\r\n socket.on('someEvent', function(data) {\r\n       // data almost 100kb -- 150kb\r\n       _this.$store.commit('someMutationsName', data);\r\n  })\r\n\r\n```\r\n\r\n### What is expected?\r\nChrome momery keep normal.\r\n\r\n### What is actually happening?\r\nChrome momery usage keep increasing.\r\n\r\n---\r\nWhen I **comment this code** :\r\n```javascript\r\nthis._subscribers\r\n    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe\r\n    .forEach(function (sub) { return sub(mutation, this$1.state); });\r\n```\r\n\r\nor **uninstall Chrome vue devtool**  which I use this version:\r\n\r\n6.0.0 beta 2\r\n\r\nIt's back to normal.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1881","RelatedDescription":"Open issue \"memory leak with socket.io and vue devtools \" (#1881)"},{"Id":"748142257","IsPullRequest":true,"CreatedAt":"2020-11-22T07:47:25","Actor":"periscuelo","Number":"1880","RawContent":null,"Title":"(Add pt-br language) Vuex 4","State":"closed","Body":"Translated to Portuguese BR\r\nAdded config menu\r\n\r\n@ktsn Is it already possible to make the translation available? After a review of course?","Url":"https://github.com/vuejs/vuex/pull/1880","RelatedDescription":"Closed or merged PR \"(Add pt-br language) Vuex 4\" (#1880)"},{"Id":"747579521","IsPullRequest":false,"CreatedAt":"2020-11-20T16:33:10","Actor":"musashiM82","Number":"1879","RawContent":null,"Title":"try to add registerModule in router beforeEach","State":"closed","Body":"### Version\r\n4.0.0-rc.1\r\n\r\n### Reproduction link\r\n[https://github.com/musashiM82/register-module-in-router](https://github.com/musashiM82/register-module-in-router)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n* clone repo\r\n* execute `npm i && npm run serve`\r\n* open web app in browser\r\n* check console error ` [vuex] module namespace not found in mapGetters(): home/`\r\n* click on About link\r\n* check console error ` [vuex] module namespace not found in mapGetters(): about/`\r\n\r\n\r\n### What is expected?\r\nit is expected that store module is registered in correct way\r\n\r\n### What is actually happening?\r\nit is like that store module is not registered\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1879","RelatedDescription":"Closed issue \"try to add registerModule in router beforeEach\" (#1879)"},{"Id":"747574828","IsPullRequest":false,"CreatedAt":"2020-11-20T15:22:55","Actor":"musashiM82","Number":"1878","RawContent":null,"Title":"lost previous registered module during multiple registration","State":"open","Body":"### Version\r\n4.0.0-rc.1\r\n\r\n### Reproduction link\r\n[https://github.com/musashiM82/register-module-in-before-create-page](https://github.com/musashiM82/register-module-in-before-create-page)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Steps to reproduce\r\n* clone repo\r\n* execute `npm i && npm run serve`\r\n* open web app in browser\r\n* in \"Home\" page you can see \"state.home.count 1\"\r\n* click on \"About\" link\r\n* click on \"Home\" link\r\n* in \"Home\" page you can see \"state.home.count\" now\r\n\r\n### What is expected?\r\nit is expected that the second time that I go into Home page I continue to see \"state.home.count 1\"\r\n\r\n### What is actually happening?\r\nit is happening that I see \"state.home.count\". it is like the previous registered module is lost\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->","Url":"https://github.com/vuejs/vuex/issues/1878","RelatedDescription":"Open issue \"lost previous registered module during multiple registration\" (#1878)"}],"ResultType":"GitHubIssue"}},"RunOn":"2020-12-19T05:30:41.8211607Z","RunDurationInMilliseconds":1704}