{"Data":{"Blog":{"FeedItems":[{"Title":"OpenSSF Scorecard for .NET and the NuGet ecosystem","PublishedOn":"2024-11-04T17:07:24+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"OpenSSF Scorecard is a tool developed by the Open Source Security Foundation (OpenSSF) that provides automated security assessments for open-source projects. The primary goal of the Scorecard project...","Href":"https://devblogs.microsoft.com/nuget/openssf-scorecard-for-net-nuget/","RawContent":null},{"Title":"NuGetAudit 2.0: Elevating Security and Trust in Package Management","PublishedOn":"2024-07-17T19:37:50+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Introduction In November 2023 (NuGet 6.8, Visual Studio 17.8, .NET SDK 8.0.100), we released NuGet Audit. NuGet Audit provides warnings during restore when a package with a known vulnerability is used...","Href":"https://devblogs.microsoft.com/nuget/nugetaudit-2-0-elevating-security-and-trust-in-package-management/","RawContent":null},{"Title":"Building a Safer Future – How NuGet is Tackling Software Supply Chain Threats","PublishedOn":"2024-07-16T18:40:14+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Despite significant technological progress in addressing complex security threats, the key to preventing the next attack lies in adhering to fundamental security principles. It&#8217;s essential to...","Href":"https://devblogs.microsoft.com/nuget/building-a-safer-future-how-nuget-is-tackling-software-supply-chain-threats/","RawContent":null},{"Title":"Dark Mode Now Available on NuGet.org","PublishedOn":"2024-07-11T13:08:54+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"We won’t keep you “in the dark” about this any longer… Dark Mode for NuGet.org is finally here!   Your feedback has been invaluable in making this happen. We know that eye strain is a significant...","Href":"https://devblogs.microsoft.com/nuget/dark-mode-now-available-on-nuget-org/","RawContent":null},{"Title":"Announcing NuGet 6.10","PublishedOn":"2024-05-21T18:28:09+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"NuGet 6.10 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.10 for Windows, macOS, and Linux as a standalone executable. In NuGet 6.10, we introduce some...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-10/","RawContent":null},{"Title":"Announcing NuGet Commands in C# Dev Kit","PublishedOn":"2024-05-14T19:25:17+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"With the April release of C# Dev Kit, you can now manage your NuGet packages directly from Visual Studio Code using the new commands in the command palette. To add a NuGet package to your project, use...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/","RawContent":null},{"Title":"The NuGet.org repository signing certificate will be updated as soon as April 8th, 2024","PublishedOn":"2024-03-14T02:04:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Action required: If you validate that packages are repository signed by NuGet.org using a NuGet client policy, NuGet.exe verify command, or the dotnet nuget verify command, please follow these steps...","Href":"https://devblogs.microsoft.com/nuget/the-nuget-org-repository-signing-certificate-will-be-updated-as-soon-as-april-8th-2024/","RawContent":null},{"Title":"Refining Your Search: Introducing NuGet.org’s Compatible Framework Filters","PublishedOn":"2024-03-12T20:05:53+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Last year, we introduced search by target frameworks on NuGet.org, allowing you to filter your search results based on the framework(s) that a package targets. We received plenty of great feedback...","Href":"https://devblogs.microsoft.com/nuget/refining-your-search-introducing-nuget-orgs-compatible-framework-filters/","RawContent":null},{"Title":"Announcing NuGet 6.9","PublishedOn":"2024-02-14T00:33:14+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"NuGet 6.9 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.9 for Windows, macOS, and Linux as a standalone executable. In NuGet 6.9, we introduce some...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/","RawContent":null},{"Title":"Introducing NuGetSolver: A Powerful Tool for Resolving NuGet Dependency Conflicts in Visual Studio","PublishedOn":"2024-01-16T18:54:55+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"Managing dependencies on complex projects can be overwhelming. Developers often grapple with numerous direct and transitive dependencies across multiple projects. When different projects share...","Href":"https://devblogs.microsoft.com/nuget/introducing-nugetsolver-a-powerful-tool-for-resolving-nuget-dependency-conflicts-in-visual-studio/","RawContent":null}],"ResultType":"Feed"},"Gallery":{"Events":[{"Id":"44223512693","Type":"PullRequestEvent","CreatedAt":"2024-11-26T20:48:21","Actor":"agr","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10283","RelatedDescription":"Opened pull request \"Log enrichment with entry assembly metadata\" (#10283) at NuGet/NuGetGallery","RelatedBody":"Currently there is no way to figure out what version of job is running from logs. This change adds a property to all log messages with build information:\r\n\r\n![image](https://github.com/user-attachments/assets/b5b63b3a-b3f2-4e5e-9e0d-22a82aeeb896)\r\n\r\nWill save us some time when we need to figure out what exactly is running."},{"Id":"44198684837","Type":"PullRequestEvent","CreatedAt":"2024-11-26T09:22:57","Actor":"drewgillies","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10281","RelatedDescription":"Merged pull request \"Migrate ArchivePackages to using MSI for storage access\" (#10281) at NuGet/NuGetGallery","RelatedBody":"Addresses: https://github.com/NuGet/Engineering/issues/5441\r\n\r\nI took the opportunity to make this code consistent with like types (style, etc.). Essentially the logic flow is untouched, but some methods consumed here needed updates to parameters."},{"Id":"44184724773","Type":"PullRequestEvent","CreatedAt":"2024-11-25T22:58:37","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10269","RelatedDescription":"Merged pull request \"[OIDC 6] Find matching federated credential policy (policy evaluation)\" (#10269) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/NuGetGallery/issues/10212.\r\nDepends on https://github.com/NuGet/NuGetGallery/pull/10268.\r\n\r\nThis is a big chunk of the OIDC feature's business logic. A new `IFederatedCredentialEvaluator` is added which takes a list of federated credential policies and a bearer token and evaluates which trust policy, if any matches the given bearer token.\r\n\r\nThis is a read-only operation. The creation of the short-lived API key will be performed at a higher level.\r\n\r\nThere are two main parts of the logic.\r\n\r\nFirst, find the issuer of the bearer token and validate it using the appropriate, issuer-specific validation routine. This step can be summarized as \"Is this a valid token, issued by an expected issuer?\". This is done no matter the policies provided. to reduce the amount of information leaked about policies in our DB.\r\n\r\nSecond, if the token is valid, the code checks the claims in the token against the given polices. For the short term, this is checking if the `tid` and `oid` claims in a policy match the token.\r\n\r\nFor a future phase where we accept GitHub Actions tokens, the first step will be enhanced with GitHub OIDC signature validation and step 2 will validate against some expected build context provided by the user (e.g. is the token coming from an expected repository and branch). This is not part of the PR but I wanted to give a taste for how this code will expand in the future as we federate with more IdPs.\r\n\r\nThe returned `EvaluatedFederatedCredentialPolicies` is the result pattern because there are several error modes that should be handled differently, but gracefully. This is opposed to throwing different flavored exceptions, Generally, there is \"bad token\", \"no matching policy\", and \"matching policy\". The \"bad token\" state shows a helpful error message because it is unrelated to any specific policy. This eases debugging for the user. The \"unauthorized\" state will not show a detailed error message because we don't want to leak information about what policies the user has or doesn't have.\r\n\r\nThe caller of this new method will fetch the policies for a given user and call this method to find a matching policy if any."},{"Id":"44183025355","Type":"PullRequestEvent","CreatedAt":"2024-11-25T21:49:14","Actor":"Lanaparezanin","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10282","RelatedDescription":"Opened pull request \"Bugfix for PostProcess Stats job\" (#10282) at NuGet/NuGetGallery","RelatedBody":"\r\nAddresses https://github.com/orgs/NuGet/projects/21/views/1?filterQuery=milestone%3A%22Sprint+2024-11%22+assignee%3A%40me&pane=issue&itemId=64259916&issue=NuGet%7CEngineering%7C5445"}],"ResultType":"GitHubEvent"},"Home":{"Events":[{"Id":"44221483447","Type":"IssuesEvent","CreatedAt":"2024-11-26T19:35:49","Actor":"colejohnson66","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13965","RelatedDescription":"Opened issue \"`dotnet nuget push` fails with cryptic \"the system cannot find the path specified\"\" (#13965) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\ndotnet.exe\n\n### Product Version\n\n9.0.100 (59db016f11)\n\n### Worked before?\n\n8.0.403\n\n### Impact\n\nI'm unable to use this version\n\n### Repro Steps & Context\n\nWe have a private Gitea-based NuGet source on a 10.0.0.0/24 IP address. Our NuGet.Config looks like:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<configuration>\r\n  <packageSources>\r\n    <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" />\r\n    <add key=\"gitea\" value=\"http://10.0.0.31/api/packages/<>/nuget/index.json\" allowInsecureConnections=\"True\" />\r\n  </packageSources>\r\n  <packageSourceCredentials>\r\n    <gitea>\r\n        <add key=\"Username\" value=\"<>\" />\r\n        <add key=\"Password\" value=\"<>\" />\r\n      </gitea>\r\n  </packageSourceCredentials>\r\n</configuration>\r\n```\r\n\r\nOnce we upgraded from SDK 8.0.403 to 9.0.100, our Jenkins pipeline has been failing consistently with a cryptic error:\r\n\r\n```\r\nerror: Unable to load the service index for source http://10.0.0.31/api/packages/<>/nuget/index.json.\r\nerror:   The system cannot find the path specified.\r\n```\r\n\r\nWhat gets even more frustrating is that we can remote in and, using the local account, run the push command with no issues. But if Jenkins (under the SYSTEM account) tries, it fails. Using psexec, we can confirm it's not Jenkins that's the issue, but the usage of a SYSTEM account.\r\n\r\nI've managed to track the error down; It's thrown in `GetServiceIndexResourceV3`.\n\n### Verbose Logs\n\n```shell\nSpecify --help for a list of available options and commands.\r\nerror: Unrecognized option '--verbosity'\r\n\r\n\r\nUsage: dotnet nuget push [arguments] [options]\r\n\r\nArguments:\r\n  [root]  Specify the path to the package and your API key to push the package to the server.\r\n\r\nOptions:\r\n  -h|--help                      Show help information\r\n  --force-english-output         Forces the application to run using an invariant, English-based culture.\r\n  -s|--source <source>           Package source (URL, UNC/folder path or package source name) to use. Defaults to DefaultPushSource if specified in NuGet.Config.\r\n  -ss|--symbol-source <source>   Symbol server URL to use.\r\n  -t|--timeout <timeout>         Timeout for pushing to a server in seconds. Defaults to 300 seconds (5 minutes).\r\n  -k|--api-key <apiKey>          The API key for the server.\r\n  -sk|--symbol-api-key <apiKey>  The API key for the symbol server.\r\n  -d|--disable-buffering         Disable buffering when pushing to an HTTP(S) server to decrease memory usage.\r\n  -n|--no-symbols                If a symbols package exists, it will not be pushed to a symbols server.\r\n  --no-service-endpoint          Does not append \"api/v2/package\" to the source URL.\r\n  --interactive                  Allow the command to block and require manual action for operations like authentication.\r\n  --skip-duplicate               If a package and version already exists, skip it and continue with the next package in the push, if any.\r\n```\n```\n"},{"Id":"44190231510","Type":"IssuesEvent","CreatedAt":"2024-11-26T03:58:34","Actor":"Meai","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13964","RelatedDescription":"Opened issue \"Support file paths for <PackageVersion> in Directory.Packages.props\" (#13964) at NuGet/Home","RelatedBody":"### NuGet Product(s) Involved\n\nNuGet.exe, Visual Studio Package Management UI, Visual Studio Package Manager Console, MSBuild.exe, dotnet.exe, NuGet SDK\n\n### The Elevator Pitch\n\n**Goal:**\r\nThe following should automatically update the Visual Studio solution each time I change/remove the Path=\"\" so that I can switch between using a local project or its published nuget package version.\r\n```\r\n<Project>\r\n\t<PropertyGroup>\r\n\t\t<ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>\r\n\t\t<CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>\r\n\t</PropertyGroup>\r\n\t<ItemGroup>\r\n\t  <PackageVersion Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\r\n\t  <PackageVersion Include=\"ClassLibrary1\" Version=\"1.0.0\" Path=\"..\\..\\ClassLibrary1\\ClassLibrary1\\ClassLibrary1.csproj\" />\r\n\t</ItemGroup>\r\n</Project>\r\n```\r\n\r\n**Longer scenario description:**\r\nConsoleApp1 has a nuget reference to ClassLibrary1. Now I want to test local changes I made to ClassLibrary1. This is a very common usecase, you could argue that this is the primary usecase of having libraries. Sure I want my code to be isolated in another place but that doesn't mean that I want endless friction when actually developing this library which by definition will be used in possibly many other places. Alas in c# if I choose to use nuget packages I'm immediately entering that territory of endless friction because I'm forced to manually convert my nuget references in my entire solution to project references. Each time I want to test either the published package or test my local stashed changes I have to do this manual \"vendoring/linking\" step.\r\n\r\n**Comparison with other languages/package managers:**\r\nI think this is mostly a solved usecase by other package managers. Npm has 'link' and many other \"workspace\" tools, either built into npm/pnpm or another way from Microsoft via rushstack. Golang has the vendor system which is not exactly the same but it sort of solves this issue as well because each time you change the location of the package from an url to a filepath it should vendor itself correctly again and afaik you are coding directly against your symlinked local code.\n\n### Additional Context and Details\n\n_No response_"},{"Id":"44186422570","Type":"IssuesEvent","CreatedAt":"2024-11-26T00:25:44","Actor":"kartheekp-ms","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13963","RelatedDescription":"Opened issue \"Update docs to notify customers that NU3043 warning is promoted to an error.\" (#13963) at NuGet/Home","RelatedBody":"Update docs during NuGet 6.13 release timeframe to notify customers that [NU3043](https://learn.microsoft.com/nuget/reference/errors-and-warnings/nu3043) warning is promoted to an error."},{"Id":"44186282472","Type":"IssuesEvent","CreatedAt":"2024-11-26T00:17:44","Actor":"kartheekp-ms","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13962","RelatedDescription":"Opened issue \"[DCR] Raise an error for SHA-1 fingerprints usage in NuGet.exe sign command\" (#13962) at NuGet/Home","RelatedBody":"### NuGet Product(s) Affected\n\nNuGet.exe\n\n### Current Behavior\n\nnuget.exe sign commands to accept fingerprints from the SHA-2 family (SHA256, SHA384, or SHA512) instead of SHA-1. If a SHA-1 fingerprint is passed, the commands raise a [NU3043](https://learn.microsoft.com/nuget/reference/errors-and-warnings/nu3043) warning indicating that SHA-1 is insecure. This error should be eventually escalated to an error around the .NET 10 timeframe to enforce stronger security standards.\n\n### Desired Behavior\n\nnuget.exe sign command to accept fingerprints from the SHA-2 family (SHA256, SHA384, or SHA512) instead of SHA-1. If a SHA-1 fingerprint is passed, the commands raise an error indicating that SHA-1 is insecure. This approach will enhance security by ensuring that only strong, approved hash algorithms are used in NuGet sign commands.\n\n### Additional Context\n\nRelated to https://github.com/NuGet/Home/issues/13891"},{"Id":"44184573807","Type":"PullRequestEvent","CreatedAt":"2024-11-25T22:51:36","Actor":"OliaG","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/pull/13961","RelatedDescription":"Opened pull request \"Adding a proposal for the new CLI command to fix vulnerabilities\" (#13961) at NuGet/Home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[],"ResultType":"GitHubEvent"}},"RunOn":"2024-11-27T03:30:20.8197007Z","RunDurationInMilliseconds":915}