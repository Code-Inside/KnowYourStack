{"Data":{"Blog":{"FeedItems":[{"Title":"OpenSSF Scorecard for .NET and the NuGet ecosystem","PublishedOn":"2024-11-04T17:07:24+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"OpenSSF Scorecard is a tool developed by the Open Source Security Foundation (OpenSSF) that provides automated security assessments for open-source projects. The primary goal of the Scorecard project...","Href":"https://devblogs.microsoft.com/nuget/openssf-scorecard-for-net-nuget/","RawContent":null},{"Title":"NuGetAudit 2.0: Elevating Security and Trust in Package Management","PublishedOn":"2024-07-17T19:37:50+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Introduction In November 2023 (NuGet 6.8, Visual Studio 17.8, .NET SDK 8.0.100), we released NuGet Audit. NuGet Audit provides warnings during restore when a package with a known vulnerability is used...","Href":"https://devblogs.microsoft.com/nuget/nugetaudit-2-0-elevating-security-and-trust-in-package-management/","RawContent":null},{"Title":"Building a Safer Future – How NuGet is Tackling Software Supply Chain Threats","PublishedOn":"2024-07-16T18:40:14+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Despite significant technological progress in addressing complex security threats, the key to preventing the next attack lies in adhering to fundamental security principles. It&#8217;s essential to...","Href":"https://devblogs.microsoft.com/nuget/building-a-safer-future-how-nuget-is-tackling-software-supply-chain-threats/","RawContent":null},{"Title":"Dark Mode Now Available on NuGet.org","PublishedOn":"2024-07-11T13:08:54+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"We won’t keep you “in the dark” about this any longer… Dark Mode for NuGet.org is finally here!   Your feedback has been invaluable in making this happen. We know that eye strain is a significant...","Href":"https://devblogs.microsoft.com/nuget/dark-mode-now-available-on-nuget-org/","RawContent":null},{"Title":"Announcing NuGet 6.10","PublishedOn":"2024-05-21T18:28:09+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"NuGet 6.10 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.10 for Windows, macOS, and Linux as a standalone executable. In NuGet 6.10, we introduce some...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-10/","RawContent":null},{"Title":"Announcing NuGet Commands in C# Dev Kit","PublishedOn":"2024-05-14T19:25:17+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"With the April release of C# Dev Kit, you can now manage your NuGet packages directly from Visual Studio Code using the new commands in the command palette. To add a NuGet package to your project, use...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/","RawContent":null},{"Title":"The NuGet.org repository signing certificate will be updated as soon as April 8th, 2024","PublishedOn":"2024-03-14T02:04:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Action required: If you validate that packages are repository signed by NuGet.org using a NuGet client policy, NuGet.exe verify command, or the dotnet nuget verify command, please follow these steps...","Href":"https://devblogs.microsoft.com/nuget/the-nuget-org-repository-signing-certificate-will-be-updated-as-soon-as-april-8th-2024/","RawContent":null},{"Title":"Refining Your Search: Introducing NuGet.org’s Compatible Framework Filters","PublishedOn":"2024-03-12T20:05:53+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Last year, we introduced search by target frameworks on NuGet.org, allowing you to filter your search results based on the framework(s) that a package targets. We received plenty of great feedback...","Href":"https://devblogs.microsoft.com/nuget/refining-your-search-introducing-nuget-orgs-compatible-framework-filters/","RawContent":null},{"Title":"Announcing NuGet 6.9","PublishedOn":"2024-02-14T00:33:14+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"NuGet 6.9 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.9 for Windows, macOS, and Linux as a standalone executable. In NuGet 6.9, we introduce some...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/","RawContent":null},{"Title":"Introducing NuGetSolver: A Powerful Tool for Resolving NuGet Dependency Conflicts in Visual Studio","PublishedOn":"2024-01-16T18:54:55+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"Managing dependencies on complex projects can be overwhelming. Developers often grapple with numerous direct and transitive dependencies across multiple projects. When different projects share...","Href":"https://devblogs.microsoft.com/nuget/introducing-nugetsolver-a-powerful-tool-for-resolving-nuget-dependency-conflicts-in-visual-studio/","RawContent":null}],"ResultType":"Feed"},"Gallery":{"Events":[{"Id":"43976437358","Type":"IssuesEvent","CreatedAt":"2024-11-19T14:33:55","Actor":"samtrion","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/10274","RelatedDescription":"Closed issue \"[NuGet.org Bug]: Api query does not return all results, compared to web search\" (#10274) at NuGet/NuGetGallery","RelatedBody":"### Impact\r\n\r\nIt bothers me. A fix would be nice\r\n\r\n### Describe the bug\r\n\r\nWhen I search for my Nuget packages via nuget.org, I currently get 40 packages as a result set. If I search via the api, with the same term, I always get one result less.\r\n\r\n- nuget.org: [www.nuget.org/packages?q=netevolve](https://www.nuget.org/packages?q=netevolve)\r\n- api: [api-v2v3search-0.nuget.org/query?q=netevolve](https://api-v2v3search-0.nuget.org/query?q=netevolve)\r\n\r\nIt is always the same package (https://www.nuget.org/packages/NetEvolve.Extensions.XUnit.V3), which is missing and I have not been able to identify the cause. I have also tried additional parameters such as for a pre-release, without success.\r\n\r\n### Repro Steps\r\n\r\nSee enclosed links\r\n\r\n### Expected Behavior\r\n\r\nThe same number of Nuget packages is listed for me.\r\n\r\n### Screenshots\r\n\r\n_No response_\r\n\r\n### Additional Context and logs\r\n\r\n_No response_"},{"Id":"43973732793","Type":"IssuesEvent","CreatedAt":"2024-11-19T13:26:53","Actor":"samtrion","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/10274","RelatedDescription":"Opened issue \"[NuGet.org Bug]: Api query does not return all results, compared to web search\" (#10274) at NuGet/NuGetGallery","RelatedBody":"### Impact\n\nIt bothers me. A fix would be nice\n\n### Describe the bug\n\nWhen I search for my Nuget packages via nuget.org, I currently get 40 packages as a result set. If I search via the api, with the same term, I always get one result less.\r\n\r\n- nuget.org: [www.nuget.org/packages?q=netevolve](https://www.nuget.org/packages?q=netevolve)\r\n- api: [api-v2v3search-0.nuget.org/query?q=netevolve](https://api-v2v3search-0.nuget.org/query?q=netevolve)\r\n\r\nIt is always the same package and I have not been able to identify the cause. I have also tried additional parameters such as for a pre-release, without success.\n\n### Repro Steps\n\nSee enclosed links\n\n### Expected Behavior\n\nThe same number of Nuget packages is listed for me.\n\n### Screenshots\n\n_No response_\n\n### Additional Context and logs\n\n_No response_"},{"Id":"43957807079","Type":"IssuesEvent","CreatedAt":"2024-11-19T05:39:26","Actor":"V-Manali","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/10273","RelatedDescription":"Opened issue \"[NuGet.org Bug]: Unable to edit API key\" (#10273) at NuGet/NuGetGallery","RelatedBody":"### Impact\n\nI'm unable to use NuGet.org\n\n### Describe the bug\n\nWhen tried to edit API key in NuGet.org, It throws errors \"An error occurred while editing an API key. Please try again.\"  \r\n![image](https://github.com/user-attachments/assets/592a2960-18be-4025-a937-4b4542740941)\r\n\n\n### Repro Steps\n\nSteps to reproduce the issue:\r\n1. Login to NuGet.org\r\n2. Go to profile\r\n3. Click on API keys\r\n4. try to edit the API keys which is already created\n\n### Expected Behavior\n\nShould be able to edit the API key.\n\n### Screenshots\n\n![image](https://github.com/user-attachments/assets/b71c4180-abe0-4cb3-9235-5fdbcf73b175)\r\n\n\n### Additional Context and logs\n\n_No response_"},{"Id":"43949480282","Type":"PullRequestEvent","CreatedAt":"2024-11-18T22:27:41","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10272","RelatedDescription":"Merged pull request \"Do not audit values for removed/revoked API keys\" (#10272) at NuGet/NuGetGallery","RelatedBody":"Today we audit the hashed API key value when a credential is deleted/revoked. This is not very useful (it is hashed) and it could trigger credential scanner in our audit logs at some point. I would like to remove it so our audit logs don't have this useless value.\r\n\r\nVaguely related to https://github.com/NuGet/NuGetGallery/issues/10212."}],"ResultType":"GitHubEvent"},"Home":{"Events":[{"Id":"43982895618","Type":"IssuesEvent","CreatedAt":"2024-11-19T17:08:59","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/13917","RelatedDescription":"Closed issue \"Sporadic Restore error: The process cannot access the file 'edpys1ay.f5i' because it is being used by another process. \" (#13917) at NuGet/Home","RelatedBody":"### NuGet Product Used\r\n\r\nMSBuild.exe\r\n\r\n### Product Version\r\n\r\nMSBuild Version 17.8.5+b5265ef37 / NuGet Client Version 6.8.1.2\r\n\r\n### Worked before?\r\n\r\ndon't know\r\n\r\n### Impact\r\n\r\nIt bothers me. A fix would be nice\r\n\r\n### Repro Steps & Context\r\n\r\nOn our build server we observe sporadically some file access issues (see exception below) during the NuGet restore task.\r\n\r\n**Context:**\r\n- \tOsName : Microsoft Windows Server 2025 Standard \r\n- \tOsVersion : 10.0.26304\r\n- \tMSBuild Version 17.8.5+b5265ef37\r\n- \tNuGet Client Version 6.8.1.2\r\n\r\n\r\nThe NuGet.targets(156,5) seems to point to the restore task.\r\n  <Target Name=\"Restore\" DependsOnTargets=\"_GenerateRestoreGraph\">\r\n\r\nThere seems to be a race condition in the PackageExtractor. The filename 'edpys1ay.f5i' suggests that it is about a temporary file (Path.GetRandomFileName()). \r\n\r\nMsBuild invokes NuGet restore with parallel threads. And since its running on a build server there are multiple MsBuild processes with restore running at the same time. A second build could also be in the middle of NuGet restore.\r\n\r\n**Further notes:**\r\n\r\nAfter the file access error happened other builds fail with NuGet package cache issues (see Follow up exception below). I think these type of exceptions are follow up errors from the first one.\r\n\r\nActually this corruption in the global package folder breaks many subsequent builds on that particular build server.\r\n\r\n\r\n### Verbose Logs\r\n\r\n```shell\r\nWhen running with MsBuild detailed log we get a callstack\r\n\r\n\tC:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\Common7\\IDE\\CommonExtensions\\Microsoft\\NuGet\\NuGet.targets(156,5): error : The process cannot access the file 'edpys1ay.f5i' because it is being used by another process. [...csproj]\r\n\t  System.IO.IOException: The process cannot access the file 'edpys1ay.f5i' because it is being used by another process.\r\n\t     at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)\r\n\t     at System.IO.FileInfo.Delete()\r\n\t     at NuGet.Packaging.PackageExtractor.<>c__DisplayClass5_0.<<InstallFromSourceAsync>b__0>d.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Common.ConcurrencyUtilities.<ExecuteWithFileLockedAsync>d__5`1.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n\t     at NuGet.Common.ConcurrencyUtilities.<ExecuteWithFileLockedAsync>d__5`1.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Packaging.PackageExtractor.<InstallFromSourceAsync>d__5.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Commands.ProjectRestoreCommand.<InstallPackageAsync>d__16.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Commands.ProjectRestoreCommand.<>c__DisplayClass15_1.<<InstallPackagesAsync>b__4>d.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Commands.ProjectRestoreCommand.<InstallPackagesAsync>d__15.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)\r\n\t     at NuGet.Commands.ProjectRestoreCommand.<TryRestoreAsync>d__9.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)\r\n\t     at NuGet.Commands.RestoreCommand.<ExecuteRestoreAsync>d__86.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)\r\n\t     at NuGet.Commands.RestoreCommand.<ExecuteAsync>d__68.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Commands.RestoreRunner.<ExecuteAsync>d__7.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Commands.RestoreRunner.<ExecuteAndCommitAsync>d__6.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Commands.RestoreRunner.<CompleteTaskAsync>d__9.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Commands.RestoreRunner.<RunAsync>d__2.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Commands.RestoreRunner.<RunAsync>d__0.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)\r\n\t     at NuGet.Build.Tasks.BuildTasksUtility.<RestoreAsync>d__12.MoveNext()\r\n\t  --- End of stack trace from previous location where exception was thrown ---\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n\t     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n\t     at NuGet.Build.Tasks.RestoreTask.<ExecuteAsync>d__47.MoveNext()\r\n\r\n\r\nFollow up exception (not the same build log). This comes from subsequent builds:\r\n\r\n\r\nC:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\Common7\\IDE\\CommonExtensions\\Microsoft\\NuGet\\NuGet.targets(156,5): error NU5037: The package is missing the required nuspec file. Path: C:\\Users\\<myuser>\\.nuget\\packages\\<myPackageName>\\<someversion> [<mycsproj>]\r\n  NuGet.Packaging.Core.PackagingException: The package is missing the required nuspec file. Path: C:\\Users\\<myuser>\\.nuget\\packages\\<myPackageName>\\<someversion>\r\n     at NuGet.Packaging.PackageFolderReader.GetNuspecFile()\r\n     at NuGet.Packaging.PackageReaderBase.GetNuspec()\r\n     at NuGet.Protocol.LocalPackageFileCache.GetNuspec(String manifestPath, String expandedPath)\r\n     at NuGet.Protocol.LocalPackageFileCache.<>c__DisplayClass7_1.<GetOrAddNuspec>b__1()\r\n     at System.Lazy`1.CreateValue()\r\n```\r\n"},{"Id":"43982202139","Type":"IssuesEvent","CreatedAt":"2024-11-19T16:50:17","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13943","RelatedDescription":"Opened issue \"New dependency resolver downloads more packages than before\" (#13943) at NuGet/Home","RelatedBody":"### NuGet Product(s) Affected\n\nNuGet.exe, Visual Studio Package Management UI, MSBuild.exe, dotnet.exe\n\n### Current Behavior\n\nAs an optimization, the new dependency resolver downloads packages in parallel.  However, when processing the direct package references, the dependencies are also downloaded when they weren't before.\r\n\r\nFor example:\r\n```\r\nProject -> A 1.0 -> B 1.0\r\nProject -> B 2.0\r\n```\r\n\r\nThe new resolver queues up a task to download `A 1.0` and `B 2.0`.  Then it processes `A 1.0` and queues up a download of `B 1.0`.  Then it processes `B 2.0` which ends up being the resolved version.  However, since `B 2.0` was directly referenced, NuGet does not need to technically download `B 1.0`. \n\n### Desired Behavior\n\nWe should process all of the direct dependencies first and then use background tasks to download children after that, ensuring that extra packages are not downloaded.\n\n### Additional Context\n\nSome users are hitting issues since their feeds don't offer up the packages.  So even though the resolved graph is identical, they experience restore failures."},{"Id":"43977162902","Type":"IssuesEvent","CreatedAt":"2024-11-19T14:49:09","Actor":"jbparker","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13942","RelatedDescription":"Opened issue \"MSB4018 - \"ResolvePackageDependencies\" task fails with \"Invalid framework version '2.0/win'\"\" (#13942) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nMSBuild.exe\n\n### Product Version\n\nMSBuild via VS 2022 17.12.0\n\n### Worked before?\n\nWorked in VS 2022 17.11.5\n\n### Impact\n\nIt's more difficult to complete my work\n\n### Repro Steps & Context\n\nThe error is being emitted for **PackageReference** projects with the following attributes:\r\n\r\n```xml\r\n<TargetFramework>netstandard2.0</TargetFramework>\r\n<RuntimeIdentifiers>win</RuntimeIdentifiers>\r\n```\r\n\r\nAssumedly, this is where the `2.0/win` comes from. There are many dozens of dependencies (package, product, etc), so determining how to singularly reproduce is exceedingly difficult.\r\n\r\nBuilding and running the project itself _does not seem to be impacted_, but the error displaying is causing much confusion with developers that have upgraded VS on our team.\r\n\r\nAdding `<NuGetAuditMode>direct</NuGetAuditMode>` to **Directory.Build.props** resolves the error based on the [auditing mode change made as part of .NET 9](https://learn.microsoft.com/en-us/nuget/concepts/auditing-packages#configuring-nuget-audit) removes the error from the **Error List**.\n\n### Verbose Logs\n\n```shell\nI can't get additional logs to show up in VS, but what shows in **Error List** is:\r\n\r\nSeverity: Error\r\nCode: MSB4018\r\nDescription: The \"ResolvePackageDependencies\" task failed unexpectedly.\r\nSystem.ArgumentException: Invalid framework version '2.0/win'.\r\n   at NuGet.Frameworks.NuGetFramework.ParseFrameworkNameParts(IFrameworkNameProvider mappings, String[] parts, String& framework, Version& version, String& profile)\r\n   at NuGet.Frameworks.NuGetFramework.ParseFrameworkName(String frameworkName, IFrameworkNameProvider mappings)\r\n   at Microsoft.NET.Build.Tasks.ResolvePackageDependencies.<GetPackageAndFileDefinitions>b__44_5(String tg)\r\n   at System.Linq.Enumerable.WhereSelectListIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.Contains[TSource](IEnumerable`1 source, TSource value, IEqualityComparer`1 comparer)\r\n   at System.Linq.Enumerable.WhereListIterator`1.MoveNext()\r\n   at System.Linq.Enumerable.Any[TSource](IEnumerable`1 source)\r\n   at Microsoft.NET.Build.Tasks.ResolvePackageDependencies.<GetPackageAndFileDefinitions>g__GetPackageDiagnosticLevel|44_0(LockFileLibrary package)\r\n   at Microsoft.NET.Build.Tasks.ResolvePackageDependencies.GetPackageAndFileDefinitions()\r\n   at Microsoft.NET.Build.Tasks.TaskBase.Execute()\r\n   at Microsoft.Build.BackEnd.TaskExecutionHost.Execute()\r\n   at Microsoft.Build.BackEnd.TaskBuilder.<ExecuteInstantiatedTask>d__26.MoveNext()\r\nFile: C:\\Program Files\\dotnet\\sdk\\9.0.100\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.PackageDependencyResolution.targets\r\nLine: 196\n```\n"},{"Id":"43960527998","Type":"IssuesEvent","CreatedAt":"2024-11-19T07:29:59","Actor":"Bouke","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13941","RelatedDescription":"Opened issue \"NU1004 after installing .NET 9 SDK\" (#13941) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\ndotnet.exe\n\n### Product Version\n\n9.0.100\n\n### Worked before?\n\n8.0.301\n\n### Impact\n\nIt's more difficult to complete my work\n\n### Repro Steps & Context\n\nWe're using [repeatable package restores](https://devblogs.microsoft.com/nuget/enable-repeatable-package-restores-using-a-lock-file/) in our .NET build pipeline. However as Azure DevOps windows-2022 version 20241113.3.0 started rolling out to agents, our build has been failing:\r\n\r\n> error NU1004: The project's runtime identifiers have changed from. Project's runtime identifiers: win-x86, lock file's runtime identifiers win7-x86.The packages lock file is inconsistent with the project dependencies so restore can't be run in locked mode. Disable the RestoreLockedMode MSBuild property or pass an explicit --force-evaluate option to run restore to update the lock file.\r\n\r\nWe're still targeting .NET 8, not .NET 9, so I don't understand why this is now failing. This is seemingly related to NuGet yet again changing identifiers between versions and the lockfiles not being compatible between SDKs?\r\n\r\nWe've since tried updating the lockfiles, which makes the build succeed when .NET 9 SDK is installed. However as some agents are still running 20241021.1.0, the updated lockfiles will fail on _those_. This is not a great situation to be in. Also updating the lockfiles requires all our developers to install .NET 9 SDK, which is something we would like to avoid.\n\n### Verbose Logs\n\n_No response_"},{"Id":"43954193295","Type":"IssuesEvent","CreatedAt":"2024-11-19T02:24:40","Actor":"gordon-matt","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13940","RelatedDescription":"Opened issue \"Improvements to the NuGet UI package selections in Visual Studio\" (#13940) at NuGet/Home","RelatedBody":"### NuGet Product(s) Affected\n\nVisual Studio Package Management UI\n\n### Current Behavior\n\nI just had to manually update dozens of NuGet packages (mostly the latest 8.*.* Microsoft packages) for dozens of projects in a single solution.. each package one-by-one.. VERY time consuming, and I reckon there are 2 things that can be improved to save time in these situations\n\n### Desired Behavior\n\n1. We didn't want to update to .NET 9 packages yet.. only the latest 8.*.* packages. There should be a way to filter packages by specified .NET target framework, so we can bulk update all packages to whatever we want. So in our case, we're targeting .NET 8, so all latest 8.*.* packages should show.. not any .NET 9 packages.\r\n\r\n2. When updating a NuGet package, the default checked projects should ONLY include those where the package is top-level, not transitive. We have almost 200 projects in the solution and it's annoying when updating a NuGet package auto selects all projects whether it's top-level or transitive. Maybe a dropdown to select \"all/none/top-level only\" would be good here? Otherwise just don't auto select the transitive ones, please. Unless maybe transitive is all there is for the selected package.\n\n### Additional Context\n\n_No response_"},{"Id":"43953014987","Type":"IssuesEvent","CreatedAt":"2024-11-19T01:20:07","Actor":"donnie-msft","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13939","RelatedDescription":"Opened issue \"Details Pane in Solution PM UI Project list calculates negative column widths\" (#13939) at NuGet/Home","RelatedBody":"The ListView for the projects table in Solution PMUI calculates column widths in order to make adjustments to each column. The [ListView_SizeChanged](https://github.com/NuGet/NuGet.Client/blob/47365347afc98bda37568e6441132122895b065c/src/NuGet.Clients/NuGet.PackageManagement.UI/Xamls/SolutionView.xaml.cs#L262) performs several calculations, and this can result in a negative value.\r\n\r\nRecently, a regression (https://github.com/NuGet/Home/issues/13928) was introduced in this area as Transitive Vulnerabilities were added as a column to this table. When the Details Pane is small, this logic would set a negative width on the column.\r\nTo mitigate this, a fix was made (in https://github.com/NuGet/NuGet.Client/pull/6146) to check for and only set a positive value for width.\r\n\r\nExample of a negative calculation from the debugger:\r\n![image](https://github.com/user-attachments/assets/3d7a4cf5-c704-4029-b8b5-2d2d9072dec5)\r\n\r\nThis logic seems overly complicated. Ideally:\r\n- Try to use WPF built-in settings to manage the column widths\r\n- If customization is needed, try refactoring the `ListView_SizeChanged` event to minimize the calculations it performs. Perhaps bailing out of the loop as soon as the `width` variable turns negative would optimize it slightly.\r\n- Re-evaluate the hard-coded values (project count `> 7` and `header.ActualWidth < 86` to ensure they're still correct and useful.\r\n\r\n"},{"Id":"43950279569","Type":"IssuesEvent","CreatedAt":"2024-11-18T22:59:46","Actor":"donnie-msft","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/13928","RelatedDescription":"Closed issue \"Small Solution PM UI size can cause a System.ArgumentException SolutionView.ListView_SizeChanged\" (#13928) at NuGet/Home","RelatedBody":"More details about the error\r\nhttps://devdiv.visualstudio.com/DevDiv/_workitems/edit/1253059?src=WorkItemMention&src-action=artifact_link"},{"Id":"43949930238","Type":"IssuesEvent","CreatedAt":"2024-11-18T22:44:26","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13938","RelatedDescription":"Opened issue \"New dependency resolver erroneously reports NU1605 (downgrade) when using transitive pinning a direct dependency and a downgrade exists in a package graph\" (#13938) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\ndotnet.exe, MSBuild.exe, NuGet.exe\n\n### Product Version\n\n6.12\n\n### Worked before?\n\nYes\n\n### Impact\n\nIt's more difficult to complete my work\n\n### Repro Steps & Context\n\nIf you have a package with a downgrade in its graph, you have a direct package reference, and you have transitive pinning enabled, the new dependency resolution algorithm does not properly treat it as \"pinned\" and instead logs a downgrade warning.  The legacy dependency resolution algorithm treats pinned dependencies as special, even if they are direct dependencies and will use higher versions, working around the downgrade.  This results in erroneous NU1605 warnings being logged when they weren't before.\n\n### Verbose Logs\n\n```shell\nNU1605: Warning As Error: Detected package downgrade: PackageC from 2.0.0 to 1.0.0. Reference the package directly from the project to select a different version.\r\n Project -> PackageA 1.0.0 -> PackageB 1.0.0 -> PackageC (>= 1.0.0)\r\n Project -> PackageA 1.0.0 -> PackageC (>= 2.0.0)\r\n```\n```\n"},{"Id":"43948769223","Type":"IssuesEvent","CreatedAt":"2024-11-18T21:59:54","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/13921","RelatedDescription":"Closed issue \"dotnet tool restore fails on Linux with System.ArgumentException: \"\" is invalid version string\" (#13921) at NuGet/Home","RelatedBody":"### NuGet Product Used\r\n\r\ndotnet.exe\r\n\r\n### Product Version\r\n\r\ndotnet 9.0.100\r\n\r\n### Worked before?\r\n\r\n8.x.y\r\n\r\n### Impact\r\n\r\nI'm unable to use this version\r\n\r\n### Repro Steps & Context\r\n\r\nAfter upgrade to .NET 9 the dotnet tool command fails on Linux but still works on Windows. \r\n\r\nHere is a minimal repro and the stacktrace\r\n\r\n[dotnet-tools.json](https://github.com/user-attachments/files/17731461/dotnet-tools.json)\r\n[global.json](https://github.com/user-attachments/files/17731466/global.json)\r\n\r\n```\r\n{\r\n  \"version\": 1,\r\n  \"isRoot\": true,\r\n  \"tools\": {\r\n    \"fantomas\": {\r\n      \"version\": \"6.2.3\",\r\n      \"commands\": [\r\n        \"fantomas\"\r\n      ],\r\n      \"rollForward\": false\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nerror:\r\n```\r\n\r\nUnhandled exception: System.ArgumentException: \"\" ist keine gültige Versionszeichenfolge.\r\n   at NuGet.Versioning.VersionRange.Parse(String value, Boolean allowFloating)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1 creator, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, Object existingValue, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1 creator, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, Object existingValue, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, Object target)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateObject(Object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, Object target)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateObject(Object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, Object existingValue, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, Object target)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateObject(Object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, String id)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.Deserialize(JsonReader reader, Type objectType, Boolean checkAdditionalContent)\r\n   at Newtonsoft.Json.JsonSerializer.DeserializeInternal(JsonReader reader, Type objectType)\r\n   at Newtonsoft.Json.JsonSerializer.Deserialize[T](JsonReader reader)\r\n   at NuGet.Protocol.PackageMetadataResourceV3.DeserializeStreamDataAsync[T](Stream stream, CancellationToken token)\r\n   at NuGet.Protocol.HttpSource.<>c__DisplayClass[15](https://gitlab/a-team/stream/-/jobs/1849400#L15)_0`1.<<GetAsync>b__0>d.MoveNext()\r\n--- End of stack trace from previous location ---\r\n   at NuGet.Common.ConcurrencyUtilities.ExecuteWithFileLockedAsync[T](String filePath, Func`2 action, CancellationToken token)\r\n   at NuGet.Common.ConcurrencyUtilities.ExecuteWithFileLockedAsync[T](String filePath, Func`2 action, CancellationToken token)\r\n   at NuGet.Protocol.HttpSource.GetAsync[T](HttpSourceCachedRequest request, Func`2 processAsync, ILogger log, CancellationToken token)\r\n   at NuGet.Protocol.PackageMetadataResourceV3.GetMetadataAsync(String packageId, Boolean includePrerelease, Boolean includeUnlisted, VersionRange range, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token)\r\n   at NuGet.Protocol.PackageMetadataResourceV3.GetMetadataAsync(String packageId, Boolean includePrerelease, Boolean includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token)\r\n   at Microsoft.DotNet.Cli.NuGetPackageDownloader.NuGetPackageDownloader.GetPackageMetadataAsync(PackageSource source, String packageIdentifier, Boolean includePrerelease, Boolean includeUnlisted, CancellationToken cancellationToken)\r\n   at Microsoft.DotNet.Cli.NuGetPackageDownloader.NuGetPackageDownloader.GetPackageMetadataAsync(String packageIdentifier, NuGetVersion packageVersion, IEnumerable`1 sources, CancellationToken cancellationToken, Boolean includeUnlisted)\r\n   at Microsoft.DotNet.Cli.NuGetPackageDownloader.NuGetPackageDownloader.GetPackageSourceAndVersion(PackageId packageId, NuGetVersion packageVersion, PackageSourceLocation packageSourceLocation, Boolean includePreview, Boolean includeUnlisted, PackageSourceMapping packageSourceMapping)\r\n   at Microsoft.DotNet.Cli.NuGetPackageDownloader.NuGetPackageDownloader.DownloadPackageAsync(PackageId packageId, NuGetVersion packageVersion, PackageSourceLocation packageSourceLocation, Boolean includePreview, Nullable`1 includeUnlisted, Nullable`1 downloadFolder, PackageSourceMapping packageSourceMapping)\r\n   at Microsoft.DotNet.Cli.ToolPackage.ToolPackageDownloader.DownloadAndExtractPackage(PackageId packageId, INuGetPackageDownloader nugetPackageDownloader, String packagesRootPath, NuGetVersion packageVersion, PackageSourceLocation packageSourceLocation, Boolean includeUnlisted)\r\n   at Microsoft.DotNet.Cli.ToolPackage.ToolPackageDownloader.<>c__DisplayClass8_0.<InstallPackage>b__0()\r\n   at Microsoft.DotNet.Cli.TransactionalAction.Run[T](Func`1 action, Action commit, Action rollback)\r\n   at Microsoft.DotNet.Tools.Tool.Restore.ToolRestoreCommand.InstallPackages(ToolManifestPackage package, Nullable`1 configFile)\r\n   at System.Linq.Enumerable.ArraySelectIterator`2.Fill(ReadOnlySpan`1 source, Span`1 destination, Func`2 func)\r\n   at System.Linq.Enumerable.ArraySelectIterator`2.ToArray()\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at Microsoft.DotNet.Tools.Tool.Restore.ToolRestoreCommand.Execute()\r\n   at System.CommandLine.Invocation.InvocationPipeline.Invoke(ParseResult parseResult)\r\n   at System.CommandLine.ParseResult.Invoke()\r\n   at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, TimeSpan startupTime, ITelemetry telemetryClient)\r\n```\r\n\r\n\r\n### Verbose Logs\r\n\r\n_No response_"},{"Id":"43948728415","Type":"IssuesEvent","CreatedAt":"2024-11-18T21:58:22","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/13918","RelatedDescription":"Closed issue \"[Feature Request] Disable caching for Local Feed\" (#13918) at NuGet/Home","RelatedBody":"### NuGet Product(s) Involved\r\n\r\nNuGet.exe, NuGet SDK\r\n\r\n### The Elevator Pitch\r\n\r\nI'm asking the same feature in #8251 , in light of new clearer reasons of which is the common scenario that the feature will resolve.\r\n\r\nFor local development purposes this feature is a must-have: I exhaustive described [here](https://github.com/NuGet/Home/issues/8251#issuecomment-2468435652) a common scenario, but - shortly - the idea is to give to developers the freedom to works on their local machines using [Local Feeds](https://learn.microsoft.com/en-us/nuget/hosting-packages/local-feeds) without facing cache issues.\r\n\r\nThis is especially needed when we work on 2 or more local projects, where one is a package project and the other is a project who consumes the package. When a developer make some changes on a package, before to push these changes he wants to test the changes using (in local) other project(s) which consumes the edited package. All of this happens in local and doesn't involve yet the CI/CD pipelines. This is a really common scenario in companies with large codebase and numerous package projects. \r\nNote that the purpose here is not to skip the CI/CD, but just speed-up the local development.\r\n\r\nSo the request is: _only and exclusively for packages on the local machine, that the cache should be disabled._\r\n\r\nIt could be by default or, as suggested [here](https://github.com/NuGet/Home/issues/8251#issuecomment-1260930006), with this configuration:\r\n```\r\nnuget.config\r\n\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<configuration>\r\n  <packageSources>\r\n     <add key=\"Local packages for Windows\" value=\"%userprofile%\\.nuget\\packages\\localPackages\"  disableCache=\"True\" />\r\n     <add key=\"Local packages for MacOS\" value=\"~/.nuget/packages/localPackages\"  disableCache=\"True\" />\r\n  </packageSources>\r\n</configuration>\r\n```\r\nOf course `disableCache=\"True\"`  should works only for local feeds.\r\n\r\nAnother solution it can be to operate on the <PackageReference> in the .csproj in this way:\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n         ...\r\n\t<ItemGroup>\r\n\t\t<PackageReference Include=\"MyPackage\" Version=\"8.0.0-Local\" disableCache=\"true\" />\r\n\t</ItemGroup>\r\n</Project>\r\n```\r\n\r\nAny other ideas on how to disable cache for packages on the local machine are welcome.\r\n\r\n### Additional Context and Details\r\n\r\nIn local I use to produce a package using this convention: MyPackage.x.y.z-Local ... now, we all knows that increment the version is really important when we are shipping the package, but in local it should not be a serious thing, because is just distracting and a waste of time and focus.\r\nBut using just the \"-Local\" suffix without increment the version means facing cache issues: this should due to _global packages folder_ that keep the old package (I don't think that _http-cache_ is involved).\r\n\r\nNote:\r\n- In NuGet there are already several ways to skip cache, but not via .config or .csproj\r\n- Being forced to continuously increment the version number on both the package project and the project that references it, when we are still working locally, is non-sense [IMHO].\r\n- Typically a pre-release version of a package is built via CI/CD related to a feature branch: but being forced to push changes to start this pipeline, only to debug and test locally something a developer isn't entirely sure about, is a waste of time, resources (pipeline agents), and an unnecessary mess of git history. And have to wait the pipeline execution just to take the new pre-release version that then will however tested in local by the other project... is a waste of time and focus.\r\n- Avoiding this cache problem with the use of CLI commands, custom Powershell scripts, Directory.Builds.props (which is my case), clean all the cache manually every time... all of this is a burden that the feature proposed resolves.\r\n- Note that substitute the `<PackageReference>` tag with the more directly `<Reference>` tag in the .csproj of the project who uses the package expose to easy mistakes and compromises other things. \r\n- A fallback Package Folders doesn't resolve the problem (as initially pointed out in the closed issue)."},{"Id":"43940355255","Type":"IssuesEvent","CreatedAt":"2024-11-18T17:24:53","Actor":"cataggar","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13937","RelatedDescription":"Opened issue \"dotnet restore erroring on NuGet.Config being used by another process\" (#13937) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\ndotnet.exe\n\n### Product Version\n\ndotnet sdk 9.0.100\n\n### Worked before?\n\ndotnet sdk 8.0.401\n\n### Impact\n\nI'm unable to use this version\n\n### Repro Steps & Context\n\nHere is the [internal pull request](https://dev.azure.com/msazure/One/_git/Azure-Dedicated-AVS/pullrequest/11281877) to reproduce. \r\n\r\nI am often getting this error even with `--disable-parallel`:\r\n\r\n~/ms/avs/src/conveyor/conveyor> dotnet build --disable-parallel\r\nC:\\Program Files\\dotnet\\sdk\\9.0.100\\NuGet.targets(751,5): error :\r\n  Unexpected failure reading NuGet.Config. Path: 'C:\\Users\\cataggar\\AppData\\Roaming\\NuGet\\NuGet.Config'.\r\n    The process cannot access the file 'C:\\Users\\cataggar\\AppData\\Roaming\\NuGet\\NuGet.Config' because it is being used by another process.\n\n### Verbose Logs\n\n_No response_"},{"Id":"43939185510","Type":"IssuesEvent","CreatedAt":"2024-11-18T16:49:15","Actor":"SetTrend","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13936","RelatedDescription":"Opened issue \"When targetting .NET 9 and .NET Framework 4.8.1, NuGet throws: NU5046: The icon file 'favicon256.png' does not exist in the package.\" (#13936) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nMSBuild.exe\n\n### Product Version\n\nNuGet Version: 6.11.0.119, MSBuild-Version 17.12.6+db5f6012c for .NET Framework, dotnet version 9.0.100\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nI'm unable to use this version\n\n### Repro Steps & Context\n\nThis is my project file:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <TargetFrameworks>net481;net9.0-windows</TargetFrameworks>\r\n    <LangVersion>13.0</LangVersion>\r\n    <Nullable>enable</Nullable>\r\n    <ImplicitUsings>disable</ImplicitUsings>\r\n    <UseWPF>true</UseWPF>\r\n    <ApplicationIcon>favicon.ico</ApplicationIcon>\r\n    <DebugType>embedded</DebugType>\r\n    <ProduceReferenceAssembly>False</ProduceReferenceAssembly>\r\n    <GenerateDocumentationFile>True</GenerateDocumentationFile>\r\n    <IsPublishable>False</IsPublishable>\r\n    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>\r\n    <Title>***</Title>\r\n    <Description>***</Description>\r\n    <Authors>***</Authors>\r\n    <Product>$(PackageId)</Product>\r\n    <Copyright>2024 – ***</Copyright>\r\n    <PackageIcon>favicon256.png</PackageIcon>\r\n    <PackageReadmeFile>ReadMe.md</PackageReadmeFile>\r\n    <PackageOutputPath>$(SolutionDir)\\NuGet Packages</PackageOutputPath>\r\n    <PackageTags>***</PackageTags>\r\n  </PropertyGroup>\r\n\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|AnyCPU'\">\r\n    <DebugType>none</DebugType>\r\n    <TreatWarningsAsErrors>True</TreatWarningsAsErrors>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <Content Include=\"favicon.ico\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup>\r\n    <None Update=\"favicon256.png\">\r\n      <Pack>True</Pack>\r\n      <PackagePath>\\</PackagePath>\r\n    </None>\r\n    <None Update=\"ReadMe.md\">\r\n      <Pack>True</Pack>\r\n      <PackagePath>\\</PackagePath>\r\n    </None>\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\nTargetting solely `net9.0-windows` is working flawlessly. But adding the `net481` target, NuGet fails.\n\n### Verbose Logs\n\n_No response_"},{"Id":"43932776093","Type":"IssuesEvent","CreatedAt":"2024-11-18T14:10:14","Actor":"maridematte","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13935","RelatedDescription":"Opened issue \"How to avoid package version dependency from project\" (#13935) at NuGet/Home","RelatedBody":"---\r\n**Issue moved from dotnet/msbuild#10941**\r\n- Please respond to @Ajith-GS.\r\n\r\n---\r\n\r\n_From @Ajith-GS on Thursday, November 7, 2024 10:21:32 AM_\r\n\r\n1.\t**Background**\nWe have a requirement to avoid package version dependency from a WinUI3 CppWinRT project. In CSharp projects NuGet package for multiple projects can be accessed from a single location using NuGet's central package management (CPM) features. But in CppWinRT project this is not working as expected because package.config file is version dependent.\n2.\t**Issue**\nIn WinUI3 CppWinRT application we can only update package versions manually using Manage NuGet Packages. In CppWinRT projects, using Central Package Management version dependencies in project file can be removed but version dependency from package.config cannot be removed.\n3.\t**Method** **tried**\n Using Central Package Management\n•\tPackage and its version information’s are present in project and package.config file. We tried Central Package Management to centrally manage package dependencies in project. Using Central Package Management version dependency from project file is removed but again issue occurred as version dependency from package.config cannot be removed.\n•\tInstead of removing versions from package.config we tried to copy updated packages.config to root folder in prebuild events but this also failed as NuGet restore operations occurs before prebuild events.\n4.\t**Query**\nIs there a method to make package.config version independent or update the versions in package.config automatically.\n\n5.\t**Testing Environment**\n•\tWindows OS version\t: 22H2\n•\tOS Build\t\t\t: 19045.5011\n•\tVisual Studio Version\t: VS 2022,17.4.4\n\nSample application is attached:\n[SampleApp.zip](https://github.com/user-attachments/files/17659889/SampleApp.zip)\n"},{"Id":"43930349393","Type":"IssuesEvent","CreatedAt":"2024-11-18T13:08:26","Actor":"mikejohnstonPremierinc","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13934","RelatedDescription":"Opened issue \"NuGet Restore restoring old versions of transitive dependencies when direct dependency does not have guidelines for user's targeted .NET Framework\" (#13934) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nNuGet.exe, Visual Studio Package Management UI, Visual Studio Package Manager Console\n\n### Product Version\n\nVisual Studio 17.12. NuGet.exe 16.12.1\n\n### Worked before?\n\nVisual Studio 17.11.6. NuGet.exe 16.11.1\n\n### Impact\n\nI'm unable to use this version\n\n### Repro Steps & Context\n\nThis issue occurs when building code/restoring packages within Visual Studio version 17.12 (Using the version of NuGet Package Manager that was packaged with Visual Studio 17.12).\r\n\r\nThe issue has also been reported when not using Visual Studio to restore packages, i.e. Using the NuGet command line tool (NuGet.exe), at version 6.12.1.\r\n\r\n**Use Case**  \r\nUser downloads a direct dependency from NuGet `noksa.webdriver.screenshotextensions 0.1.5.4`. This direct dependency’s .nuspec file shows a transitive dependency of `newtonsoft.json 11.0.1`, as seen in the screenshot below:\r\n\r\n![image](https://github.com/user-attachments/assets/6f42431a-f778-4b2c-a94f-7366a0dd0e95)\r\n\r\nSo, if you download `noksa.webdriver.screenshotextensions 0.1.5.4` to your PC, it will also download it’s transitive dependency `newtonsoft.json 11.0.1`\r\n\r\n`newtonsoft.json 11.0.1` has a security vulnerability, but `noksa.webdriver.screenshotextensions 0.1.5.4` does not have any security vulnerabilities.\r\n\r\nIf a user wants to download `noksa.webdriver.screenshotextensions 0.1.5.4` without introducing a security vulnerability, they should be able to do so, because the transitive dependency requirement is that `newtonsoft.json` has to be greater-than-or-equal-to 11.0.1, as seen in the screenshot below.\r\n\r\n![image](https://github.com/user-attachments/assets/dfe9ac03-16d1-4c72-93ab-f96bb9715539)\r\n\r\n**Visual Studio Version Below 17.12**  \r\nTo download `noksa.webdriver.screenshotextensions 0.1.5.4` with a non-vulnerable version of `newtonsoft.json`, the user can add the following text to the xml of the .csproj file.\r\n\r\n```  \r\n<PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\r\n```\r\n\r\nAdding the above xml within a Visual Studio version that is below 17.12 will result in NuGet downloading version 13.0.3 of `Newtonsoft.Json`. It will not download the vulnerable version 11.0.1. This results in `noksa.webdriver.screenshotextensions 0.1.5.4` using `Newtonsoft.Json 13.0.3` as it’s transitive dependency.\r\n\r\n**Visual Studio Version 17.12**  \r\nIncluding the above xml will result in NuGet downloading version 13.0.3, but it will ALSO result in NuGet downloading the vulnerable version 11.0.1.\r\n\r\n**.NET Framework Discrepancies**  \r\nAs you can see in the screenshot below showing the NuGet window, the .NET framework versions that are mentioned/referenced for `noksa.webdriver.screenshotextensions 0.1.5.4` are `. NETFramework 4.5.2` `. NETFramework4.6` and `. NETStandard2.0`. In the use case above, the user’s project is targeting `. NET8.0`. This may or may not be a reason why VS version 17.12 is respecting/not respecting the xml <packagereference> that was added into the .csproj file, because `noksa.webdriver.screenshotextensions 0.1.5.4` does not define which transitive dependency should be downloaded for `. NET8.0`\r\n\r\n![image](https://github.com/user-attachments/assets/2d0c1341-d475-4a85-b9e2-2698954cfc86)\r\n\r\n_**Workarounds**_  \r\nIf the user is using Visual Studio to build code and restore packages, the user can downgrade to Visual Studio 17.11.6.  \r\nIf the user is using Azure DevOps to build his code and restore packages (via the NuGetToolInstaller task), the user can target an older version of NuGet.exe, such as version 6.11.1:  \r\n`task: NuGetToolInstaller@1 inputs: versionSpec: 6.11.1`\n\n### Verbose Logs\n\n_No response_"},{"Id":"43901470486","Type":"IssuesEvent","CreatedAt":"2024-11-17T12:04:44","Actor":"microsoft-github-policy-service[bot]","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/13838","RelatedDescription":"Closed issue \"The HTTP request to 'GET https://api.nuget.org/v3/index.json' has timed out after 100000ms.\" (#13838) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\ndotnet.exe\n\n### Product Version\n\nLinux, Arch-based, x64, 8.0.108\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nI'm unable to use this version\n\n### Repro Steps & Context\n\ndotnet restore on any project, even one fresh from dotnet new\n\n### Verbose Logs\n\n```shell\nAssembly loaded during TaskRun (NuGet.Build.Tasks.RestoreTask): System.Runtime.Intrinsics, Version=8.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51 (location: /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.8/System.Runtime.Intrinsics.dll, MVID: 76c4fb63-66d1-4fbf-8aff-dd1c4a6bb94c, AppDomain: [Default]) (TaskId:36)\r\n03:33:03.804     1>/usr/share/dotnet/sdk/8.0.108/NuGet.targets(156,5): error : Unable to load the service index for source https://api.nuget.org/v3/index.json. [/home/kirki/Code/a/a.csproj]\r\n/usr/share/dotnet/sdk/8.0.108/NuGet.targets(156,5): error :   The HTTP request to 'GET https://api.nuget.org/v3/index.json' has timed out after 100000ms. [/home/kirki/Code/a/a.csproj]\r\n                     Assembly loaded during TaskRun (NuGet.Build.Tasks.RestoreTask): System.Diagnostics.StackTrace, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a (location: /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.8/System.Diagnostics.StackTrace.dll, MVID: aa9eb643-db2b-4c3a-8381-d02c8f479a8e, AppDomain: [Default]) (TaskId:36)\r\n                     NuGet.Protocol.Core.Types.FatalProtocolException: Unable to load the service index for source https://api.nuget.org/v3/index.json.\r\n                      ---> System.TimeoutException: The HTTP request to 'GET https://api.nuget.org/v3/index.json' has timed out after 100000ms.\r\n                        at NuGet.Protocol.TimeoutUtility.StartWithTimeout[T](Func`2 getTask, TimeSpan timeout, String timeoutMessage, CancellationToken token)\r\n                        at NuGet.Protocol.HttpRetryHandler.SendAsync(HttpRetryHandlerRequest request, String source, ILogger log, CancellationToken cancellationToken)\r\n                        at NuGet.Protocol.HttpSource.GetThrottledResponse(Func`1 requestFactory, TimeSpan requestTimeout, TimeSpan downloadTimeout, Int32 maxTries, Boolean isRetry, Boolean isLastAttempt, Guid sessionId, ILogger log, CancellationToken cancellationToken)\r\n                        at NuGet.Protocol.HttpSource.<>c__DisplayClass15_0`1.<<GetAsync>b__0>d.MoveNext()\r\n                     --- End of stack trace from previous location ---\r\n                        at NuGet.Common.ConcurrencyUtilities.ExecuteWithFileLockedAsync[T](String filePath, Func`2 action, CancellationToken token)\r\n                        at NuGet.Common.ConcurrencyUtilities.ExecuteWithFileLockedAsync[T](String filePath, Func`2 action, CancellationToken token)\r\n                        at NuGet.Protocol.HttpSource.GetAsync[T](HttpSourceCachedRequest request, Func`2 processAsync, ILogger log, CancellationToken token)\r\n                        at NuGet.Protocol.ServiceIndexResourceV3Provider.GetServiceIndexResourceV3(SourceRepository source, DateTime utcNow, ILogger log, CancellationToken token)\r\n                        --- End of inner exception stack trace ---\r\n                        at NuGet.Protocol.ServiceIndexResourceV3Provider.GetServiceIndexResourceV3(SourceRepository source, DateTime utcNow, ILogger log, CancellationToken token)\r\n                        at NuGet.Protocol.ServiceIndexResourceV3Provider.TryCreate(SourceRepository source, CancellationToken token)\r\n                        at NuGet.Protocol.Core.Types.SourceRepository.GetResourceAsync[T](CancellationToken token)\r\n                        at NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider.TryCreate(SourceRepository source, CancellationToken token)\r\n                        at NuGet.Protocol.Core.Types.SourceRepository.GetResourceAsync[T](CancellationToken token)\r\n                        at NuGet.Commands.VulnerabilityInformationProvider.GetVulnerabilityInfoAsync()\r\n                        at NuGet.Commands.VulnerabilityInformationProvider.GetVulnerabilityInformationAsync(CancellationToken cancellationToken)\r\n                        at NuGet.Commands.Restore.Utility.AuditUtility.GetAllVulnerabilityDataAsync(CancellationToken cancellationToken)\r\n                        at NuGet.Commands.Restore.Utility.AuditUtility.CheckPackageVulnerabilitiesAsync(CancellationToken cancellationToken)\r\n                        at NuGet.Commands.RestoreCommand.PerformAuditAsync(EnabledValue enableAudit, IEnumerable`1 graphs, TelemetryActivity telemetry, CancellationToken token)\r\n                        at NuGet.Commands.RestoreCommand.ExecuteAsync(CancellationToken token)\r\n                        at NuGet.Commands.RestoreRunner.ExecuteAsync(RestoreSummaryRequest summaryRequest, CancellationToken token)\r\n                        at NuGet.Commands.RestoreRunner.ExecuteAndCommitAsync(RestoreSummaryRequest summaryRequest, IRestoreProgressReporter progressReporter, CancellationToken token)\r\n                        at NuGet.Commands.RestoreRunner.CompleteTaskAsync(List`1 restoreTasks)\r\n                        at NuGet.Commands.RestoreRunner.RunAsync(IEnumerable`1 restoreRequests, RestoreArgs restoreArgs, CancellationToken token)\r\n                        at NuGet.Commands.RestoreRunner.RunAsync(RestoreArgs restoreContext, CancellationToken token)\r\n                        at NuGet.Build.Tasks.BuildTasksUtility.RestoreAsync(DependencyGraphSpec dependencyGraphSpec, Boolean interactive, Boolean recursive, Boolean noCache, Boolean ignoreFailedSources, Boolean disableParallel, Boolean force, Boolean forceEvaluate, Boolean hideWarningsAndErrors, Boolean restorePC, Boolean cleanupAssetsForUnsupportedProjects, ILogger log, CancellationToken cancellationToken)\r\n                        at NuGet.Build.Tasks.RestoreTask.ExecuteAsync(ILogger log) (TaskId:36)\r\n                   Done executing task \"RestoreTask\" -- FAILED. (TaskId:36)\r\n03:33:03.809     1>Done building target \"Restore\" in project \"a.csproj\" -- FAILED.: (TargetId:42)\r\n03:33:03.810     1>Done Building Project \"/home/kirki/Code/a/a.csproj\" (Restore target(s)) -- FAILED.\r\nDeferred Messages\r\n03:33:03.810     0>\r\nDetailed Build Summary\r\n======================\r\n     (TaskId:0)\r\n                     \r\n                     ============================== Build Hierarchy (IDs represent configurations) =====================================================\r\n                     Id                  : Exclusive Time   Total Time   Path (Targets)\r\n                     ----------------------------------------------------------------------------------------------------------------------------------- (TaskId:0)\r\n                     0                   : 605.957s           606.033s       /home/kirki/Code/a/a.csproj (Restore)  (TaskId:0)\r\n                     | 1                 : 0.011s           0.011s       /home/kirki/Code/a/a.csproj (_IsProjectRestoreSupported)  (TaskId:0)\r\n                     | 2                 : 0.002s           0.002s       /home/kirki/Code/a/a.csproj (_GenerateRestoreProjectPathWalk)  (TaskId:0)\r\n                     | 3                 : 0.058s           0.058s       /home/kirki/Code/a/a.csproj (_GenerateRestoreGraphProjectEntry)  (TaskId:0)\r\n                     . 4                 : 0.004s           0.004s       /home/kirki/Code/a/a.csproj (_GenerateProjectRestoreGraph)  (TaskId:0)\r\n                     \r\n                     ============================== Node Utilization (IDs represent configurations) ====================================================\r\n                     Timestamp:            1        Duration   Cumulative\r\n                     ----------------------------------------------------------------------------------------------------------------------------------- (TaskId:0)\r\n                     638637817777761148:   0        0.216s     0.216s .... (TaskId:0)\r\n                     638637817779925252:   1        0.011s     0.228s  (TaskId:0)\r\n                     638637817780039260:   0        0.011s     0.238s  (TaskId:0)\r\n                     638637817780145178:   2        0.002s     0.241s  (TaskId:0)\r\n                     638637817780167035:   0        0.002s     0.242s  (TaskId:0)\r\n                     638637817780185073:   3        0.058s     0.301s . (TaskId:0)\r\n                     638637817780767182:   0        0.002s     0.302s  (TaskId:0)\r\n                     638637817780783608:   4        0.004s     0.307s  (TaskId:0)\r\n                     638637817780827136:   0        605.728s     606.035s ############ (scale 1:1000) (TaskId:0)\r\n                     -----------------------------------------------------------------------------------------------------------------------------------\r\n                     Utilization:          100.0    Average Utilization: 100.0 (TaskId:0)\r\n\r\nProject Evaluation Performance Summary:\r\n      177 ms  /home/kirki/Code/a/a.csproj                2 calls\r\n\r\nProject Performance Summary:\r\n    605914 ms  /home/kirki/Code/a/a.csproj                6 calls\r\n              605850 ms  Restore                                    1 calls\r\n                  0 ms  _IsProjectRestoreSupported                 2 calls\r\n                  2 ms  _GenerateRestoreProjectPathWalk            1 calls\r\n                 58 ms  _GenerateRestoreGraphProjectEntry          1 calls\r\n                  4 ms  _GenerateProjectRestoreGraph               1 calls\r\n\r\nTarget Performance Summary:\r\n        0 ms  _GenerateProjectRestoreGraph               1 calls\r\n        0 ms  _GenerateRestoreDependencies               1 calls\r\n        0 ms  _GetRestoreSettingsCurrentProject          1 calls\r\n        0 ms  _GenerateRestoreGraphProjectEntry          1 calls\r\n        0 ms  _GenerateProjectRestoreGraphCurrentProject   1 calls\r\n        0 ms  _GenerateRestoreProjectPathItemsCurrentProject   1 calls\r\n        0 ms  _CheckForObsoleteDotNetCliToolReferences   1 calls\r\n        0 ms  _GetRestoreSettingsPerFramework            1 calls\r\n        0 ms  _GetProjectJsonPath                        1 calls\r\n        0 ms  _CheckForLanguageAndFeatureCombinationSupport   1 calls\r\n        0 ms  _GetRestoreTargetFrameworkOverride         1 calls\r\n        0 ms  _GetRestoreSettingsOverrides               1 calls\r\n        0 ms  _CheckForUnsupportedCppNETCoreVersion      2 calls\r\n        0 ms  _AddMicrosoftNetCompilerToolsetFrameworkPackage   1 calls\r\n        0 ms  _IsProjectRestoreSupported                 1 calls\r\n        0 ms  CollectFrameworkReferences                 1 calls\r\n        0 ms  _CheckForUnsupportedNETCoreVersion         2 calls\r\n        0 ms  _GenerateRestoreProjectPathItems           1 calls\r\n        0 ms  _GenerateRestoreSpecs                      1 calls\r\n        0 ms  _GenerateRestoreProjectSpec                1 calls\r\n        0 ms  _GenerateRestoreProjectPathItemsPerFramework   1 calls\r\n        0 ms  CollectPackageReferences                   1 calls\r\n        1 ms  _GenerateDotnetCliToolReferenceSpecs       1 calls\r\n        1 ms  _CollectTargetFrameworkForTelemetry        1 calls\r\n        1 ms  CollectCentralPackageVersions              1 calls\r\n        1 ms  CollectPackageDownloads                    1 calls\r\n        1 ms  _GenerateRestoreProjectPathWalk            1 calls\r\n        1 ms  _GenerateProjectRestoreGraphPerFramework   1 calls\r\n        1 ms  _GetRestoreTargetFrameworksOutput          1 calls\r\n        1 ms  _GetRestoreProjectStyle                    1 calls\r\n        2 ms  CheckForImplicitPackageReferenceOverrides   1 calls\r\n        2 ms  _ComputeToolPackInputsToProcessFrameworkReferences   1 calls\r\n        4 ms  _LoadRestoreGraphEntryPoints               1 calls\r\n        5 ms  _GetAllRestoreProjectPathItems             1 calls\r\n       21 ms  _GetRestoreSettings                        1 calls\r\n       29 ms  ProcessFrameworkReferences                 1 calls\r\n       45 ms  _FilterRestoreGraphProjectInputItems       1 calls\r\n       65 ms  _GenerateRestoreGraph                      1 calls\r\n    605726 ms  Restore                                    1 calls\r\n\r\nTask Performance Summary:\r\n        0 ms  GetRestorePackageReferencesTask            1 calls\r\n        0 ms  GetRestoreFrameworkReferencesTask          1 calls\r\n        0 ms  GetRestoreProjectReferencesTask            1 calls\r\n        0 ms  CheckForDuplicateFrameworkReferences       1 calls\r\n        0 ms  GetRestorePackageDownloadsTask             1 calls\r\n        0 ms  AllowEmptyTelemetry                        1 calls\r\n        0 ms  GetRestoreDotnetCliToolsTask               1 calls\r\n        0 ms  ConvertToAbsolutePath                      2 calls\r\n        0 ms  NuGetMessageTask                           1 calls\r\n        0 ms  CheckForImplicitPackageReferenceOverrides   1 calls\r\n        1 ms  Message                                    3 calls\r\n        1 ms  GetProjectTargetFrameworksTask             1 calls\r\n        1 ms  GetRestoreProjectStyleTask                 1 calls\r\n        1 ms  CheckForDuplicateNuGetItemsTask            3 calls\r\n        2 ms  RemoveDuplicates                           5 calls\r\n        3 ms  WarnForInvalidProjectsTask                 1 calls\r\n        5 ms  ResolveAppHosts                            1 calls\r\n       21 ms  GetRestoreSettingsTask                     1 calls\r\n       23 ms  ProcessFrameworkReferences                 1 calls\r\n       89 ms  MSBuild                                    6 calls\r\n    605725 ms  RestoreTask                                1 calls\r\n\r\nBuild FAILED.\r\n\r\n                   \"/home/kirki/Code/a/a.csproj\" (Restore target) (1) ->\r\n                   (Restore target) -> \r\n                     /usr/share/dotnet/sdk/8.0.108/NuGet.targets(156,5): error : Unable to load the service index for source https://api.nuget.org/v3/index.json. [/home/kirki/Code/a/a.csproj]\r\n                   /usr/share/dotnet/sdk/8.0.108/NuGet.targets(156,5): error :   The HTTP request to 'GET https://api.nuget.org/v3/index.json' has timed out after 100000ms. [/home/kirki/Code/a/a.csproj]\n```\n"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"41298441972","Type":"IssuesEvent","CreatedAt":"2024-08-23T22:18:02","Actor":"zhhyu","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Announcements/issues/73","RelatedDescription":"Closed issue \"Scream Test Impacting Alpine Linux Customers on 08/20/2024\" (#73) at NuGet/Announcements","RelatedBody":"On **August 20, 2024**, NuGet.org will conduct a **scream test** that may affect **Alpine Linux** customers. The test is scheduled to begin at **EDT 01:00 PM** and is expected to last between **24 to 72 hours**. We will adjust the test duration based on customer feedback.\r\n\r\nDuring the scream test, **Alpine Linux** customers may encounter **DNS failures** from the [V3 API](https://learn.microsoft.com/nuget/nuget-org/overview-nuget-org#api-endpoint-for-nugetorg) due to this [issue](https://github.com/NuGet/NuGetGallery/issues/9736). To mitigate, we recommend that Alpine Linux customers migrate to **Alpine Linux 3.18.0** or a newer version. These newer versions support **TCP fallback** in the DNS resolver.\r\n\r\nTo ensure uninterrupted service during the test, please use the [V2 API](https://learn.microsoft.com/nuget/nuget-org/overview-nuget-org#api-endpoint-for-nugetorg) instead.\r\n\r\nIf you have any **feedback**, **concerns**, or **questions**, feel free to reach out to us at support@nuget.org or by commenting on the discussion issue: [NuGet/Home#12985](https://github.com/NuGet/Home/discussions/12985)."},{"Id":"41149312432","Type":"IssuesEvent","CreatedAt":"2024-08-19T18:48:41","Actor":"zhhyu","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/73","RelatedDescription":"Opened issue \"Scream Test Impacting Alpine Linux Customers on 08/20/2024\" (#73) at NuGet/Announcements","RelatedBody":"On **August 20, 2024**, NuGet.org will conduct a **scream test** that may affect **Alpine Linux** customers. The test is scheduled to begin at **EDT 01:00 PM** and is expected to last between **24 to 72 hours**. We will adjust the test duration based on customer feedback.\r\n\r\nDuring the scream test, **Alpine Linux** customers may encounter **DNS failures** from the [V3 API](https://learn.microsoft.com/nuget/nuget-org/overview-nuget-org#api-endpoint-for-nugetorg) due to this [issue](https://github.com/NuGet/NuGetGallery/issues/9736). To mitigate, we recommend that Alpine Linux customers migrate to **Alpine Linux 3.18.0** or a newer version. These newer versions support **TCP fallback** in the DNS resolver.\r\n\r\nTo ensure uninterrupted service during the test, please use the [V2 API](https://learn.microsoft.com/nuget/nuget-org/overview-nuget-org#api-endpoint-for-nugetorg) instead.\r\n\r\nIf you have any **feedback**, **concerns**, or **questions**, feel free to reach out to us at support@nuget.org or by commenting on the discussion issue: [NuGet/Home#12985](https://github.com/NuGet/Home/discussions/12985)."}],"ResultType":"GitHubEvent"}},"RunOn":"2024-11-20T03:30:19.8636712Z","RunDurationInMilliseconds":929}