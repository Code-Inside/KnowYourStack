{"Data":{"Blog":{"FeedItems":[{"Title":"HTTPS Everywhere Update","PublishedOn":"2023-09-19T15:52:06+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"Mistakes were made\nWhen we first published the plan for the effort of HTTPS everywhere, we wanted to get developer community feedback on the various HTTP and HTTPS scenarios that we don&#8217;t have...","Href":"https://devblogs.microsoft.com/nuget/https-everywhere-update/","RawContent":null},{"Title":"Announcing NuGet 6.7 – Keeping You Secure","PublishedOn":"2023-08-10T15:27:01+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"NuGet 6.7 is included in Visual Studio 2022 and .NET 7.0 out of the box. You can also download NuGet 6.7 for Windows, macOS, and Linux as a standalone executable.\nSecurity is a chain; it&#8217;s only...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-7-keeping-you-secure/","RawContent":null},{"Title":"The Microsoft author-signing certificate will be updated as soon as August 14th, 2023","PublishedOn":"2023-08-03T18:38:24+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Action required: If you validate that packages are author-signed by Microsoft using a NuGet client policy or the NuGet.exe verify command, please follow these steps by August 14th, 2023 to avoid...","Href":"https://devblogs.microsoft.com/nuget/microsoft-author-signing-certificate-update-2023/","RawContent":null},{"Title":"NuGet.org Terms of Service Update on Unexpected Behavior and Hate Speech","PublishedOn":"2023-04-13T17:20:42+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"In recent years, the .NET open source community and NuGet package registry have become increasingly important for sharing code. However, with the growth of these platforms, there has also been a rise...","Href":"https://devblogs.microsoft.com/nuget/nuget-org-terms-of-service-update-on-unexpected-behavior-and-hate-speech/","RawContent":null},{"Title":"Write a high-quality README for NuGet packages","PublishedOn":"2023-03-02T19:07:53+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"Based on our recent customer interviews and surveys, one of the top problems that package consumers face is insufficient package documentation, such as README, changelog, examples, and API reference....","Href":"https://devblogs.microsoft.com/nuget/write-a-high-quality-readme-for-nuget-packages/","RawContent":null},{"Title":"Announcing NuGet 6.5 – The Sweetest Way to Manage Your Packages","PublishedOn":"2023-02-28T16:29:59+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"NuGet 6.5 is included in Visual Studio 2022 and .NET 7.0 out of the box. You can also download NuGet 6.5 for Windows, macOS, and Linux as a standalone executable.\nTired of the sour taste of managing...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-5-the-sweetest-way-to-manage-your-packages/","RawContent":null},{"Title":"Introducing Search By Target Framework on NuGet.org","PublishedOn":"2023-02-14T21:43:08+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"Last year, we brought a new feature to improve the way you assess target framework compatibility of a NuGet package through a new &#8220;Frameworks&#8221; tab.\nToday, we are announcing a new feature...","Href":"https://devblogs.microsoft.com/nuget/introducing-search-by-target-framework-on-nuget-org/","RawContent":null},{"Title":"Announcing NuGet 6.4 – Signed, Central, Delivered","PublishedOn":"2022-11-08T20:59:34+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"NuGet 6.4 is included in Visual Studio 2022 and .NET 7.0 out of the box. You can also download NuGet 6.4 for Windows, macOS, and Linux as a standalone executable.\nNuGet 6.4 is one of many releases in...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-4-signed-central-delivered/","RawContent":null},{"Title":"NuGet Season of Giving","PublishedOn":"2022-09-30T18:01:24+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"NuGet has gone through a lot of changes over the last 10 years. From the package manager console, standalone NuGet.exe, and integration of NuGet into the .NET SDK, we have always relied on the open...","Href":"https://devblogs.microsoft.com/nuget/nuget-season-of-giving/","RawContent":null},{"Title":"Announcing NuGet 6.3 – Transitive Dependencies, Floating Versions, and Re-enabling Signed Package Verification","PublishedOn":"2022-08-09T20:04:03+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"NuGet 6.3 is included in Visual Studio 2022 and .NET 6.0 out of the box. You can also download NuGet 6.3 for Windows, macOS, and Linux as a standalone executable.\nNuGet 6.3 is one of many releases in...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-3-transitive-dependencies-floating-versions-and-re-enabling-signed-package-verification/","RawContent":null}],"ResultType":"Feed"},"Gallery":{"Events":[{"Id":"32032120294","Type":"PullRequestEvent","CreatedAt":"2023-09-22T13:02:39","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/9669","RelatedDescription":"Merged pull request \"Move to latest ServerCommon for new Service Bus SDK\" (#9669) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/Engineering/issues/5011\r\n\r\nSummary of changes:\r\n- Update to new ServerCommon version (depends on https://github.com/NuGet/ServerCommon/pull/412)\r\n- Pull in new Azure Service Bus SDK (Azure.Messaging.ServiceBus) as part of ServerCommon and associated API changes\r\n- Add global.json to eliminate Roslyn analyzer warnings about ambient .NET SDK 7 or 8.\r\n  - This was making it hard for me to assess that I wasn't introducing more warnings.\r\n- Introduce `ServiceBusConfiguration.ManagedIdentityClientId` to pass user-assignment managed identity client ID in\r\n   - We used to do this with an environment variable, not it's explicit\r\n- Update web.config since NuGetGallery binding redirects changed a lot with this update\r\n\r\nNote that the `Close` of the Service Bus sender is no longer sync. It's `CloseAsync`. This means it leaves an un-awaited Task. This is acceptable because the instance is a singleton in the DI container meaning this will only happen when the process is shutting down (graceful app service shutdown) when associated handled will be released anyway."},{"Id":"32020439691","Type":"IssuesEvent","CreatedAt":"2023-09-22T03:45:43","Actor":"descona","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/9670","RelatedDescription":"Opened issue \"[NuGet.org Bug]: License files still exist when the package is hidden\" (#9670) at NuGet/NuGetGallery","RelatedBody":"### Impact\n\nOther\n\n### Describe the bug\n\nWhen the package is hidden, the License file is still available to the public. This issue should be fixed.\r\nAs the spammers are making use of this issue to promote their spam links via nuget package.\r\nThere are lots of spammed License files in nuget. such as (https://www.nuget.org/packages/FREE-CASH-APP-MONEY-GENERATOR-CODES-UPDATED-2023/2.1.0/License)\r\nYou will find more by using google search.\r\n\n\n### Repro Steps\n\nYou will find more spammed license files using this search in google\r\nsite:nuget.org free\n\n### Expected Behavior\n\nWhen the spam package is hidden or deleted, the License file should be deleted or hidden too.\n\n### Screenshots\n\n_No response_\n\n### Additional Context and logs\n\n_No response_"},{"Id":"31985154906","Type":"PullRequestEvent","CreatedAt":"2023-09-20T22:18:38","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/9669","RelatedDescription":"Opened pull request \"Move to latest ServerCommon for new Service Bus SDK\" (#9669) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/Engineering/issues/5011\r\n\r\nSummary of changes:\r\n- Update to new ServerCommon version (depends on https://github.com/NuGet/ServerCommon/pull/412)\r\n- Pull in new Azure Service Bus SDK (Azure.Messaging.ServiceBus) as part of ServerCommon and associated API changes\r\n- Add global.json to eliminate Roslyn analyzer warnings about ambient .NET SDK 7 or 8.\r\n  - This was making it hard for me to assess that I wasn't introducing more warnings.\r\n- Introduce `ServiceBusConfiguration.ManagedIdentityClientId` to pass user-assignment managed identity client ID in\r\n   - We used to do this with an environment variable, not it's explicit\r\n- Update web.config since NuGetGallery binding redirects changed a lot with this update\r\n\r\nNote that the `Close` of the Service Bus sender is no longer sync. It's `CloseAsync`. This means it leaves an un-awaited Task. This is acceptable because the instance is a singleton in the DI container meaning this will only happen when the process is shutting down (graceful app service shutdown) when associated handled will be released anyway."}],"ResultType":"GitHubEvent"},"Home":{"Events":[{"Id":"32058861285","Type":"IssuesEvent","CreatedAt":"2023-09-24T12:23:38","Actor":"LostTime76","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/12902","RelatedDescription":"Opened issue \"[Question | Bug?] Restore fails to GeneratePathProperty or copy content to output directory if obj folder is missing\" (#12902) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\ndotnet.exe, MSBuild.exe\n\n### Product Version\n\ndotnet 8.1 RC\n\n### Worked before?\n\nNever tried\n\n### Impact\n\nIt bothers me. A fix would be nice\n\n### Repro Steps & Context\n\nMy project uses the dotnet CLI directly instead of using a standard C# project structure with the root project having a solution. Instead I have a parent msbuild project file that invokes child msbuild projects. Some of those child projects are C# projects and some are just generic build files not attached to a standard msbuild project type like C#. I happen to be using VSCode for development to invoke the command line.\r\n\r\nSuffice it to say, the child C# projects are not committed to source control with their obj or bin folders and they contain package references. When somebody checks out the project, the intent is for the build to restore everything including the package references.\r\n\r\nThe C# project files are setup to perform a pre build nuget restore, which ends up generating the obj folder and the nuget packages are successfully restored globally. The issue I am having is that if the obj and bin folders are missing the first time a user does a build (or the user does a clean, because I have the clean target delete obj & bin), then the nuget restore only restores the packages and the obj folder for the project. If the package contains content that needs to be copied to the output directory on package restore, nuget does not perform the copy. If a second build if performed with the obj folder present from the previous restore, the package content is copied successfully to the output folder. This behavior seems to be the same for the GeneratePathProperty. The package reference path is only generated if the obj folder is already present on restore.\r\n\r\nAfter some testing and digging, it just seems like nuget needs to take the extra step of completing its work if the obj folder is absent. If the obj folder is absent and a restore is performed, it is generating the obj folder, restoring the packages to the global .nuget folder but is stopping there. It should lastly perform the content copy. I think the .g.props file that is generated within the obj folder is controlling that content copy as it contains all the paths to the content to copy, it's just not being invoked when nuget has to firstly generate the file.\r\n\r\nWhen the automatic copy on fresh restore failed, I tried using the GeneratePathProperty to manually execute an msbuild copy task to copy what I needed.. only to find out that it seems like the property is not generated unless obj (an .g.props) exists first. I need a way for the restore to work fully if the obj folder is absent on a fresh restore. If this comes from the built in copy or from me manually writing a copy task using GeneratePathProperty, it doesn't matter, I just need one or both to work.\r\n\r\nThe overall issue is that it is a bad omen to tell users of my project that they need to restore / build the project twice whenever they firstly clone the project or do a full clean. I think this has been mentioned elsewhere in the forum, but nuget restore should work fully from a fresh restore (no obj or bin folders). Saying that the built in msbuild clean target never touches the obj folder or the obj folder is restored by VSCode / Visual Studio with \"normal\" solution project structures, is not very valid.\r\n\r\n\n\n### Verbose Logs\n\n_No response_"},{"Id":"32046422156","Type":"IssuesEvent","CreatedAt":"2023-09-23T03:33:08","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/12901","RelatedDescription":"Closed issue \"Ambiguous project name when using PackageID parameter\" (#12901) at NuGet/Home","RelatedBody":"### NuGet Product Used\r\n\r\ndotnet.exe\r\n\r\n### Product Version\r\n\r\n.NET SDK:  Version:   7.0.200\r\n\r\n### Worked before?\r\n\r\n_No response_\r\n\r\n### Impact\r\n\r\nIt's more difficult to complete my work\r\n\r\n### Repro Steps & Context\r\n\r\n[example.zip](https://github.com/NuGet/Home/files/12702218/example.zip)\r\n\r\nIn the zip file is a solution with 2 projects\r\n\r\n`ProjectC`, which has a ProjectReference to `ProjectD`\r\n\r\nNeither projects have `PackageID` defined in their `.csproj` files\r\n\r\nWhen running the command `dotnet pack .\\src\\ProjectC\\ProjectC.csproj -p:PackageID=Example`\r\n\r\nThe following error is shown `error : Ambiguous project name 'Example'.`\r\n\r\nRunning the same command without `-p:PackageID=Example` works ok\r\n\r\nRemoving the reference to `ProjectD` also fixes it, but I don't see anything in `ProjectD` which would cause an ambiguous reference.\r\n\r\n\r\n### Verbose Logs\r\n\r\n[log.txt](https://github.com/NuGet/Home/files/12702289/log.txt)\r\n"},{"Id":"32046401429","Type":"IssuesEvent","CreatedAt":"2023-09-23T03:29:28","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/12895","RelatedDescription":"Closed issue \"RestoreUseStaticGraphEvaluation=true causes error NU1100\" (#12895) at NuGet/Home","RelatedBody":"### NuGet Product Used\r\n\r\ndotnet.exe\r\n\r\n### Product Version\r\n\r\n.NET STDK 7.0.101, Nuget 6.7.0\r\n\r\n### Worked before?\r\n\r\n_No response_\r\n\r\n### Impact\r\n\r\nNone\r\n\r\n### Repro Steps & Context\r\n\r\nIn `Directory.Build.props` we wanted to enable static graph `MSBuild` evaluation:\r\n```xml\r\n<Project>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Foo.Bar.Sdk\" ExcludeAssets=\"runtime\" />\r\n  </ItemGroup>\r\n  <PropertyGroup>\r\n    <RestoreUseStaticGraphEvaluation>true</RestoreUseStaticGraphEvaluation>\r\n  </PropertyGroup>\r\n</Project>\r\n```\r\n\r\nOur pipeline in `Azure DevOps` then failed, unable to restore our globally referenced package (above):\r\n>error NU1100: Unable to resolve 'Foo.Bar.Sdk (>= 1.2.3)' for 'net6.0/win-x64'\r\n\r\nThis is the relevant part of `pipeline.yml`:\r\n```yml\r\n- task: NuGetToolInstaller@1\r\n  displayName: 'Use NuGet 6.7.0'\r\n  inputs:\r\n    versionSpec: 6.7.0\r\n\r\n- task: DotNetCoreCLI@2\r\n  displayName: 'dotnet restore'\r\n  inputs:\r\n    command: 'restore'\r\n    projects: 'src/**/*.csproj'\r\n    feedsToUse: config\r\n    nugetConfigPath: 'src/NuGet.Config'\r\n    restoreArguments: '-r win-x64'\r\n```\r\n\r\nOur pipeline works when we don't set `RestoreUseStaticGraphEvaluation`, so it seems there is an issue with this specific setting.\r\n\r\nAlso not sure if this error comes from `dotnet.exe` or that `DotNetCoreCLI@2` task...\r\n\r\n### Update\r\nIt should be noted that we have these settings enabled:\r\n```\r\n<ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>\r\n<CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>\r\n```\r\n\r\n### Verbose Logs\r\n\r\n```shell\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at System.Collections.Generic.Dictionary`2.get_Item(TKey key) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.LockFileBuilder.GetLibraryDependenciesForCentralTransitiveDependencies(RestoreTargetGraph targetGraph, TargetFrameworkInformation targetFrameworkInformation, Boolean centralPackageTransitivePinningEnabled)+MoveNext() [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.LockFileBuilder.AddCentralTransitiveDependencyGroupsForPackageReference(PackageSpec project, LockFile lockFile, IEnumerable`1 targetGraphs) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.LockFileBuilder.CreateLockFile(LockFile previousLockFile, PackageSpec project, IEnumerable`1 targetGraphs, IReadOnlyList`1 localRepositories, RemoteWalkContext context, LockFileBuilderCache lockFileBuilderCache) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.RestoreCommand.BuildAssetsFile(LockFile existingLockFile, PackageSpec project, IEnumerable`1 graphs, IReadOnlyList`1 localRepositories, RemoteWalkContext contextForProject) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.RestoreCommand.ExecuteAsync(CancellationToken token) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.RestoreRunner.ExecuteAsync(RestoreSummaryRequest summaryRequest, CancellationToken token) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.RestoreRunner.ExecuteAndCommitAsync(RestoreSummaryRequest summaryRequest, IRestoreProgressReporter progressReporter, CancellationToken token) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.RestoreRunner.CompleteTaskAsync(List`1 restoreTasks) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.RestoreRunner.RunAsync(IEnumerable`1 restoreRequests, RestoreArgs restoreArgs, CancellationToken token) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Commands.RestoreRunner.RunAsync(RestoreArgs restoreContext, CancellationToken token) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Build.Tasks.BuildTasksUtility.RestoreAsync(DependencyGraphSpec dependencyGraphSpec, Boolean interactive, Boolean recursive, Boolean noCache, Boolean ignoreFailedSources, Boolean disableParallel, Boolean force, Boolean forceEvaluate, Boolean hideWarningsAndErrors, Boolean restorePC, Boolean cleanupAssetsForUnsupportedProjects, ILogger log, CancellationToken cancellationToken) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\7.0.101\\NuGet.RestoreEx.targets(19,5): error :    at NuGet.Build.Tasks.Console.MSBuildStaticGraphRestore.RestoreAsync(String entryProjectFilePath, IDictionary`2 globalProperties, IReadOnlyDictionary`2 options) [E:\\_work\\1\\s\\src\\Foo.csproj]\r\n       Done executing task \"RestoreTaskEx\" -- FAILED.\r\n```\r\n"},{"Id":"32039823908","Type":"IssuesEvent","CreatedAt":"2023-09-22T18:19:07","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/9464","RelatedDescription":"Closed issue \"[CPVM-OnBoard] Implicit flow of transitive dependencies \" (#9464) at NuGet/Home","RelatedBody":"\r\n## Details about Problem\r\n\r\nFeature Request\r\nIssue details from customer\r\n\r\n> I really hope this doesn't become the new packages.config that was so hard to maintain since updating one package meant having to update so many other packages just so that the set of versions was coherent.\r\nIn this new CPV world, I'm seeing something very similar cropping up. Here's the scenario:\r\n•\tPackage A references package B\r\n•\tSome projects reference A while others reference B\r\n•\tI now have to specify the version for both A and B in my Directory.Packages.props\r\n•\tWhen I bump the version of A, I often get a warning that I am downgrading the version of B. I have to manually update B too.\r\nKey point: What I'd like to do is just specify Package A's version in my CPV file. The transitive closure of dependencies that specify B should imply a unified version of B in my repo so that anyone who references B directly automatically gets the same version that A points to. \r\nExplicitly specifying a version for B should of course be allowed.\r\nThe above scenario is the reduced form of what is actually a very large package graph. We have a metapackages or deep dependency trees yet projects frequently reach into many parts of that tree. I would much rather maintain just a few \"top-level\" package versions and let them automatically imply the versions that everyone should use who reach for only some subtrees of it.\r\n\r\nScenarios and expectations\r\nCase 1: \r\nPackageA 2.0.0 -> PackageB 2.0.0\r\nProjectA -> PackageA \r\nProjectB -> PackageB\r\n    \r\nDirectory.Packages.props\r\n``` xml\r\n    <PackageVersion Include=”PackageA” Version=”2.0.0” />\r\n ```\r\nDesired output:\r\nRestore ProjectB  resolve the PackageB to version 2.0.0\r\n \r\nCase 2: \r\nPackageA 2.0.0 -> PackageB 2.0.0\r\nProjectA -> PackageA \r\nProjectB -> PackageB\r\n    \r\nDirectory.Packages.props\r\n``` xml\r\n    <PackageVersion Include=”PackageA” Version=”2.0.0” />\r\n    <PackageVersion Include=”PackageB” Version=”3.0.0” />\r\n ```\r\nDesired output:\r\nRestore ProjectB  resolve the PackageB to version 3.0.0\r\nRestore ProjectA resolve PackageB to version 3.0.0\r\n \r\n \r\nCase 3: \r\nPackageA 2.0.0 -> PackageB 2.0.0\r\nPackageC 3.0.0 -> PackageB 3.0.0\r\n \r\nProjectA -> PackageA \r\nProjectB -> PackageB\r\n    \r\nDirectory.Packages.props\r\n``` xml\r\n   <PackageVersion Include=”PackageA” Version=”2.0.0” />\r\n   <PackageVersion Include=”PackageC” Version=”3.0.0” />\r\n```  \r\n \r\nDesired:\r\n\r\n> I would suggest we consider that just like we would if ProjectB referenced PackageA and PackageC: fail with an ambiguity and require that PackageB now be added to the Directory.Packages.props file. \r\nThe alternative I guess would be to take the higher of the two. But I don't think that's how nuget version conflicts are resolved today, and I can live with your current policy there.\r\n\r\n"},{"Id":"32036021952","Type":"IssuesEvent","CreatedAt":"2023-09-22T15:24:03","Actor":"CoenraadS","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/12901","RelatedDescription":"Opened issue \"Ambiguous project name when using PackageID parameter\" (#12901) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\ndotnet.exe\n\n### Product Version\n\n.NET SDK:  Version:   7.0.200\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nIt's more difficult to complete my work\n\n### Repro Steps & Context\n\n[example.zip](https://github.com/NuGet/Home/files/12702218/example.zip)\r\n\r\nIn the zip file is a solution with 2 projects\r\n\r\n`ProjectC`, which has a ProjectReference to `ProjectD`\r\n\r\nNeither projects have `PackageID` defined in their `.csproj` files\r\n\r\nWhen running the command `dotnet pack .\\src\\ProjectC\\ProjectC.csproj -p:PackageID=Example`\r\n\r\nThe following error is shown `error : Ambiguous project name 'Example'.`\r\n\r\nRunning the same command without `-p:PackageID=Example` works ok\r\n\r\nRemoving the reference to `ProjectD` also fixes it, but I don't see anything in `ProjectD` which would cause an ambiguous reference.\r\n\r\nLog: \r\n[log.txt](https://github.com/NuGet/Home/files/12702257/log.txt)\r\n\n\n### Verbose Logs\n\n_No response_"},{"Id":"32017332484","Type":"IssuesEvent","CreatedAt":"2023-09-21T23:26:05","Actor":"heng-liu","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/12899","RelatedDescription":"Opened issue \"Test UpdateAllReinstall_WithPackageReferenceProject_WarnsAsync constantly fail\" (#12899) at NuGet/Home","RelatedBody":"This Apex test is currently skipped for IPC errors.\r\nBut after fixing IPC errors in test runs, it failed constantly 10 out of 10 times.\r\nThe error message is\r\n```\r\nExpected boolean to be True because Update-Package -Reinstall\r\nThe -Reinstall parameter does not apply to PackageReference based projects `TestProject'.\r\nExecuting nuget actions took 0.02 ms\r\nTime Elapsed: 00:00:00.0487588\r\nPM> , but found False.\r\n```\r\nThe stack trace is:\r\n```\r\n at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)\r\n   at FluentAssertions.Execution.TestFrameworkProvider.Throw(String message)\r\n   at FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(String message)\r\n   at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)\r\n   at FluentAssertions.Execution.AssertionScope.FailWith(Func`1 failReasonFunc)\r\n   at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)\r\n   at FluentAssertions.Primitives.BooleanAssertions`1.Be(Boolean expected, String because, Object[] becauseArgs)\r\n   at NuGet.Tests.Apex.NuGetConsoleTestCase.<UpdateAllReinstall_WithPackageReferenceProject_WarnsAsync>d__14.MoveNext() in D:\\a\\_work\\1\\s\\test\\NuGet.Tests.Apex\\NuGet.Tests.Apex\\NuGetEndToEndTests\\NuGetConsoleTestCase.cs:line 547\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n```\r\nThe standard output is:\r\n```\r\n[test] info: Creating test context\r\n[test] info: Creating solution\r\n[test] info: Adding project\r\n[test] info: Saving solution\r\n[test] info: Building solution\r\n[test] info: GetConsole\r\n[test] info: EnsurePackageManagerConsoleIsOpen\r\n[test] info: GetPackageManagerConsole\r\n[test] info: GetConsole complete\r\n[test] info: Test complete, closing solution.\r\n[test] info: Package Manager Console contents:  Update-Package -Reinstall\r\nThe `-Reinstall` parameter does not apply to PackageReference based projects `TestProject'.\r\nExecuting nuget actions took 0.03 ms\r\nTime Elapsed: 00:00:00.0486887\r\nPM> \r\n[test] info: Package Manager Output Window Pane contents:  Restored C:\\Users\\TestUser\\AppData\\Local\\Temp\\NuGetTestFolder\\a8fb82b7\\9ba11c30\\solution\\TestProject\\TestProject.csproj (in 16 ms).\r\nTime Elapsed: 00:00:00.0252250\r\n========== Finished ==========\r\n```"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"31807568458","Type":"IssuesEvent","CreatedAt":"2023-09-13T14:47:35","Actor":"dtivel","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Announcements/issues/53","RelatedDescription":"Closed issue \"The NuGet.org repository signing certificate will be updated as soon as March 15th, 2021\" (#53) at NuGet/Announcements","RelatedBody":"The current NuGet.org repository signing certificate will be updated as soon as March 15th, 2021. If you validate that packages are repository signed by NuGet.org using a [NuGet client policy](https://docs.microsoft.com/nuget/consume-packages/installing-signed-packages), the [`NuGet.exe verify`](https://docs.microsoft.com/nuget/reference/cli-reference/cli-ref-verify) command, or the [`dotnet nuget verify`](https://docs.microsoft.com/dotnet/core/tools/dotnet-nuget-verify) command, you will need to take steps by March 15th, 2021 to avoid disruptions when installing packages from NuGet.org that are signed with the new certificate. \r\n\r\nIf you are unsure if you will be impacted or want to see instructions to allow the new certificate, please see our blogpost on the matter: https://devblogs.microsoft.com/nuget/the-nuget-org-repository-signing-certificate-will-be-updated-as-soon-as-march-15th-2021/"},{"Id":"31806936414","Type":"IssuesEvent","CreatedAt":"2023-09-13T14:27:49","Actor":"dtivel","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Announcements/issues/70","RelatedDescription":"Closed issue \"The Microsoft author-signing certificate will be updated as soon as August 14th, 2023\" (#70) at NuGet/Announcements","RelatedBody":"The current Microsoft author-signing certificate will be updated as soon as August 14th, 2023.  If you validate that packages are author signed by Microsoft using a [NuGet client policy](https://docs.microsoft.com/en-us/nuget/consume-packages/installing-signed-packages) or the [`verify`](https://docs.microsoft.com/en-us/nuget/reference/cli-reference/cli-ref-verify) command, you will need to take steps to avoid disruptions when installing Microsoft packages signed with the new certificate.\r\n\r\nIf you are unsure if you will be impacted or want to see instructions to allow the new certificate, please see our blog post on the matter: https://devblogs.microsoft.com/nuget/microsoft-author-signing-certificate-update-2023/"},{"Id":"30911174831","Type":"IssuesEvent","CreatedAt":"2023-08-04T21:32:04","Actor":"dtivel","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Announcements/issues/70","RelatedDescription":"Opened issue \"The Microsoft author-signing certificate will be updated as soon as August 14th, 2023\" (#70) at NuGet/Announcements","RelatedBody":"The current Microsoft author-signing certificate will be updated as soon as August 14th, 2023.  If you validate that packages are author signed by Microsoft using a [NuGet client policy](https://docs.microsoft.com/en-us/nuget/consume-packages/installing-signed-packages) or the [`verify`](https://docs.microsoft.com/en-us/nuget/reference/cli-reference/cli-ref-verify) command, you will need to take steps to avoid disruptions when installing Microsoft packages signed with the new certificate.\r\n\r\nIf you are unsure if you will be impacted or want to see instructions to allow the new certificate, please see our blog post on the matter: https://devblogs.microsoft.com/nuget/microsoft-author-signing-certificate-update-2023/"},{"Id":"30911171660","Type":"IssuesEvent","CreatedAt":"2023-08-04T21:31:49","Actor":"dtivel","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Announcements/issues/47","RelatedDescription":"Closed issue \"The Microsoft author signing certificate will be updated as soon as November 1st, 2020\" (#47) at NuGet/Announcements","RelatedBody":"The current Microsoft author signing certificate will be updated as soon as November 1st, 2020. If you validate that packages are author signed by Microsoft using a [NuGet client policy](https://docs.microsoft.com/en-us/nuget/consume-packages/installing-signed-packages) or the [`NuGet.exe verify`](https://docs.microsoft.com/en-us/nuget/reference/cli-reference/cli-ref-verify\r\n) command, you will need to take steps to avoid disruptions when installing Microsoft packages signed with the new certificate.\r\n\r\nIf you are unsure if you will be impacted or want to see instructions to allow the new certificate, please see our blogpost on the matter: https://devblogs.microsoft.com/nuget/microsoft-author-signing-certificate-update/\r\n"}],"ResultType":"GitHubEvent"}},"RunOn":"2023-09-25T03:30:22.721615Z","RunDurationInMilliseconds":1073}