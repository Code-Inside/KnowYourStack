{"Data":{"Blog":{"FeedItems":[{"Title":"OpenSSF Scorecard for .NET and the NuGet ecosystem","PublishedOn":"2024-11-04T17:07:24+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"OpenSSF Scorecard is a tool developed by the Open Source Security Foundation (OpenSSF) that provides automated security assessments for open-source projects. The primary goal of the Scorecard project...","Href":"https://devblogs.microsoft.com/nuget/openssf-scorecard-for-net-nuget/","RawContent":null},{"Title":"NuGetAudit 2.0: Elevating Security and Trust in Package Management","PublishedOn":"2024-07-17T19:37:50+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"Introduction In November 2023 (NuGet 6.8, Visual Studio 17.8, .NET SDK 8.0.100), we released NuGet Audit. NuGet Audit provides warnings during restore when a package with a known vulnerability is used...","Href":"https://devblogs.microsoft.com/nuget/nugetaudit-2-0-elevating-security-and-trust-in-package-management/","RawContent":null},{"Title":"Building a Safer Future – How NuGet is Tackling Software Supply Chain Threats","PublishedOn":"2024-07-16T18:40:14+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Despite significant technological progress in addressing complex security threats, the key to preventing the next attack lies in adhering to fundamental security principles. It&#8217;s essential to...","Href":"https://devblogs.microsoft.com/nuget/building-a-safer-future-how-nuget-is-tackling-software-supply-chain-threats/","RawContent":null},{"Title":"Dark Mode Now Available on NuGet.org","PublishedOn":"2024-07-11T13:08:54+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"We won’t keep you “in the dark” about this any longer… Dark Mode for NuGet.org is finally here!   Your feedback has been invaluable in making this happen. We know that eye strain is a significant...","Href":"https://devblogs.microsoft.com/nuget/dark-mode-now-available-on-nuget-org/","RawContent":null},{"Title":"Announcing NuGet 6.10","PublishedOn":"2024-05-21T18:28:09+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"NuGet 6.10 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.10 for Windows, macOS, and Linux as a standalone executable. In NuGet 6.10, we introduce some...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-10/","RawContent":null},{"Title":"Announcing NuGet Commands in C# Dev Kit","PublishedOn":"2024-05-14T19:25:17+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"With the April release of C# Dev Kit, you can now manage your NuGet packages directly from Visual Studio Code using the new commands in the command palette. To add a NuGet package to your project, use...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/","RawContent":null},{"Title":"The NuGet.org repository signing certificate will be updated as soon as April 8th, 2024","PublishedOn":"2024-03-14T02:04:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Action required: If you validate that packages are repository signed by NuGet.org using a NuGet client policy, NuGet.exe verify command, or the dotnet nuget verify command, please follow these steps...","Href":"https://devblogs.microsoft.com/nuget/the-nuget-org-repository-signing-certificate-will-be-updated-as-soon-as-april-8th-2024/","RawContent":null},{"Title":"Refining Your Search: Introducing NuGet.org’s Compatible Framework Filters","PublishedOn":"2024-03-12T20:05:53+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Last year, we introduced search by target frameworks on NuGet.org, allowing you to filter your search results based on the framework(s) that a package targets. We received plenty of great feedback...","Href":"https://devblogs.microsoft.com/nuget/refining-your-search-introducing-nuget-orgs-compatible-framework-filters/","RawContent":null},{"Title":"Announcing NuGet 6.9","PublishedOn":"2024-02-14T00:33:14+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"NuGet 6.9 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.9 for Windows, macOS, and Linux as a standalone executable. In NuGet 6.9, we introduce some...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/","RawContent":null},{"Title":"Introducing NuGetSolver: A Powerful Tool for Resolving NuGet Dependency Conflicts in Visual Studio","PublishedOn":"2024-01-16T18:54:55+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"Managing dependencies on complex projects can be overwhelming. Developers often grapple with numerous direct and transitive dependencies across multiple projects. When different projects share...","Href":"https://devblogs.microsoft.com/nuget/introducing-nugetsolver-a-powerful-tool-for-resolving-nuget-dependency-conflicts-in-visual-studio/","RawContent":null}],"ResultType":"Feed"},"Gallery":{"Events":[{"Id":"44265422565","Type":"PullRequestEvent","CreatedAt":"2024-11-27T21:59:13","Actor":"dannyjdev","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10292","RelatedDescription":"Merged pull request \"[Fix] GithubVulnerability2V3 use only HTTPS\" (#10292) at NuGet/NuGetGallery","RelatedBody":"# Changes\r\n* Removed explicit http scheme when creating storages.\r\n* Not related: 2 unused lines on `src/GitHubVulnerabilities2v3/Extensions/BlobStorageVulnerabilityWriter.cs`\r\n\r\nAddresses https://github.com/NuGet/NuGetGallery/issues/123"},{"Id":"44265054243","Type":"PullRequestEvent","CreatedAt":"2024-11-27T21:41:45","Actor":"dannyjdev","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10292","RelatedDescription":"Opened pull request \"[Fix] GithubVulnerability2V3 use only HTTPS\" (#10292) at NuGet/NuGetGallery","RelatedBody":"# Changes\r\n* Removed explicit http scheme when creating storages.\r\n* Not related: 2 unused lines on `src/GitHubVulnerabilities2v3/Extensions/BlobStorageVulnerabilityWriter.cs`\r\n\r\nAddresses https://github.com/NuGet/NuGetGallery/issues/123"},{"Id":"44260154203","Type":"PullRequestEvent","CreatedAt":"2024-11-27T18:22:57","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10291","RelatedDescription":"Opened pull request \"[OIDC 13] Add audit records for federated credential flows\" (#10291) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/NuGetGallery/issues/10212.\r\nDepends on https://github.com/NuGet/NuGetGallery/pull/10290.\r\n\r\nThis PR adds audit record shapes for federated credential flows. A future PR will update the service layer to emit then audit records. This PR enables us to update our internal auditing layer to handle the new audit records before actually emitting them.\r\n\r\nAs part of this PR I needed to extract the `FederatedCredentialIssuerType` enum as a public enum, so it can enrich the audit entries. Previously it was an implementation detail of the service layer.\r\n\r\nThe following steps of the end-to-end OIDC flow are audited:\r\n1. Creation of a federated credential policy\r\n2. Validating a bearer token against a well-known issuer (e.g. Entra ID OIDC JWT validation)\r\n3. Comparing a bearer token with a policy\r\n4. Rejecting a bearer token accepted via a policy due to replay \r\n5. Exchanging a bearer token for a short-lived API key via a policy \r\n6. Deletion of a policy\r\n\r\nStep 1 is done some time before token exchange, as an onboarding step.\r\n\r\nStep 2 is during the token exchange but could be used anywhere we validate bearer tokens in the future.\r\n\r\nStep 3-5 are done during token exchange (trading an OIDC token for a short-lived API key).\r\n\r\nStep 6 is done some time after a policy is created.\r\n\r\nStep 2 is emitted as an independent \"external security token\" audit record.\r\n\r\nSteps 1 and 3-6 are emitted as \"federated credential policy\" audit records, with a variety of child audit records which will become \"target resource\" relationships in our auditing system.\r\n\r\nI opted to be somewhat verbose in the audit record shapes so we can understand:\r\n- What external credential was provided to our system, an essential information like issuer, identifier and claims.\r\n- Whether that external credential was accepted (allowing federation) or rejected.\r\n- What federated credential policy was compared with the external credential.\r\n- If token replay (re-use) was detected and blocked.\r\n- What API key was generated via the exchange."},{"Id":"44259584550","Type":"PullRequestEvent","CreatedAt":"2024-11-27T18:02:29","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10290","RelatedDescription":"Opened pull request \"Add admin panel for federated credential policies\" (#10290) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/NuGetGallery/issues/10212.\r\nDepends on https://github.com/NuGet/NuGetGallery/pull/10289.\r\n\r\nThis PR adds a new admin panel for our team to manage federated credential policies on behalf of other users. We will use this to manual onboard users to the OIDC feature.\r\n\r\nThe new option on the admin panel index looks like this:\r\n<img width=\"770\" alt=\"image\" src=\"https://github.com/user-attachments/assets/a8580536-3874-450b-b786-7c8d8af31f3f\">\r\n\r\nThe admin panel looks like this:\r\n![image](https://github.com/user-attachments/assets/77e14180-c1b3-45f3-8b71-85b14205a7d8)\r\n\r\nYou can add a federated credential policy for a user here:\r\n![image](https://github.com/user-attachments/assets/fa01ccac-a806-46bc-952c-7e680e18101a)\r\n\r\nSearch results look like this:\r\n![image](https://github.com/user-attachments/assets/d4a05218-c84a-4fc9-87a5-5bb79a39fddd)\r\n\r\nThere is a \"terminology\" section at the bottom as a reference for the feature.\r\n\r\n> ### Terminology\r\n> **Federated credential**\r\n> A credential from an external system can be traded for a short-lived API key. When a federated credential is used, it is tracked in the database to avoid credential replay (reuse). An example federated credential would be an OpenID Connect (OIDC) token from a trusted external identity provider, such as Entra ID.\r\n>\r\n> **Federated credential policy**\r\n> A set of criteria to determine whether a given federated credential is acceptable to be used to operate on behalf of a specific user. This can be considered a trust policy of an external identity provided, expressed by a user of NuGet Gallery.\r\n>\r\n> **Policy user**\r\n> This is the user account that manages the federated credential policy. This will be the user that the generated short-lived API keys will be owned by.\r\n>\r\n> **Policy package owner**\r\n> This is the user or organization account that the API key will act on behalf of. This is different from the policy user because the package owner can be an organization. The policy package owner will become the owner scope on the short-lived API key created from the policy.\r\n> \r\n> **Policy type**\r\n> This is the type of federated credential that is accepted by the policy. The policy type determines how the policy criteria are interpreted. An example policy type would be an Entra ID service principal policy, which would accept Entra ID OIDC bearer tokens containing a specific tenant ID and object ID referring to a service principal.\r\n> \r\n> **Policy criteria**\r\n> These are criteria specific to a certain policy type and specified by the user. An example of some policy criteria would be a tenant ID and object ID pair for an Entra ID service principal."},{"Id":"44259032985","Type":"PullRequestEvent","CreatedAt":"2024-11-27T17:43:20","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10289","RelatedDescription":"Opened pull request \"[OIDC 11] Add method to delete policy and associated API keys\" (#10289) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/NuGetGallery/issues/10212.\r\nDepends on https://github.com/NuGet/NuGetGallery/pull/10288.\r\n\r\nThis PR add a new service method to delete an existing federated credential policy entity. It is the responsibility of the caller to fetch the entity from the entity context prior to calling the method.\r\n\r\nSince short-lived API keys can be associated with a federated credential policy, this PR also adds a new method to the `IFederatedCredentialRepository` interface to retrieve all short-lived API keys associated with a given policy so they can be deleted.\r\n\r\nI chose to manually cascade the deletion so that proper \"credential delete\" audit records (via the existing flow) are created, instead of depending on the DB to automatically cascade deletion. This also ensures the business logic of credential deletion we encapsulate in `IAuthenticationService.RemoveCredential` is respected.\r\n\r\nIn the short term, this method will be called by an admin panel to view and manage federated credential policies."},{"Id":"44258760309","Type":"PullRequestEvent","CreatedAt":"2024-11-27T17:35:08","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10288","RelatedDescription":"Opened pull request \"[OIDC 10] Add method to create an Entra ID SP trust policy\" (#10288) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/NuGetGallery/issues/10212.\r\nDepends on https://github.com/NuGet/NuGetGallery/pull/10287.\r\n\r\nThis PR introduces a service method to create a new federated credential policy for a given Entra ID service principal. In the near term this method will be called by an admin panel as we manually onboard people to the OIDC feature.\r\n\r\nThis method is responsible for the following validations:\r\n- The user that created the policy is not an organization\r\n- The user must have access to the given package owner (e.g. a member of the organization)\r\n- The package owner user/organization is in federated credential (OIDC) flight.\r\n- The provided Entra ID tenant is in the allow list\r\n\r\nNo validations are done to ensure the Entra ID service principal actually exists. The object ID and tenant ID of the service principal are assumed to exist. It is the responsibility of the user to provide good values. This is a relatively safe assumption because a non-existent service principal will not have tokens issued for it and future operations that leverage the created policy will only happen with a valid Entra ID JWT. "},{"Id":"44258520330","Type":"PullRequestEvent","CreatedAt":"2024-11-27T17:27:37","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10287","RelatedDescription":"Opened pull request \"[OIDC 9] Add allow list for Entra ID tenants acceptable for federation\" (#10287) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/NuGetGallery/issues/10212.\r\nDepends on https://github.com/NuGet/NuGetGallery/pull/10286.\r\n\r\nThis PR adds an allow list of Entra ID tenants which can be used for token exchange. This allows us to carefully control federation as we role the OIDC feature out. Starting out, we will only allow first party, internal Entra ID tenants. Third party users will likely wait on GitHub Actions integration.\r\n\r\nThis allow list will be used during token validation and (in a future PR) in the UI to create federated credential policies.\r\n\r\nIf `all` is specified in the configuration, all Entra ID tenants are allowed. This is the default for local development but in production we will have one or more tenant ID GUIDs specified. Multiple values are separated by semicolon `;` as implemented by [`StringArrayConverter`](https://github.com/NuGet/NuGetGallery/blob/main/src/NuGet.Services.Configuration/StringArrayConverter.cs)."},{"Id":"44258020565","Type":"PullRequestEvent","CreatedAt":"2024-11-27T17:11:51","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10286","RelatedDescription":"Opened pull request \"[OIDC 8] Evaluate federated credential and generate API key\" (#10286) at NuGet/NuGetGallery","RelatedBody":"Progress on https://github.com/NuGet/NuGetGallery/issues/10212.\r\nDepends on https://github.com/NuGet/NuGetGallery/pull/10285.\r\n\r\nThis is the second PR in addition to https://github.com/NuGet/NuGetGallery/pull/10269 which implements the core business logic of the OIDC feature. This PR introduces a high-level `FederatedCredentialService` with a `GenerateApiKeyAsync` method.\r\n\r\nGiven a NuGet.org username and a bearer token (JWT), this method:\r\n1. Gets federated credential policies for the provided user\r\n2. Evaluates each policy to see if it applies to the bearer token (via a dependency interface)\r\n3. The first matching policy (if any) is used to create short-lived API key.\r\n4. The API key in plaintext is returned to the caller.\r\n\r\nA new token exchange HTTP API endpoint will be added in a future PR to call this new method.\r\n\r\nWriting out new audit entries will come in a future PR.\r\n\r\nThis new method uses another class to evaluate the list of polices against the bearer token (which internally includes checking the format and validity of the bearer token):\r\nhttps://github.com/NuGet/NuGetGallery/blob/4ca98319e435a60807ff8a52735f5da12b68add8/src/NuGetGallery.Services/Authentication/Federated/FederatedCredentialEvaluator.cs#L40\r\n\r\nThe new `GenerateApiKeyAsync` method is responsible for the following validations:\r\n- The username must refer to a valid, non-deleted, non-locked user account.\r\n- Handling the result of the policy evaluation (bad token, no matching policy, matching policy)\r\n- The package owner on the selected policy must be a valid, non-deleted, non-locked user or organization account.\r\n- The user must have access to the package owner (e.g. member of the organization)\r\n- The federated credential has not already been used (reject token replay)  "},{"Id":"44257553256","Type":"PullRequestEvent","CreatedAt":"2024-11-27T16:57:32","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10285","RelatedDescription":"Opened pull request \"[OIDC 7] DB migration for federated credentials, associate policy with API key\" (#10285) at NuGet/NuGetGallery","RelatedBody":"> [!IMPORTANT]\r\n> This PR contains a DB migration. During deployment, we must execute Entity Framework DB migrations prior to deploying the new code.\r\n\r\nProgress on https://github.com/NuGet/NuGetGallery/issues/10212.\r\nDepends on https://github.com/NuGet/NuGetGallery/pull/10269.\r\n\r\nThis PR introduces database changes to support the OIDC feature. We are adding two new tables and adding a new column to the existing `Credentials` table.\r\n\r\n- **New table:** `FederatedCredentialPolicies` - this stores criteria to evaluate a federated credentials like OIDC JWTs. See [`FederatedCredentialEvaluator`](https://github.com/NuGet/NuGetGallery/blob/4ca98319e435a60807ff8a52735f5da12b68add8/src/NuGetGallery.Services/Authentication/Federated/FederatedCredentialEvaluator.cs) to see how the columns are used.\r\n  - Foreign key links to `Users` via the `CreatedByUserKey` and `PackageOwnerUserKey` columns.\r\n  - There are two 1:N (one to many) relationships from user to federated credential policy, one to track who created the policy (user only) and one to track which package owner.\r\n- **New table:** `FederatedCredentials` - this stored federated credentials that have been used, in order to detect token replay. \r\n  - This table links to the `FederatedCredentialPolicies` table *without a foreign key*. If a policy is deleted, the federated credential record should not be removed, otherwise replay could occur. It is totally possible for a federated credential record to refer to a policy key that no longer exists. I added the column so we have a persistent record of the policy that was used to accept the federated credential. This can be used to correlate with existing records or make sense of audit logs.\r\n- **New column:** optional `FederatedCredentialPolicyKey` on the `Credentials` table - this allows us to associate a policy with a short-lived API key that was created. In audit logs this will allow us to correlate a federated credential (JWT claims) with an API key that is used for a privileged action. Also, it allows us to delete short-lived API keys if the policy is deleted (manual revocation).\r\n   - This is a new 1:N (one to many) relationship from policy to credential (API key). It is possible for API keys and other credential types to have no related policy. It is possible for a policy to have no related credentials. The application ensures only API keys relate to policies, although the DB schema does allow non-API key credentials to have a policy key (due to our generic `Credentials` table design).\r\n\r\nSQL:\r\n```sql\r\nCREATE TABLE [dbo].[FederatedCredentialPolicies] (\r\n    [Key] [int] NOT NULL IDENTITY,\r\n    [Created] [datetime2](7) NOT NULL,\r\n    [LastMatched] [datetime2](7),\r\n    [TypeKey] [int] NOT NULL,\r\n    [Criteria] [nvarchar](max) NOT NULL,\r\n    [CreatedByUserKey] [int] NOT NULL,\r\n    [PackageOwnerUserKey] [int] NOT NULL,\r\n    CONSTRAINT [PK_dbo.FederatedCredentialPolicies] PRIMARY KEY ([Key])\r\n)\r\nCREATE INDEX [IX_CreatedByUserKey] ON [dbo].[FederatedCredentialPolicies]([CreatedByUserKey])\r\nCREATE INDEX [IX_PackageOwnerUserKey] ON [dbo].[FederatedCredentialPolicies]([PackageOwnerUserKey])\r\nCREATE TABLE [dbo].[FederatedCredentials] (\r\n    [Key] [int] NOT NULL IDENTITY,\r\n    [TypeKey] [int] NOT NULL,\r\n    [FederatedCredentialPolicyKey] [int] NOT NULL,\r\n    [Identity] [nvarchar](64),\r\n    [Created] [datetime2](7) NOT NULL,\r\n    [Expires] [datetime2](7),\r\n    CONSTRAINT [PK_dbo.FederatedCredentials] PRIMARY KEY ([Key])\r\n)\r\nCREATE INDEX [IX_FederatedCredentialPolicyKey] ON [dbo].[FederatedCredentials]([FederatedCredentialPolicyKey])\r\nCREATE UNIQUE INDEX [IX_Identity] ON [dbo].[FederatedCredentials]([Identity])\r\nALTER TABLE [dbo].[Credentials] ADD [FederatedCredentialPolicyKey] [int]\r\nCREATE INDEX [IX_FederatedCredentialPolicyKey] ON [dbo].[Credentials]([FederatedCredentialPolicyKey])\r\nALTER TABLE [dbo].[Credentials] ADD CONSTRAINT [FK_dbo.Credentials_dbo.FederatedCredentialPolicies_FederatedCredentialPolicyKey] FOREIGN KEY ([FederatedCredentialPolicyKey]) REFERENCES [dbo].[FederatedCredentialPolicies] ([Key])\r\nALTER TABLE [dbo].[FederatedCredentialPolicies] ADD CONSTRAINT [FK_dbo.FederatedCredentialPolicies_dbo.Users_CreatedByUserKey] FOREIGN KEY ([CreatedByUserKey]) REFERENCES [dbo].[Users] ([Key])\r\nALTER TABLE [dbo].[FederatedCredentialPolicies] ADD CONSTRAINT [FK_dbo.FederatedCredentialPolicies_dbo.Users_PackageOwnerUserKey] FOREIGN KEY ([PackageOwnerUserKey]) REFERENCES [dbo].[Users] ([Key])\r\n```"}],"ResultType":"GitHubEvent"},"Home":{"Events":[{"Id":"44230136793","Type":"IssuesEvent","CreatedAt":"2024-11-27T01:58:47","Actor":"thaiknguyen","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13967","RelatedDescription":"Opened issue \"Issues with several nuget package but others work fine\" (#13967) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nNuGet.exe\n\n### Product Version\n\n6.5.0.154\n\n### Worked before?\n\nversion did not change\n\n### Impact\n\nIt's more difficult to complete my work\n\n### Repro Steps & Context\n\nThere seems to be a misleading error, and I can't figure out why my pushes are failing for some nuget packages.. when using the UI, it works, but not through the command line.. however, same API key works for other nuget packages.\r\n\r\nI created a new API key with * as glob pattern but still does not work.  Besides, as mentioned, some packages did upload ok.  The packages I'm uploading seems to be new (e.g. not just a new version).\n\n### Verbose Logs\n\n```shell\nnuget.exe push C:\\FTemp\\nuget\\package\\Atalasoft.dotImage.PdfReader.Multiprocessing.x86.11.5.0.4216.nupkg -Source https://www.nuget.org -Verbosity detailed\r\nPushing Atalasoft.dotImage.PdfReader.Multiprocessing.x86.11.5.0.4216.nupkg to the NuGet gallery (https://www.nuget.org)...\r\n  PUT https://www.nuget.org/api/v2/package/\r\n  Forbidden https://www.nuget.org/api/v2/package/ 472ms\r\nResponse status code does not indicate success: 403 (The specified API key is invalid, has expired, or does not have permission to access the specified package.).\n```\n"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[],"ResultType":"GitHubEvent"}},"RunOn":"2024-11-28T03:30:21.225857Z","RunDurationInMilliseconds":1210}