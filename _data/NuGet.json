{"Data":{"Blog":{"FeedItems":[{"Title":"Announcing NuGet 6.10","PublishedOn":"2024-05-21T18:28:09+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"NuGet 6.10 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.10 for Windows, macOS, and Linux as a standalone executable.\nIn NuGet 6.10, we introduce some...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-10/","RawContent":null},{"Title":"Announcing NuGet Commands in C# Dev Kit","PublishedOn":"2024-05-14T19:25:17+00:00","CommentsCount":6,"FacebookCount":0,"Summary":"With the April release of C# Dev Kit, you can now manage your NuGet packages directly from Visual Studio Code using the new commands in the command palette.\nTo add a NuGet package to your project, use...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/","RawContent":null},{"Title":"The NuGet.org repository signing certificate will be updated as soon as April 8th, 2024","PublishedOn":"2024-03-14T02:04:17+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Action required: If you validate that packages are repository signed by NuGet.org using a NuGet client policy, NuGet.exe verify command, or the dotnet nuget verify command, please follow these steps...","Href":"https://devblogs.microsoft.com/nuget/the-nuget-org-repository-signing-certificate-will-be-updated-as-soon-as-april-8th-2024/","RawContent":null},{"Title":"Refining Your Search: Introducing NuGet.org’s Compatible Framework Filters","PublishedOn":"2024-03-12T20:05:53+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Last year, we introduced search by target frameworks on NuGet.org, allowing you to filter your search results based on the framework(s) that a package targets. We received plenty of great feedback...","Href":"https://devblogs.microsoft.com/nuget/refining-your-search-introducing-nuget-orgs-compatible-framework-filters/","RawContent":null},{"Title":"Announcing NuGet 6.9","PublishedOn":"2024-02-14T00:33:14+00:00","CommentsCount":5,"FacebookCount":0,"Summary":"NuGet 6.9 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.9 for Windows, macOS, and Linux as a standalone executable.\nIn NuGet 6.9, we introduce some...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/","RawContent":null},{"Title":"Introducing NuGetSolver: A Powerful Tool for Resolving NuGet Dependency Conflicts in Visual Studio","PublishedOn":"2024-01-16T18:54:55+00:00","CommentsCount":14,"FacebookCount":0,"Summary":"Managing dependencies on complex projects can be overwhelming. Developers often grapple with numerous direct and transitive dependencies across multiple projects. When different projects share...","Href":"https://devblogs.microsoft.com/nuget/introducing-nugetsolver-a-powerful-tool-for-resolving-nuget-dependency-conflicts-in-visual-studio/","RawContent":null},{"Title":"Announcing NuGet.exe and NuGet Client SDK Packages Support Policy: Keeping You Informed and Secure","PublishedOn":"2023-11-21T01:04:53+00:00","CommentsCount":2,"FacebookCount":0,"Summary":"At NuGet, our commitment is to ensure that our users have access to the latest, most secure, and well-maintained versions of our tools and packages. With this in mind, we would like to announce the...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-exe-and-nuget-client-sdk-packages-support-policy-keeping-you-informed-and-secure/","RawContent":null},{"Title":"Announcing NuGet 6.8 – Maintaining Security with Ease","PublishedOn":"2023-11-17T22:26:57+00:00","CommentsCount":4,"FacebookCount":0,"Summary":"NuGet 6.8 is included in Visual Studio 2022 and .NET 8.0 out of the box. You can also download NuGet 6.8 for Windows, macOS, and Linux as a standalone executable.\nMaintaining and understanding...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-8-maintaining-security-with-ease/","RawContent":null},{"Title":"HTTPS Everywhere Update","PublishedOn":"2023-09-19T15:52:06+00:00","CommentsCount":7,"FacebookCount":0,"Summary":"Mistakes were made\nWhen we first published the plan for the effort of HTTPS everywhere, we wanted to get developer community feedback on the various HTTP and HTTPS scenarios that we don&#8217;t have...","Href":"https://devblogs.microsoft.com/nuget/https-everywhere-update/","RawContent":null},{"Title":"Announcing NuGet 6.7 – Keeping You Secure","PublishedOn":"2023-08-10T15:27:01+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"NuGet 6.7 is included in Visual Studio 2022 and .NET 7.0 out of the box. You can also download NuGet 6.7 for Windows, macOS, and Linux as a standalone executable.\nSecurity is a chain; it&#8217;s only...","Href":"https://devblogs.microsoft.com/nuget/announcing-nuget-6-7-keeping-you-secure/","RawContent":null}],"ResultType":"Feed"},"Gallery":{"Events":[{"Id":"39722512703","Type":"IssuesEvent","CreatedAt":"2024-06-28T21:40:54","Actor":"thaiknguyen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/10053","RelatedDescription":"Opened issue \"Can not get API key with glob pattern to work\" (#10053) at NuGet/NuGetGallery","RelatedBody":"### NuGet Product Used\n\nNuGet.exe\n\n### Product Version\n\nnuget.exe\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nOther\n\n### Repro Steps & Context\n\nCreate an API key with glob pattern: *alpha*\r\n\r\n\r\nI'm unable to push packages with that pattern in the name.. for example:\r\n\r\n>nuget push thaitest.alpha.AppLogger.3.0.0.nupkg -Source https://api.nuget.org/v3/index.json\r\nPushing thaitest.alpha.AppLogger.3.0.0.nupkg to 'https://www.nuget.org/api/v2/package'...\r\n  PUT https://www.nuget.org/api/v2/package/\r\n  Forbidden https://www.nuget.org/api/v2/package/ 268ms\r\nResponse status code does not indicate success: 403 (The specified API key is invalid, has expired, or does not have permission to access the specified package.).\r\n\r\nI'm actually trying to only allow pushing '-alpha' version packages for this API key, but also tried the package name; both failed.  If I changed the glob pattern to just *, then the above works.\r\n\n\n### Verbose Logs\n\n```shell\nnuget push thaitest.alpha.AppLogger.3.0.0.nupkg -Source https://api.nuget.org/v3/index.json -verbosity detailed\r\nNuGet Version: 6.10.0.107\r\nPushing thaitest.alpha.AppLogger.3.0.0.nupkg to 'https://www.nuget.org/api/v2/package'...\r\n  PUT https://www.nuget.org/api/v2/package/\r\n  Forbidden https://www.nuget.org/api/v2/package/ 311ms\r\nResponse status code does not indicate success: 403 (The specified API key is invalid, has expired, or does not have permission to access the specified package.).\r\nSystem.Net.Http.HttpRequestException: Response status code does not indicate success: 403 (The specified API key is invalid, has expired, or does not have permission to access the specified package.).\r\n   at System.Net.Http.HttpResponseMessage.EnsureSuccessStatusCode()\r\n   at NuGet.Protocol.Core.Types.PackageUpdateResource.EnsureSuccessStatusCode(HttpResponseMessage response, Nullable`1 codeNotToThrow, ILogger logger)\r\n   at NuGet.Protocol.Core.Types.PackageUpdateResource.<>c__DisplayClass26_0.<PushPackageToServer>b__0(HttpResponseMessage response)\r\n   at NuGet.Protocol.HttpSource.<ProcessResponseAsync>d__20`1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.Protocol.Core.Types.PackageUpdateResource.<PushPackageToServer>d__26.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.Protocol.Core.Types.PackageUpdateResource.<PushPackageCore>d__22.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at NuGet.Protocol.Core.Types.PackageUpdateResource.<PushPackagePath>d__21.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at NuGet.Protocol.Core.Types.PackageUpdateResource.<Push>d__15.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.Commands.PushRunner.<Run>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.CommandLine.PushCommand.<ExecuteCommandAsync>d__36.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.CommandLine.Command.Execute()\r\n   at NuGet.CommandLine.Program.MainCore(String workingDirectory, String[] args)\n```\n"},{"Id":"39722490598","Type":"PullRequestEvent","CreatedAt":"2024-06-28T21:39:31","Actor":"agr","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10052","RelatedDescription":"Merged pull request \"More arguments for `UsingMsi` method.\" (#10052) at NuGet/NuGetGallery","RelatedBody":"Added `readAccessGeoRedundant` and `requestTimeout` arguments to `UsingMsi`."},{"Id":"39721301761","Type":"PullRequestEvent","CreatedAt":"2024-06-28T20:34:52","Actor":"agr","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10052","RelatedDescription":"Opened pull request \"More arguments for `UsingMsi` method.\" (#10052) at NuGet/NuGetGallery","RelatedBody":"Added `readAccessGeoRedundant` and `requestTimeout` arguments to `UsingMsi`."},{"Id":"39715444140","Type":"PullRequestEvent","CreatedAt":"2024-06-28T16:08:41","Actor":"erdembayar","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/9986","RelatedDescription":"Merged pull request \"move to 8.0.301 sdk\" (#9986) at NuGet/NuGetGallery","RelatedBody":"Tracking issue: https://github.com/NuGet/Engineering/issues/5505"},{"Id":"39710006263","Type":"IssuesEvent","CreatedAt":"2024-06-28T13:11:08","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/NuGetGallery/issues/10047","RelatedDescription":"Closed issue \"activePackageSource should be removed since it's deprecated\" (#10047) at NuGet/NuGetGallery","RelatedBody":"Per https://learn.microsoft.com/en-us/nuget/reference/nuget-config-file#activepackagesource"},{"Id":"39709993701","Type":"PullRequestEvent","CreatedAt":"2024-06-28T13:10:44","Actor":"joelverhagen","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10048","RelatedDescription":"Merged pull request \"Remove activePackageSource from NuGet.config\" (#10048) at NuGet/NuGetGallery","RelatedBody":"Remove activePackageSource as it's deprecated since 3.x, per https://learn.microsoft.com/en-us/nuget/reference/nuget-config-file#activepackagesource\r\nAddresses https://github.com/NuGet/NuGetGallery/issues/10047"},{"Id":"39695870492","Type":"PullRequestEvent","CreatedAt":"2024-06-28T03:41:09","Actor":"SimonCropp","Repository":"NuGet/NuGetGallery","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/NuGetGallery/pull/10051","RelatedDescription":"Opened pull request \"remove some redundant ToString\" (#10051) at NuGet/NuGetGallery","RelatedBody":""}],"ResultType":"GitHubEvent"},"Home":{"Events":[{"Id":"39733803974","Type":"IssuesEvent","CreatedAt":"2024-06-29T19:05:28","Actor":"Nigusu-Allehu","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Home/issues/13446","RelatedDescription":"Closed issue \"tweak wording of NU1603\" (#13446) at NuGet/Home","RelatedBody":"### NuGet Product(s) Involved\r\n\r\nOther/NA\r\n\r\n### The Elevator Pitch\r\n\r\nI got a bunch of these and was a little confused\r\n`[restore] .../TestProject.IntegrationServiceA.csproj : error NU1603: Warning As Error: TestProject.IntegrationServiceA depends on Aspire.StackExchange.Redis (>= 8.0.0) but Aspire.StackExchange.Redis 8.0.0 was not found. An approximate best match of Aspire.StackExchange.Redis 8.0.1 was resolved. [...]`\r\n\r\nHow i read it \r\n* \"any version 8.0.0 or later is acceptable, but we had to fall back and use 8.0.1\" \r\nthis confused me as 8.0.1 seems to match the >= constraint so how was it approximate?\r\n\r\nWhat it's saying\r\n* \"any version 8.0.0 or later is acceptable, with 8.0.0 preferred. We could not find 8.0.0 so we used the next closest version we found 8.0.1\"\r\n\r\nMaybe the message would be clearer like\r\n`TestProject.IntegrationServiceA depends on Aspire.StackExchange.Redis (>= 8.0.0). Aspire.StackExchange.Redis 8.0.0 was preferred but not found. The next nearest available match Aspire.StackExchange.Redis 8.0.1 was resolved.`\r\n\r\n\r\n### Additional Context and Details\r\n\r\n_No response_"},{"Id":"39732133222","Type":"IssuesEvent","CreatedAt":"2024-06-29T15:44:26","Actor":"SchreinerK","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13599","RelatedDescription":"Opened issue \"UpdatePackage Exception ((https://nuget.pkg.github.com)\" (#13599) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nVisual Studio Package Manager Console\n\n### Product Version\n\ndornet 8.0.200 nuget 6.10.0.0\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nI'm unable to use this version\n\n### Repro Steps & Context\n\nTrying update a prerelease package from github (https://nuget.pkg.github.com) for the first time. \r\nUpdate from nuget (api.nuget.org) does work.\r\nFirst using visual stufio UI, then package manager console. both logs appended\r\n\n\n### Verbose Logs\n\n```shell\nRestoring packages for D:\\Develop\\Extern\\GitHub.xxxxxx\\xxxxxxxxxxxxxxxxxx\\src\\xxxxxxxxxxxxxxxxxx.csproj...\r\n  GET https://api.nuget.org/v3/vulnerabilities/index.json\r\n  OK https://api.nuget.org/v3/vulnerabilities/index.json 53ms\r\n  GET https://api.nuget.org/v3-vulnerabilities/2024.06.28.05.31.02/vulnerability.base.json\r\n  GET https://api.nuget.org/v3-vulnerabilities/2024.06.28.05.31.02/2024.06.29.11.31.04/vulnerability.update.json\r\n  OK https://api.nuget.org/v3-vulnerabilities/2024.06.28.05.31.02/vulnerability.base.json 50ms\r\n  OK https://api.nuget.org/v3-vulnerabilities/2024.06.28.05.31.02/2024.06.29.11.31.04/vulnerability.update.json 108ms\r\nSystem.NullReferenceException: Object reference not set to an instance of an object.\r\n   at NuGet.PackageManagement.NuGetPackageManager.<ExecuteBuildIntegratedProjectActionsAsync>d__93.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.PackageManagement.NuGetPackageManager.<ExecuteNuGetProjectActionsAsync>d__87.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.PackageManagement.NuGetPackageManager.<ExecuteNuGetProjectActionsAsync>d__86.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at NuGet.PackageManagement.NuGetPackageManager.<ExecuteNuGetProjectActionsAsync>d__85.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.PackageManagement.VisualStudio.NuGetProjectManagerService.<>c__DisplayClass20_0.<<ExecuteActionsAsync>b__0>d.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at NuGet.PackageManagement.VisualStudio.NuGetProjectManagerService.<CatchAndRethrowExceptionAsync>d__32.MoveNext()\r\nTime Elapsed: 00:00:01.2737315\r\n========== Finished ==========\r\n\r\n\r\nPM> Update-Package xxxxxx.xxxxxxxxxxxx -Verbose -IncludePrerelease\r\nNo package updates are available from the current package source for project 'xxxxxxxxxxxxxxxxxx.Tests'.\r\n  GET https://api.nuget.org/v3/registration5-gz-semver2/xxxxxx.xxxxxxxxxxxx/index.json\r\n  GET https://nuget.pkg.github.com/xxxxxx/xxxxxx.xxxxxxxxxxxx/index.json\r\n  OK https://nuget.pkg.github.com/xxxxxx/xxxxxx.xxxxxxxxxxxx/index.json 407ms\r\n  OK https://api.nuget.org/v3/registration5-gz-semver2/xxxxxx.xxxxxxxxxxxx/index.json 524ms\r\nRunning restore with 24 concurrent jobs.\r\nReading project file D:\\Develop\\Extern\\xxxxxxxx\\xxxxxxxxxxxxxxxxxx\\src\\xxxxxxxxxxxxxxxxxx.csproj.\r\nRestoring packages for D:\\Develop\\Extern\\xxxxxxxx\\xxxxxxxxxxxxxxxxxx\\src\\xxxxxxxxxxxxxxxxxx.csproj...\r\nRestoring packages for .NETCoreApp,Version=v8.0...\r\nResolving conflicts for net8.0-windows7.0...\r\n  CACHE https://api.nuget.org/v3/vulnerabilities/index.json\r\n  CACHE https://api.nuget.org/v3-vulnerabilities/2024.06.28.05.31.02/vulnerability.base.json\r\n  CACHE https://api.nuget.org/v3-vulnerabilities/2024.06.28.05.31.02/2024.06.29.11.31.04/vulnerability.update.json\r\nAll packages and projects are compatible with net8.0-windows7.0.\r\nUpdate-Package : Object reference not set to an instance of an object.\r\nAt line:1 char:1\r\n+ Update-Package xxxxxx.xxxxxxxxxxxx -Verbose -IncludePrerelease\r\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : NotSpecified: (:) [Update-Package], Exception\r\n    + FullyQualifiedErrorId : NuGetCmdletUnhandledException,NuGet.PackageManagement.PowerShellCmdlets.UpdatePackageCommand\r\n \r\nTime Elapsed: 00:00:02.0589993\n```\n"},{"Id":"39718972342","Type":"PullRequestEvent","CreatedAt":"2024-06-28T18:44:55","Actor":"JonDouglas","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/pull/13598","RelatedDescription":"Opened pull request \"Add End-of-Life (EOL) Status for NuGet Packages\" (#13598) at NuGet/Home","RelatedBody":"This pull request introduces a new status for NuGet packages: End-of-Life (EOL). The EOL status indicates that a package is no longer maintained, supported, or updated by its authors. This status aims to provide clear guidance to package consumers and improve security by highlighting unsupported packages that should be migrated to alternatives.\r\n\r\nKey features:\r\n\r\n- New EOL status alongside existing Vulnerable and Deprecated statuses.\r\n- Visual indicators and warnings for EOL packages on NuGet.org and during package restore.\r\n- API support for querying EOL status.\r\n- CLI commands to list EOL packages in a project's dependency graph.\r\n\r\nBy implementing the EOL status, developers will have better visibility into the support lifecycle of their dependencies, allowing for more informed decisions and enhanced security practices.\r\n\r\nRelated: https://github.com/NuGet/NuGetGallery/issues/9638 & https://github.com/NuGet/NuGetGallery/issues/9837\r\n\r\nPlease 👍 or 👎 this comment to help us with the direction of this feature & leave as much feedback/questions/concerns as you'd like on this issue itself and we will get back to you shortly.\r\n\r\nThank You 🎉"},{"Id":"39716644420","Type":"IssuesEvent","CreatedAt":"2024-06-28T16:57:58","Actor":"Mikejo5000","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13597","RelatedDescription":"Opened issue \"NuGet Docs: Revise Source Link documentation with modern guidance\" (#13597) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nOther/NA\n\n### Product Version\n\nN/A\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nNone\n\n### Repro Steps & Context\n\nPorted from NuGet Docs, where we are closing issues.\r\n\r\nRevise the https://docs.microsoft.com/en-us/nuget/create-packages/symbol-packages-snupkg\r\n\r\nMost current blog might be\r\n\r\nhttps://devblogs.microsoft.com/dotnet/producing-packages-with-source-link/\r\nhttps://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink\r\nhttps://aaronstannard.com/visual-studio-sourcelink-setup/\r\n\r\nCOMMENTS\r\nfrom @PureKrome\r\nThe topic of this issue is about refreshing the Docs on Source Link. Awesome! 🚀\r\n\r\nThis thread was created by @JonDouglas after [this twitter thread convo](https://twitter.com/purekrome/status/1369551682573508614).\r\n\r\nI still have a few questions which I think can be viewed as \"The current documentation is a bit confusing or not worded clearly enough .. so lets see if we can clear things up\".\r\n\r\nFirstly: the current docs are pretty awesome with respect to getting a simple OSS package up to Nuget.org and where the code resides on GitHub. This is like the common OSS happy path.\r\n\r\nMost of my questions (where I think the docs are a bit hazy/missing info) is about:\r\n\r\nPrivate packages (think: working at a company)\r\nNot Nuget.org as the package repository because we've got private code. (In our example, it's MyGet.org)\r\nHappy path includes GitHub as the code repo ... but SL already supports 99% of the other major players, so i think this part is solved and doesn't need further docs/clarification.\r\n\r\nQuestions:\r\nQ1. There are .nupkgs and .snupkgs. What's the relationship between these? Do we need -both- of these?\r\n[The docs suggest that we create symbol packages seperate from our nuget packages](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/nuget#symbol-packages) (our main reusable library \"code\").\r\n\r\nThe idea of symbol packages is they're hosted on a symbol server and are only downloaded by a tool like Visual Studio on demand.\r\n\r\nSo from my understanding, this is what I thought the docs are saying (simplified version):\r\n\r\nCreate come code. dotnet build it. when ready, dotnet pack it. We now have your dll packaged inside a nice zip folder 📦 ready for easy re-use. Throw this package up to a special place called a NuGet server so people can find/use it really easy. ⭐\r\nCreate some symbols (`.pdb's) of your library as a separate package. Again, stick it in a 📦 and throw that up somewhere else to a special location called a Symbol Server.\r\nWhat's important about both of those two different steps is this:\r\n\r\nmain dll library/package only contains the code. Nothing else. If you get stuck and want to debug into the code, bad luck.\r\nthe symbol package contains all this extra magic to help you debug/step into the code -IF- you need to. Most people don't do this (e.g. all of the MS libraries).\r\nMost people don't want to step into the other people's code. Like all the MS libraries we're leveraging/using in our .NET apps. As such (for performance reasons) those symbol/pdb's are NOT provided by default and if you want to, you manually request those files from a symbol server on a ad-hoc basis. Great! Separation of concerns.\r\n\r\nBut now the guidance is to have the pdb's embedded into the main dll ... so this means we don't need separate snupkg's?\r\n\r\nThis is all starting to get confusing 😕\r\n\r\nQ2. What's the relationship with Source Link and .snupkgs\r\nIf the pdb's are inside an snupkg then the Source Link info is also inside the pdb's (which are in the snupkg's?) [Source Link is](https://devblogs.microsoft.com/dotnet/producing-packages-with-source-link/#how-source-link-works) (To quote @clairernovotny)\r\n\r\nthat maps raw source code locations to the source files in the build.\r\n\r\nSo we can connect readable code to the compiled code .. making it super easy to step-into-debug stuff.\r\n\r\nSo regardless how we store/handle pdb's (separate package? embedded into the dll?), Source Link will work. It just needs those pdb's.\r\n\r\nQ3. Symbol Servers.\r\nIf we do use the guidance of putting our pdb's into a separate package (called an .snupkg) and send those symbols up to a symbol server, then these symbol servers need to do other special stuff? [From this tweet](https://twitter.com/clairernovotny/status/1369618361441779715):\r\n\r\n![image](https://github.com/NuGet/Home/assets/11948536/e81c0851-9a7a-4e73-8a12-5b5a168f471f)\r\n\r\nDoes this mean even though we use other NuGet providers that are not nuget.org (e.g. MyGet.org, etc) then those 3rd parties also need to do something magical ✨ to enable Source Link to work nicely with pdb's/symbols?\r\n\r\nI hope my questions haven't confused people because I feel very confused. damn me!\r\n\r\nAcceptance Criteria\r\nFor the MSDN docs to be 'updated', I would consider the following scenario all passing:\r\n\r\nCreate a nuget package\r\nSymbols are generated and 'live' somewhere\r\nNuget is published to MyGet.org (or equivalent, not-nuget.org server)\r\nSymbols are also published somewhere (or embedded, so nothing to publish)\r\nI can create a new dotnet new blah, reference the nuget and then step through it.\r\n\r\nCOMMENTS\r\nfrom @clairernovotny \r\n<quote> Most people don't want to step into the other people's code. Like all the MS libraries we're leveraging/using in our .NET apps. As such (for performance reasons) those symbol/pdb's are NOT provided by default and if you want to, you manually request those files from a symbol server on a ad-hoc basis. Great! Separation of concerns. </quote>\r\n\r\nPerformance has nothing to do with this. There is no perf impact to having symbols in the execution of the app. The potential issues are that the nupkg is slightly larger, which may cause slower restore times for those on slower links. That said, portable pdb's and embedded pdb's are significantly smaller than the old Windows PDB's and aren't as much of an issue.\r\n\r\nSymbols are required for reproducible builds and for debugging associated code. It is almost always easier to step into the third party code, if required, than to not have the symbols. For most OSS libraries, which is the majority of the ecosystem, at the very least it enables better bug reports and better call stacks (line numbers, etc).\r\n\r\n<quote> Does this mean even though we use other NuGet providers that are not nuget.org (e.g. MyGet.org, etc) then those 3rd parties also need to do something magical ✨ to enable Source Link to work nicely with pdb's/symbols? </quote> \r\n\r\nThis is for the reproducible build logic as it needs to locate the symbols for the binaries. It has nothing to do with Source Link itself. I.e., you can use source link long as you get the PDB (and you can configure VS to get the symbols from the MyGet symbol server feeds you need already).\r\n\r\nCOMMENTS\r\nfrom @PureKrome\r\nThanks so much @clairernovotny for jumping in here 🍰\r\n\r\n<quote> That said, portable pdb's and embedded pdb's </quote>\r\n\r\nHmm - I just want to make sure we all understand the terminology better (maybe something we can update the MSDN docs with?) Can you confirm/clarify\r\n\r\nEmbedded pdb's: these are the symbols/debug-magic, which is INSIDE the dll? Or are these still a separate .pdb file that is packaged into the .nupkg file? so if I inspect the .nupkg, I will see the dll and the pdb, side by side (just like when I dotnet build and see these two files side-by-side in the output folder.\r\nPortable pdb's: is this what an .snupkg is? where the pdb is packaged into a separate packaged file.\r\nIf i'm guessing the above is correct, then why do we have the option (suggestion?) to split the pdb into a separate .snupkg?\r\n\r\n<quote>The potential issues are that the nupkg is slightly larger, which may cause slower restore times for those on slower links.\r\n</quote>\r\n\r\nIs that the reason for choosing Embedded (in the .nupkg) vs Portable (in a separate .snupkg) - restore speed?\r\n\r\nWhich means we have 2 options:\r\n\r\nEmbedded: Slightly slower restore BUT you can debug-step-into 💯\r\nPortable: Small nupkg size BUT the symbols are elsewhere and it's a real pain to access them if it's not-nuget.org\r\nthen wouldn't the guidance be something like this: To keep life easy for you developers...\r\n\r\nIf on NuGet.org -> make .snupkg's. (go portable)\r\nIf not on NuGet.org, embed and don't make snupkg's. It's too hard (go embedded)\r\nAlways add Source Link.\r\n?\r\n\r\nCOMMENTS\r\nfrom xtOrted\r\nI'm sure @PureKrome is working up to this question, but the use of .snupkg packages is also important when using [GitHub Packages](https://github.com/features/packages) since they don't support them and have a firm stance of not supporting them. I've typically bundled PDBs in my .nupkgs so tools like Application Insights, Raygun, and Sentry have more detailed stack traces but now that I'm using Source Link and GitHub Packages I'm not really sure what the right setup is.\r\n\r\nCOMMENTS\r\nfrom @poke\r\nAs [mentioned on Twitter](https://twitter.com/poke/status/1369691465526501381), in the past, I repeatedly have seen guidance to use either symbol packages or embedded PDBs without any actual arguments to back these recommendations.\r\n\r\nFor that reason, I would like to see actual explanations on a revised documentation page that compares the two options and actually explains the differences and individual benefits. While there may be good reasons to favor one over the other, I think we should allow people to make up their own mind and enable them to make educated decisions on their own.\r\n\r\nClaire [already started](https://twitter.com/clairernovotny/status/1369716728347901954) with some reasons but I think we can find more. This would be what I would start with:\r\n\r\nEmbedded PDBs\r\n\r\nSymbols packaged within single nupkg\r\nLarger package size due to included symbols\r\nWorks with all NuGet feeds (local folders, GitHub packages, AzDO artifacts)\r\nGenerally a very simple model because everything is just bundled into a single package during a single process\r\nSymbol packages\r\n\r\nSymbols are packaged inside a separate symbol package (usually snupkg)\r\nOriginal nupkg smaller due to left out symbols\r\nSymbols and debuggability are opt-in\r\nKind of a pay-what-you-need model in terms of package contents\r\nDoes not work with feeds that do not support symbol packages, or requires separate symbol server\r\nNeed to be published separately, resulting in a slightly more complicated publishing process\r\nMay need additional configuration by the end user in order for them to use them for debugging\r\n\r\nCOMMENTS\r\nfrom @clairernovotny \r\nWhen I say embedded vs portable, I am referring to the type of PDB, not about whether they're in a snupkg or nupkg.\r\n\r\nThere are two PDB formats:\r\n\r\nWindows PDB\r\nPortable PDB\r\nWindows PDB's are only supported on Windows. Portable PDB's are supported cross platform. There's more information here: https://github.com/dotnet/core/blob/main/Documentation/diagnostics/portable_pdb.md. Note that at this time, Portable PDB's are supported virtually everywhere. Portable PDB's are the default in the .NET SDK.\r\n\r\nPortable PDB's are much smaller than Windows PDB's.\r\n\r\nBoth Windows and Portable PDB's are stored in a .pdb file by default. Portable PDB's may be embedded in a PE file (dll/exe) in a section, but otherwise it's the same data.\r\n\r\nSo when I say \"Embedded PDB\", that's where the PDB data is in the exe/dll itself. When that file is packed into a .nupkg, there's nothing extra needed as the pdb data is inside the dll/exe file. A portable PDB can be either alongside the dll in the nupkg or in a snupkg. snupkg does not support Windows PDBs.\r\n\r\nBTW, the full format of Portable PDB is documented here: https://github.com/dotnet/runtime/blob/main/docs/design/specs/PortablePdb-Metadata.md\r\n\r\nThe format is controlled by the DebugType property:\r\n\r\nfull: Windows PDB, a .pdb file\r\nportable / missing: Portable PDB, a .pdb file\r\nembedded: Portable PDB, but stored inside the main .dll/.exe file\r\nExtending this out to NuGet packages, .snupkg only supports Portable PDBs. There was an older .symbols.nupkg format that supported Windows PDBs and pushed the symbols to Symbol Soruce. That's mostly been deprecated as those Windows PDB's only work on Windows.\r\n\r\nIf you generate Portable PDB's, you need to decide where to put them; you have two choices: the main .nupkg, or the .snupkg. If you use Emedded PDBs, there's nothing to do since they're inside the main .dll/.exe, which is already in the .nupkg.\r\n\r\nOur recommendation is to use Embedded PDB's largely for the simplicity and compatibility aspects. There's no additional package required (the .snupkg), no symbol server required (client config or server), and you'll always have it for diagnostics since you're far less likely to lose your running binary than some other artifact.\r\n\r\nCOMMENTS\r\nfrom @PureKrome\r\n@clairernovotny Wowz. this is awesome.\r\n\r\nSo this is sorta how I'm thinking the decision process goes ... in this exact order:\r\n\r\nWhich PDB format do I want? Portable or Windows?\r\nHow do I wish to share my PDB? Embedded or via an snupkg with a symbol server?\r\nFinally, do I wish to Source Link my PDB?\r\nNow it looks like you're saying that the suggested recommendation is 🥁 🥁🥁 :\r\n\r\nPortable PDB's are supported cross platform\r\nPortable PDB's are the default in the .NET SDK.\r\nOur recommendation is to use Embedded PDB's\r\n\r\n✔️ Portable PDB's\r\n✔️ Embedded the PDB's.\r\n🚀 Source Link those hawt PDB's.\r\nSo with this info, I'll start to do things like this.\r\n\r\nIt's also really helpful to see WHY people would want to choose snupkg's also. So all those questions @poke asked - that would be great to be documented also.\r\n\r\n✔️ These are our (Microsoft) recommendations ...\r\n⭐ But these the the other options ... which might suit these other scenarios\r\nIn the famous words of Carl Cox:\r\n![image](https://github.com/NuGet/Home/assets/11948536/e3c44532-db75-4728-9c07-d3dcf0a829a3)\r\n\r\nCOMMENTS\r\nfrom @slang25\r\nGreat writeup @clairernovotny! I've been advocating embedded PDBs for a couple of years now and will continue to do so.\r\n\r\n@jnm2 recently made me aware of another interesting scenario where you might not want embedded PDBs, if you consider your library to be something not typically debugged by consumers:\r\nhttps://github.com/shouldly/shouldly/pull/772\r\nI don't know if the underlying problem is really a tooling thing though.\r\n\r\nCOMMENTS\r\nfrom @jnm2\r\nIt's a big problem for assertion or validation/check/throw helper libraries. It jars the inner loop test debugging experience for the IDE to stop in the innards of the assertion library when Just My Code is enabled, rather than stopping on your failing assertion.\r\n\r\nCOMMENTS\r\nfrom @JonDouglas \r\nThank you all so much for the scenarios & modern guidance. We'll work on improving the existing documentation & writing some new conceptual docs during our next doc days(Once a month typically).\r\n\r\nIn the meantime, if anyone would like to contribute, I've marked this good first issue & help wanted. Here's how you can learn to contribute docs to NuGet:\r\n\r\nhttps://github.com/NuGet/docs.microsoft.com-nuget#contribution-workflow\r\n\r\nOtherwise, I'm mentally preparing myself to type up some new docs & recommendations on debug symbols. Till then!\r\n\r\n![image](https://github.com/NuGet/Home/assets/11948536/3406d225-69cc-40bd-a840-57b8a0188a5f)\r\n\r\nCOMMENTS\r\nfrom @jnm2\r\nThe reason I'm not super excited about libraries ever embedding PDBs is that the larger file size doesn't feel appropriate in a mobile or desktop app distribution scenario.\r\n\r\nFor me, the sweet spot is a separate .pdb file for every library that could conceivably end up being distributed in an app, and snupkg is the current way of getting a library's separate .pdb file loaded with the least overall consumption friction.\r\n\r\nCOMMENTS\r\nfrom @slang25\r\nThat's a job for the mono linker though, right?\r\n\r\nCOMMENTS\r\nfrom @jnm2\r\nIf tooling existed to fix this in a way that didn't lose important attributes of the libraries, such as being able to still use the PDB data when debugging crash dumps (or for some, things like Authenticode?), and the tooling could be turned on with a single csproj property, that would be different.\r\n\r\nCOMMENTS\r\nfrom @PureKrome\r\n@JonDouglas also, maybe the [Creating Symbol Packages doc](https://docs.microsoft.com/en-us/nuget/create-packages/symbol-packages-snupkg) can also be reviewed, as it is tied to this entire discussion, IMO\r\n\r\nCOMMENTS\r\nfrom @JonDouglas \r\n@PureKrome It's in the issue description when I first posted 😉. Is there something else?\r\n\r\nCOMMENTS\r\nfrom @PureKrome\r\neeks. soz. I kept seeing the TITLE of the issue .. which is about Source Link (and thinking that might only get some updates .. not all the surrounding stuff, also) .. my bad.\r\n\r\nsowwy\r\n\r\n/me goes and hides :)\r\n\r\n\r\n\n\n### Verbose Logs\n\n_No response_"},{"Id":"39716342934","Type":"IssuesEvent","CreatedAt":"2024-06-28T16:45:24","Actor":"Mikejo5000","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13596","RelatedDescription":"Opened issue \"NuGet Docs: nuget.config locations on linux\" (#13596) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nOther/NA\n\n### Product Version\n\nN/A\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nNone\n\n### Repro Steps & Context\n\nPorted from NuGet Docs, where we are closing issues.\r\n\r\nNuGet Product(s) Involved\r\ndotnet.exe\r\n\r\nThe Elevator Pitch\r\nFrom the docs it's unclear where dotnet add, dotnet nuget, etc look for configs:\r\n\r\n$XDG_DATA_HOME (typically ~/.local/share or /usr/local/share, depending on OS distribution)\r\n\r\nIn my case, this variable is not set. I wanted to add a global configuration for my docker image and tried these options:\r\n\r\nlocation: /usr/local/share, /etc/opt, /\r\nfilename: NuGet.Config, NuGetDefaults.Config, nuget.config\r\nThe only working solution turned out to be /nuget.config.\r\n\r\nHow docs can be improved in this regard:\r\n\r\ndescribe exact algorithm used by tooling for locating configs\r\nif $XDG_DATA_HOME is unset, what is the fallback? it can't be distro-specific, it's somewhere in nuget source code\r\nclarify use case of NuGetDefaults.Config\r\nclarify if nuget looks for case-sensitive config names or not: NuGet.Config vs nuget.config\r\ndescribe recommended and legacy locations/filenames. \"On Linux, this previous location was /etc/opt\" is not clear\r\nAdditional Context and Details\r\nNo response\r\n\r\nCOMMENTS\r\nfrom @Rast1234\r\nThanks for looking at this ticket. I don't think PR from any external contributor is really possible here: in order to make a PR, one would have to dig into previous, current and upcoming versions of nuget and dotnet nuget cli to figure out developer intentions. Some things are not possible to understand from code, eg. what's going to be depreacted and what is the most recommended mechanism the team is currently betting on...\r\n\r\nCOMMENTS\r\nfrom @nkolev92 \r\n@Rast1234\r\n\r\n@heng-liu recently updated the doc: https://learn.microsoft.com/en-us/nuget/consume-packages/configuring-nuget-behavior#config-file-locations-and-uses\r\n\r\nI went through the questions and spent a minute or 2 where appropriate to help out the person changing the doc and maybe help answer some questions for you in the meantime.\r\n\r\ndescribe exact algorithm used by tooling for locating configs\r\nI think https://learn.microsoft.com/en-us/nuget/consume-packages/configuring-nuget-behavior#how-settings-are-applied\r\ncovers that.\r\n\r\nif $XDG_DATA_HOME is unset, what is the fallback? it can't be distro-specific, it's somewhere in nuget source code\r\n\r\nThe backup is Home, https://github.com/NuGet/NuGet.Client/blob/741f7d55477ebd3e2201a5d9e6a030daa25ec5f2/src/NuGet.Core/NuGet.Common/PathUtil/NuGetEnvironment.cs#L223. https://github.com/NuGet/NuGet.Client/blob/741f7d55477ebd3e2201a5d9e6a030daa25ec5f2/src/NuGet.Core/NuGet.Common/PathUtil/NuGetEnvironment.cs#L284-L305. Basically looks at the HOME variable.\r\n\r\nclarify use case of NuGetDefaults.Config\r\n\r\nIt's to add non-removable sources. I don't think this is something we recommend folks use much, but deeper analysis is needed here.\r\n\r\nclarify if nuget looks for case-sensitive config names or not: NuGet.Config vs nuget.config\r\n\r\nIt matters on case sensitive FS.\r\nnuget.config, NuGet.config and NuGet.Config are all respected in that order.\r\nhttps://github.com/NuGet/NuGet.Client/blob/741f7d55477ebd3e2201a5d9e6a030daa25ec5f2/src/NuGet.Core/NuGet.Configuration/Settings/Settings.cs#L34-L36\r\n\r\ndescribe recommended and legacy locations/filenames. \"On Linux, this previous location was /etc/opt\" is not clear\r\n\r\nI think /etc/opt is not used anymore, so it's not recommended as a machine wide config location.\r\n\r\nCOMMENTS\r\nfrom @Rast1234\r\ni'm not sure what changed in docs but it looks better, great!\r\n\r\nNuGetEnvironment.cs is interesting. looks like a approached my task with wrong mindset:\r\n\r\ni expected tooling to look in some predefined specific place for a global, user-independent config if no user/project configs exist, like most linux tools place their global settings in /etc/something/nuget.config. i see this is not the case as it tries really hard to use one of env variables. i think even root always has at least $HOME that's why GetValueOrThrowMissingEnvVar doesn't throw, but i'm not sure this assumption is 100% valid. especially in containers...\r\nthe config which happens to work for me, /nuget.config, works because tooling looks up the directory tree until it finds anything?\r\nand back to docs:\r\n\r\n~/.local/share or /usr/local/share will be used (varies by OS distribution)\r\n\r\nwhy? i only see Path.Combine(_getHome.Value, \".local\", \"share\"); in source code. how can local (without dot) end up in here?\r\n\r\nOn Linux, this previous location was /etc/opt\r\n\r\ni see a fallback to /etc/opt in a branch related to CommonApplicationData enum value. since docs say previous (version?), is branch effectively dead?\r\n\r\nCOMMENTS\r\nfrom @nkolev92 \r\nwhy? i only see Path.Combine(_getHome.Value, \".local\", \"share\"); in source code. how can local (without dot) end up in here?\r\n\r\nMight be something that true at some point but not now? Not sure, requires deeper analysis.\r\n\r\nYeah, I think the /etc/opt on is probably not reachable anymore.\r\n\r\nCOMMENTS\r\nfrom @Rast1234\r\nissue is still relevant. please make sure docs are up to date with actual implementation and without hard to verify statements like \"on linux, previous location was ...\" with no clear meaning\n\n### Verbose Logs\n\n_No response_"},{"Id":"39716207900","Type":"IssuesEvent","CreatedAt":"2024-06-28T16:39:42","Actor":"Mikejo5000","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13595","RelatedDescription":"Opened issue \"NuGet Docs: The \"typical\" nuspec is out of date and missing dependency groups\" (#13595) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nOther/NA\n\n### Product Version\n\nN/A\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nNone\n\n### Repro Steps & Context\n\nPorted from NuGet docs, where we are closing issues.\r\n\r\nThis is important to include because failure to use dependency groups will result in pack warnings (or errors).\r\n\r\nCOMMENTS\r\nfrom @JonDouglas \r\nWe can update this doc to use an example like EF Core or something just to show groups.\r\n\r\n     <dependencies>\r\n      <group targetFramework=\".NETStandard2.1\">\r\n        <dependency id=\"Microsoft.EntityFrameworkCore.Abstractions\" version=\"5.0.1\" exclude=\"Build,Analyzers\" />\r\n        <dependency id=\"Microsoft.EntityFrameworkCore.Analyzers\" version=\"5.0.1\" exclude=\"Build\" />\r\n        <dependency id=\"Microsoft.Extensions.Caching.Memory\" version=\"5.0.0\" exclude=\"Build,Analyzers\" />\r\n        <dependency id=\"Microsoft.Extensions.DependencyInjection\" version=\"5.0.1\" exclude=\"Build,Analyzers\" />\r\n        <dependency id=\"Microsoft.Extensions.Logging\" version=\"5.0.0\" exclude=\"Build,Analyzers\" />\r\n        <dependency id=\"System.Collections.Immutable\" version=\"5.0.0\" exclude=\"Build,Analyzers\" />\r\n        <dependency id=\"System.ComponentModel.Annotations\" version=\"5.0.0\" exclude=\"Build,Analyzers\" />\r\n        <dependency id=\"System.Diagnostics.DiagnosticSource\" version=\"5.0.0\" exclude=\"Build,Analyzers\" />\r\n      </group>\r\n    </dependencies>\n\n### Verbose Logs\n\n_No response_"},{"Id":"39715770369","Type":"IssuesEvent","CreatedAt":"2024-06-28T16:21:45","Actor":"Mikejo5000","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13594","RelatedDescription":"Opened issue \"NuGet Docs: Improve documentation on creating native packages\" (#13594) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nOther/NA\n\n### Product Version\n\nN/A\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nNone\n\n### Repro Steps & Context\n\nPorted from NuGet Docs, where we are closing issues.\r\n\r\nInformation in the existing topic is sketchy, and there are questions, see https://docs.microsoft.com/en-us/nuget/create-packages/native-packages#comments-container.\r\n\r\nRequest: \"Needs more details of what package structures need to be and links to other reference material. \"\r\n\r\nOlder issues:\r\nhttps://github.com/NuGet/Home/issues/1508\r\nhttps://github.com/NuGet/Home/issues/3027\r\n\r\nAdditional customer feedback:\r\n\r\nNeeds more details of what package structures need to be and links to other reference material.\r\nI need to download a package. But nowhere I can do this.\r\nMore information about how to actually create a native package (use CoApp or not?)\r\nIt's painfull to create even a simple NuGet native package. Writing the props/targets files is just like the hell (it should be generated like with CoApp). Someone at Microsoft has pointed me on https://github.com/Microsoft/vcpkg (great but) the NuGet package stuff is just for local use (it's a bridge on the native files); no way to create a standalone package for publishing on the official repository :-(.\r\nHow would the creation of the nuspec file and the packaging look like? At the moment, when creating the nuspec (via nuget spec) and package afterwards (via nuget pack) nuget (v 3.5) just takes everything that sits inside my project folder and packages that. The assembly is missing etc. The CoApp project is dead and I haven't found anything on the roadmap for nuget (https://github.com/NuGet).\r\n\r\nCOMMENTS\r\nfrom @kraigb\r\nSee also https://github.com/MicrosoftDocs/mvp-hackadoc-2018/issues/43\r\n\r\nCOMMENTS\r\nfrom @ras0219-msft\r\nno way to create a standalone package for publishing on the official repository :-(.\r\n\r\nTake a look at our export command [1][2].\r\n\r\n[1] https://blogs.msdn.microsoft.com/vcblog/2017/05/03/vcpkg-introducing-export-command/\r\n[2] https://github.com/Microsoft/vcpkg/blob/d80dd5cbc777ce765c2d6b78d7c485fdf05f284b/docs/users/integration.md#export\r\n\r\nCOMMENTS\r\nfrom @kraigb\r\nWhat we really need is someone familiar with the process using vcpkg to draft a walkthrough that demonstrates the whole process of creating a native package. That expertise unfortunately does not seem to exist within the NuGet team. I can provide editing help and bringing the draft up to docs quality. Just create a branch with the work in it and we can go from there.\r\n\r\nCOMMENTS\r\nfrom @kraigb\r\nAlso addres https://github.com/NuGet/docs.microsoft.com-nuget/issues/190, https://github.com/NuGet/docs.microsoft.com-nuget/issues/592, and https://github.com/NuGet/docs.microsoft.com-nuget/issues/600.\r\n\r\nCOMMENTS\r\nfrom @ericstj\r\nJust hit this myself when trying to tell folks to use nativeassets. Can we please get docs for this feature that's been around for 2 years now? /cc @jainaashish @rrelyea\r\n\r\nCOMMENTS\r\nfrom @Mizux\r\nmy 2 cents for \"Building a cross-platform .NetStandard2.0 package with native dependencies\" (only using dotnet/cli and modern .csproj)\r\n\r\nI add my own way to do it there https://github.com/NuGet/docs.microsoft.com-nuget/issues/1013#issuecomment-414930782\r\nAnd you can found a full example project in https://github.com/Mizux/dotnet-native (Documentation on the way)\r\n\r\nStill, waiting for the official documentation !!!\r\n\r\nCOMMENTS\r\nfrom @jjpepper\r\n@kraigb that's not really correct. We don't really need anything vcpkg specific here, someone might be building in linux and producing a shared libraries from there without vcpkg being in the picture at all. The C++ people will know how to build their own libraries. The bigger question is then how to structure/create a nuget package via .nuspec so that the native libraries wind up in the target directory of the C# application that references the package. That expertise should exist within the nuget team, as it's just nuget functionality. Our approach was to use a .targets file, with the unfortunate side effect that the C# project that uses the native package sees all the shared libraries along side the source files in the solution explorer view. Yuck!\r\n\r\nCOMMENTS\r\nfrom @mizux\r\n@jjpepper why do you use/hack a target file instead of setting it in the .*proj file ?\r\nAnd did you try the <Visible> property (which should work in .*proj) ?\r\nsrc: https://docs.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2017#content\r\n\r\nCOMMENTS\r\nfrom @tebeco\r\nI'm really curious about a dotnet pack solution when vendor just gives you MyNative.dll and MyDotnetWapper.dll, refusing to create nupkg.\r\n\r\nThat's also a VERY common scenario for \"legacy\" nuget or third part that was used thx to <Reference and truing to move forward to <PackageReference by manually repackaging already built dll.\r\nThey are supposed to be repackaged to netstandard2.0 since some could target net47x for example.\r\n\r\nAs of today i never found a clear and clean solution :(\r\n\r\nCOMMENTS\r\nfrom @tebeco\r\nhello @karann-msft\r\nwould something like this helps as a support for documentation ?\r\nhttps://github.com/NuGet/Home/issues/9502\r\n\r\nThis repository show a \"way\" that vendor uses (that is bad ... as they gives us RAW .net dll)\r\nhttps://github.com/tebeco/NativeLibNugetStuff/blob/master/README.md\r\n\r\nThe original repo from @poke, shows a better way => properly packing the native + managed, it only depends on what you have on your hands\r\nhttps://github.com/poke/NativeLibNugetStuff\r\n\r\nI think both could be a good contribution to the the docs as it would helps vendor to have something to rely on, in order to release fully functional packages compliant with dotnet restore and dotnet publish\r\n\r\nCOMMENTS\r\nfrom @mizux\r\nFYI I've updated https://github.com/Mizux/dotnet-native to add \"real\" C++ samples code up to the .Net wrapper generation (using SWIG to generate the .NET wrapper from the C++ code) and I've updated my documentation accordingly.\r\n\r\nThere is also github actions workflows CI and few Linux docker to test on various distros as well as tests using MacOS and Windows runners.\r\n\r\nCOMMENTS\r\nfrom @tuket\r\nWhat is the difference between \"nativeassets\" and \"native\" folders? What is the expected directory structure?\n\n### Verbose Logs\n\n_No response_"},{"Id":"39715511686","Type":"IssuesEvent","CreatedAt":"2024-06-28T16:11:22","Actor":"Mikejo5000","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13593","RelatedDescription":"Opened issue \"NuGet Docs: Document precedence rules for package frameworks\" (#13593) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nOther/NA\n\n### Product Version\n\nN/A\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nNone\n\n### Repro Steps & Context\n\nPorted from NuGet Docs, where we are closing out issues.\r\n\r\n@karann-msft commented on https://github.com/NuGet/Home/issues/3361\r\n\r\nFrom @harikmenon on July 18, 2016 17:4\r\n\r\nWe need to explicitly call out our resolution rules and possibly link to joels site.\r\n\r\nCopied from original issue: NuGet/NuGetDocs#495\r\n\r\n@kraigb commented on https://github.com/NuGet/Home/issues/3361#issuecomment-293991222\r\n\r\nWhat information do you have on this that I can work from?\r\n\r\n@kraigb commented on https://github.com/NuGet/Home/issues/3361#issuecomment-295846230\r\n\r\n@joelverhagen Do you have suitable information?\r\n\r\nCOMMENTS\r\nfrom @nkolev92 \r\nAny work here is incomplete and confusing without https://github.com/NuGet/NuGetGallery/issues/7828 first.\r\n\r\nCOMMENTS\r\nfrom @JonDouglas \r\n@joelverhagen @dannyjdev @nkolev92 Any preferences on where this should go?\r\n\r\nI was thinking under client's \"concepts\":\r\n\r\n![image](https://github.com/NuGet/Home/assets/11948536/5cfd4fa4-f80e-4313-ba56-d3d6b8693ca7)\r\n\r\nor as a new server \"reference\" page to explain the new \"frameworks\" tab further.\r\n\r\n![image](https://github.com/NuGet/Home/assets/11948536/ee4524c6-a61f-48d2-8161-2cff6e4fb0ba)\r\n\r\nThis should be fairly easy to write a small section on with everything we have today.\r\n\r\nCOMMENTS\r\nfrom @joe\r\nI think Concepts fits better. It's a lot like the Dependency resolution doc. We can certainly have a section on the concepts page to talk about how the general idea overlaps with NuGet.org's impl.\n\n### Verbose Logs\n\n_No response_"},{"Id":"39715311529","Type":"IssuesEvent","CreatedAt":"2024-06-28T16:03:32","Actor":"Mikejo5000","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13592","RelatedDescription":"Opened issue \"NuGet Docs: Improve clarify of Configuring NuGet Behavior topic (and nuget.config reference)\" (#13592) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nOther/NA\n\n### Product Version\n\nN/A\n\n### Worked before?\n\n_No response_\n\n### Impact\n\nNone\n\n### Repro Steps & Context\n\nPorted from NuGet Docs repo, where we are closing out issues.\r\n\r\nTransferred from https://github.com/MicrosoftDocs/mvp-hackadoc-2018/issues/39\r\n\r\nRepo: https://github.com/NuGet/docs.microsoft.com-nuget\r\nhttps://docs.microsoft.com/en-us/nuget/consume-packages/configuring-nuget-behavior is somewhat confusing. See comments on the page.\r\n\r\nRequest is to overhaul the article to be simpler, and to check its accuracy.\r\n\r\nAlso see https://docs.microsoft.com/en-us/nuget/reference/nuget-config-file which might need updates as well.\r\n\r\nThe main confusion is how multiple settings files work together. Primary scenario is managing sources; other scenarios are secondary.\r\n\r\nAlso need to identify exactly where config files can and do live on both Windows and Linux. Be clear on how settings are applied.\r\n\r\nNotes:\r\nPath mappings happen in https://github.com/NuGet/NuGet.Client/blob/ea1d1395d0c3dd7b5e22b873cfd71bb8cfb9062a/src/NuGet.Core/NuGet.Common/PathUtil/NuGetEnvironment.cs\r\n\r\nConfig used to be solution-based. .NET Core didn't have solution files, so we put config in project folder and it would work. Now with MSBuild we try to bring those things together. Machine-wide is still used on top of that.\r\n\r\nDeprecate .nuget folder in solutions.\r\n\r\nNuGet.Config for projects don't get applied for VS or nuget restore in the solution root, but only in the project itself.\r\n\r\nSolution-level .config in the solution root. What does VS do with this and project .config files?\r\n\r\nUser-specific in APPDATA is accurate. Linux home/nuget, gets home/.nuget/NuGet.Config, might be ~HOME. Kill the old versions\r\n\r\nMachine-wide config, probably ~XDG_DATA_HOME or ~/.local/share\r\nProgram Files is commonApplicationData, using ProgramData on Max/Linux, see mapping.\r\n\r\nInclude dotnet and nuget CLI commands in all examples.\r\n\r\nRelated issues to address\r\nhttps://github.com/NuGet/docs.microsoft.com-nuget/issues/305\r\nhttps://github.com/NuGet/docs.microsoft.com-nuget/issues/492\n\n### Verbose Logs\n\n_No response_"},{"Id":"39715187323","Type":"IssuesEvent","CreatedAt":"2024-06-28T15:58:56","Actor":"Mikejo5000","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13591","RelatedDescription":"Opened issue \"NU5128 could use an additional examples with dependencies element usage\" (#13591) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\nOther/NA\n\n### Product Version\n\nn/a\n\n### Worked before?\n\nn/a\n\n### Impact\n\nNone\n\n### Repro Steps & Context\n\nPorted from NuGet Docs repo, where we are closing out issues. This is already triaged.\r\n\r\nSee https://github.com/NuGet/Home/issues/8583#issuecomment-616844720.\r\n\r\nThe docs are a little bit confusing.\n\n### Verbose Logs\n\n_No response_"},{"Id":"39686633034","Type":"IssuesEvent","CreatedAt":"2024-06-27T19:00:53","Actor":"jeffkl","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13590","RelatedDescription":"Opened issue \"Add tests for partial CPM adoption\" (#13590) at NuGet/Home","RelatedBody":"We have a test gap for CPM so we need to add tests that verify that CPM can be disabled globally but still enabled for projects individually."},{"Id":"39678811534","Type":"IssuesEvent","CreatedAt":"2024-06-27T14:42:05","Actor":"rainersigwald","Repository":"NuGet/Home","Organization":"NuGet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/NuGet/Home/issues/13589","RelatedDescription":"Opened issue \"IOException during restore not very informative\" (#13589) at NuGet/Home","RelatedBody":"### NuGet Product Used\n\ndotnet.exe, MSBuild.exe\n\n### Product Version\n\n.NET SDK 9.0.100-preview.5.24307.3\n\n### Worked before?\n\nNot sure, this is the first time I've seen the exception.\n\n### Impact\n\nIt bothers me. A fix would be nice\n\n### Repro Steps & Context\n\nI'm not sure what caused the underlying error but I had a build failure that manifested as\r\n\r\n```\r\n  sdk failed with 1 error(s) (3.0s)\r\n    S:\\sdk\\.dotnet\\sdk\\9.0.100-preview.5.24307.3\\NuGet.targets(170,5): error : Cannot create a file when that file already exists.\r\n\r\nBuild failed with 1 error(s) in 31.7s\r\n```\r\n\r\nWhich wasn't super helpful! I had a binlog attached which showed this stack:\r\n\r\n```\r\nSystem.IO.IOException: Cannot create a file when that file already exists.\r\n   at System.IO.FileSystem.MoveFile(String sourceFullPath, String destFullPath, Boolean overwrite)\r\n   at NuGet.Common.FileUtility.Move(String sourceFileName, String destFileName)\r\n   at NuGet.Common.FileUtility.Replace(String sourceFileName, String destFileName)\r\n   at NuGet.Common.FileUtility.Replace(Action`1 writeSourceFile, String destFilePath)\r\n   at NuGet.Common.FileUtility.Replace(Action`1 writeSourceFile, String destFilePath)\r\n   at NuGet.Commands.BuildAssetsUtils.WriteFiles(IEnumerable`1 files, ILogger log)\r\n   at NuGet.Commands.RestoreResult.CommitAssetsFileAsync(LockFileFormat lockFileFormat, ILogger log, Boolean toolCommit, CancellationToken token)\r\n   at NuGet.Commands.RestoreResult.CommitAsync(ILogger log, CancellationToken token)\r\n   at NuGet.Commands.RestoreRunner.CommitAsync(RestoreResultPair restoreResult, IRestoreProgressReporter progressReporter, CancellationToken token)\r\n   at NuGet.Commands.RestoreRunner.ExecuteAndCommitAsync(RestoreSummaryRequest summaryRequest, IRestoreProgressReporter progressReporter, CancellationToken token)\r\n   at NuGet.Commands.RestoreRunner.CompleteTaskAsync(List`1 restoreTasks)\r\n   at NuGet.Commands.RestoreRunner.RunAsync(IEnumerable`1 restoreRequests, RestoreArgs restoreArgs, CancellationToken token)\r\n   at NuGet.Commands.RestoreRunner.RunAsync(RestoreArgs restoreContext, CancellationToken token)\r\n   at NuGet.Build.Tasks.BuildTasksUtility.RestoreAsync(DependencyGraphSpec dependencyGraphSpec, Boolean interactive, Boolean recursive, Boolean noCache, Boolean ignoreFailedSources, Boolean disableParallel, Boolean force, Boolean forceEvaluate, Boolean hideWarningsAndErrors, Boolean restorePC, Boolean cleanupAssetsForUnsupportedProjects, ILogger log, CancellationToken cancellationToken)\r\n   at NuGet.Build.Tasks.RestoreTask.ExecuteAsync(ILogger log)\r\n```\r\n\r\nIdeally the file being created would be called out by path, and the NuGet error would have more context about what NuGet was doing when this happened.\n\n### Verbose Logs\n\n_No response_"}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"38239602212","Type":"IssuesEvent","CreatedAt":"2024-05-09T16:12:01","Actor":"erdembayar","Repository":"NuGet/Announcements","Organization":"NuGet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/NuGet/Announcements/issues/72","RelatedDescription":"Closed issue \"The NuGet.org repository signing certificate will be updated as soon as April 8th, 2024\" (#72) at NuGet/Announcements","RelatedBody":"The current NuGet.org repository signing certificate will be updated as soon as April 8th, 2024. If you validate that packages are repository signed by NuGet.org using a [NuGet client policy](https://docs.microsoft.com/nuget/consume-packages/installing-signed-packages), the [`NuGet.exe verify`](https://docs.microsoft.com/nuget/reference/cli-reference/cli-ref-verify) command, or the [`dotnet nuget verify`](https://docs.microsoft.com/dotnet/core/tools/dotnet-nuget-verify) command, you will need to take steps by April 8th, 2024 to avoid disruptions when installing packages from NuGet.org that are signed with the new certificate. \r\n\r\nIf you are unsure if you will be impacted or want to see instructions to allow the new certificate, please see our blogpost on the matter: https://devblogs.microsoft.com/nuget/the-nuget-org-repository-signing-certificate-will-be-updated-as-soon-as-april-8th-2024/"}],"ResultType":"GitHubEvent"}},"RunOn":"2024-06-30T03:30:18.115706Z","RunDurationInMilliseconds":1023}