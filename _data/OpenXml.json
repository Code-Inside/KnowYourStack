{"Data":{"Sdk":{"Events":[{"Id":"15877954887","Type":"IssuesEvent","CreatedAt":"2021-04-09T10:19:26","Actor":"rubansergey","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/918","RelatedDescription":"Opened issue \"OpenXml validation works slow starting from version 2.11.3\" (#918) at OfficeDev/Open-XML-SDK","RelatedBody":"- Issue with the OpenXml library\r\n\r\nWe have a customer's Wordprocessing document **with a lot of tracked changes** that hangs after we update OpenXml.\r\n\r\nImvestigation shows that:\r\n- It hangs when we call OpenXmlValidator's **Validate** method against MainDocumentPart of this document. \r\n- It works quick on version 2.11.2\r\n- It was broken of version 2.11.3 I have reviewed [changelog ](https://github.com/OfficeDev/Open-XML-SDK/blob/main/CHANGELOG.md)and there is no information that means improvement quality or making algorithm of validation  more complex. Against, there were some performance improvements like removing recursion. **This points to think that there was some side effect in this build that causes such performance impact**.\r\n- Version 2.12.0 has a CancellationToken support which is great, but is more like a workaround for our situation than a fix, as we still want to validate parts as quick as before.\r\n\r\nAfter this innitial investigation I ran main branch with such simple code added against CPU profiler:\r\n\r\n`namespace ConsoleApp1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            using (var doc = WordprocessingDocument.Open(@\"d:\\xxxxxx\\Workspace\\Desk\\Sample.docx\", false))\r\n            {\r\n                var validator = new OpenXmlValidator();\r\n                validator.Validate(doc.MainDocumentPart);\r\n            }\r\n        }\r\n    }\r\n}`\r\n\r\nProfiler shows that currently the slovest method is DocumentFormat.OpenXml.Validation.ValidationTraverser **ValidatingTraverse** \r\n![image](https://user-images.githubusercontent.com/52368905/114165458-2ea7d700-9935-11eb-825e-2c7063cc63a3.png)\r\n\r\nAt this point my investigation stops as I do not have a brunch with build before this method starts works slow and this will be out of scope of my investigation, but I think given information should be enough to at least point to the issue.\r\n\r\nAlso see attached sample document and VS profiller dump file \r\n[Sample.docx](https://github.com/OfficeDev/Open-XML-SDK/files/6284918/Sample.docx)\r\n[Report20210409-1040.zip](https://github.com/OfficeDev/Open-XML-SDK/files/6284919/Report20210409-1040.zip)\r\n\r\n\r\n\r\n\r\n\r\n"},{"Id":"15852322093","Type":"IssuesEvent","CreatedAt":"2021-04-07T18:50:56","Actor":"Pxtl","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/917","RelatedDescription":"Opened issue \"AddAlternativeFormatImportPart produces malformed documents if both parent and child contain shape-lines or similar objects\" (#917) at OfficeDev/Open-XML-SDK","RelatedBody":"**Description**\r\n\r\nDocument is malformed if I use AddAlternativeFormatImportPart on a document with a shape-line (or similar objects) in the root *and* the attached documents.\r\n\r\n**Information**\r\n\r\n- .NET Target: .NET Framework 4.6.2\r\n- DocumentFormat.OpenXml Version: 2.12.3\r\n\r\n**Repro**\r\n\r\nCreate 2 word documents \"Template.docx\" and \"ExampleAttachment.docx\".  Insert a single shape-line in both.\r\nNote this was originally discovered using a shape-line and an attached image, but it can work with a shape-line.\r\n\r\n```csharp\r\nusing DocumentFormat.OpenXml;\r\nusing DocumentFormat.OpenXml.Packaging;\r\nusing DocumentFormat.OpenXml.Wordprocessing;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace ReproAddAlternativeFormatImportPartCorruption\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var iterations = 1;\r\n            var outputPath = $\"test_{DateTime.Now.ToString(\"yyyyMMdd-hhmmss\")}.docx\";\r\n            var attachmentPath = \"ExampleAttachment.docx\";\r\n            File.Copy(\"Template.docx\", outputPath);\r\n\r\n            var attachmentBytes = File.ReadAllBytes(attachmentPath);\r\n            using (var doc = WordprocessingDocument.Open(outputPath, true))\r\n            {\r\n                var firstPar = doc.MainDocumentPart.Document.Body.FirstChild;\r\n\r\n                for (int i = 0; i < iterations; i++)\r\n                {\r\n                    var attachmentHeading = $\"{attachmentPath} {i}\";\r\n                    var xmlFileId = attachmentHeading\r\n                        .Replace(\".\", \"_\")\r\n                        .Replace(\" \", \"_\");\r\n\r\n                    var compositeElements = AddDocumentAttachment(attachmentBytes, attachmentHeading, xmlFileId, doc.MainDocumentPart, AlternativeFormatImportPartType.WordprocessingML);\r\n                    foreach (var element in compositeElements)\r\n                    {\r\n                        firstPar.InsertBeforeSelf(element);\r\n                    }\r\n                }\r\n                doc.Save();\r\n            }\r\n\r\n        }\r\n\r\n        private static IEnumerable<OpenXmlCompositeElement> AddDocumentAttachment(\r\n            byte[] fileData, \r\n            string attachmentHeading, \r\n            string xmlFileId, \r\n            MainDocumentPart mainPart, \r\n            AlternativeFormatImportPartType? alternativeFormatImportPartType)\r\n        {\r\n\r\n            // Document is automatically saved and closed onDispose.\r\n            var chunk = mainPart.AddAlternativeFormatImportPart(alternativeFormatImportPartType.Value, xmlFileId);\r\n            using (var chunkStream = chunk.GetStream(FileMode.Create, FileAccess.Write))\r\n            using (var w = new BinaryWriter(chunkStream))\r\n            {\r\n                w.Write(fileData);\r\n                w.Flush();\r\n            }\r\n\r\n            var altChunk = new AltChunk\r\n            {\r\n                Id = xmlFileId\r\n            };\r\n\r\n            mainPart.Document.Save();\r\n\r\n            return new OpenXmlCompositeElement[]{\r\n                altChunk\r\n            };\r\n\r\n        }\r\n    }\r\n}\r\n``` \r\n\r\n**Observed**\r\n\r\nOpen the file in Word (Office 2019, version 1808, build 10372.20060), get the following error:\r\n\r\n\"We're sorry.  We can't open <documentname>.docx because we found a problem with its contents [OK] [Details]\r\n\r\nDetails:\r\n\r\nHRESULT 0x800004005\r\n\r\nLocation: Part: /word/document.xml, Line: 0, Column: 0\r\n\r\n**Expected**\r\n\r\nCreate a document that does not cause errors.\r\n\r\n** Additional notes**\r\n\r\nInitially I discovered this issue happening inconsistently - like, I would attach 4 documents and it would be okay, but 5 was too much.  And the only attached objects within the document were images.\r\n\r\nNow, I can raise it consistently with the method described above, using documents created from scratch.  If needed, I can send the docx files that will reproduce this issue.\r\n\r\nIf I use the same process *without* a shapes-line drawn into the files, the error does not occur."},{"Id":"15834832835","Type":"PullRequestEvent","CreatedAt":"2021-04-06T17:17:10","Actor":"tomjebo","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/916","RelatedDescription":"Opened pull request \"Additional O19 types to match Open Specifications\" (#916) at OfficeDev/Open-XML-SDK","RelatedBody":"schemas_microsoft_com_office_spreadsheetml_2018_threadedcomments.g.cs\r\nschemas_microsoft_com_office_powerpoint_2017_10_main.g.cs\r\nschemas_microsoft_com_office_powerpoint_2018_4_main.g.cs\r\nschemas_microsoft_com_office_drawing_2017_model3d.g.cs\r\nschemas_microsoft_com_office_drawing_2017_decorative.g.cs\r\nschemas_microsoft_com_office_drawing_2018_animation_model3d.g.cs\r\nschemas_microsoft_com_office_drawing_2018_animation.g.cs\r\nschemas_microsoft_com_office_drawing_2016_11_main.g.cs\r\n\r\n"},{"Id":"15777298981","Type":"IssuesEvent","CreatedAt":"2021-04-01T06:07:51","Actor":"Jenifer-TheCoder","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/915","RelatedDescription":"Opened issue \"Replacing sdtelement in dotx file with HTML that has hyperlink doesn't work\" (#915) at OfficeDev/Open-XML-SDK","RelatedBody":"\r\n**Description**\r\n\r\nI am trying to replace dotx sdtElement with html content that has hyperlink, but the link doesn't work. w:hyperlink's relationship with link doesn't seem to be working.\r\n\r\n**Information**\r\n\r\n- .NET Target: NET Framework 4.8\r\n- DocumentFormat.OpenXml Version: 2.0.5022.0\r\n\r\n**Issue in depth:**\r\n\r\n- I have a dotx file which has [Text] that has to be replaced with html that has \r\n<body <a href=\"www.google.com>How are You\">\r\n</a>Hi\r\n</body>\r\n\r\n- Replacement happens with just text  but hyperlink doesn't seem to be working. Instead of www.google.com, it has hyperlink of <localhost>\\word\\settings.xml\r\n- Could see the convertedelement has w:hyperlink on it but still unable to retrieve hyperlink \r\n- Do i need to add anything more to Run/Paragraph-properties to get hyperlink working?\r\n\r\nThe function that replaces sdtelement is as follows:\r\n`private void WriteReplacementHtml(W.SdtElement sdtElement, Stream wordMLStream)\r\n        {\r\n            // Replace spaces between images and texts with non breaking spaces\r\n            // http://stackoverflow.com/questions/43659775/regex-to-match-images-followed-with-a-space-in-an-html-string\r\n            html = WordMLTemplateProcessor.ImageFollowedWithSpaceRegex.Replace(html, \"$1&nbsp;\");\r\n\r\n            try\r\n            {\r\n\r\n                WordprocessingDocument convertedDocument = WordprocessingDocument.Open(wordMLStream, false);\r\n                var convertedElements = convertedDocument.MainDocumentPart.RootElement.Descendants<W.Body>().Single().Elements();\r\n                // Skim the fat (SectionProperties) or risk screwing up your document\r\n                convertedElements = convertedElements.Except(convertedElements.OfType<W.SectionProperties>()).ToArray();\r\n                try\r\n                {\r\n                    List<int> numberingIdsProcessed = new List<int>();\r\n\r\n                    OpenXmlElement paragraphProperties = null;\r\n                    OpenXmlElement runProperties = null;\r\n\r\n                    List<OpenXmlElement> insertedElements = new List<OpenXmlElement>();\r\n\r\n                    // Find the first parent that can contain a block such as a paragraph or a table,\r\n                    // and keep track of the element before which we'll have to insert content\r\n                    for (OpenXmlElement sdtParent = sdtElement.Parent, sdtInsertBefore = sdtElement;\r\n                        sdtParent != null;\r\n                        sdtInsertBefore = sdtParent, sdtParent = sdtParent.Parent)\r\n                    {\r\n                        // Save the paragraph and run properties of the element (if not yet done)\r\n                        if (paragraphProperties == null) paragraphProperties = sdtInsertBefore.Descendants<W.ParagraphProperties>().FirstOrDefault();\r\n                        if (runProperties == null)\r\n                        {\r\n                            W.SdtElement element = sdtInsertBefore as W.SdtElement;\r\n                            if (element != null)\r\n                                runProperties = element.SdtProperties.Descendants<W.RunProperties>().FirstOrDefault();\r\n                        }\r\n\r\n                        // Can the parent contain a paragraph or table?\r\n                        if (sdtParent is W.Body\r\n                            || sdtParent is W.Comment\r\n                            || sdtParent is W.CustomXmlBlock\r\n                            || sdtParent is W.DocPartBody\r\n                            || sdtParent is W.Endnote\r\n                            || sdtParent is W.Footnote\r\n                            || sdtParent is W.Footer\r\n                            || sdtParent is W.Header\r\n                            || sdtParent is W.SdtContentBlock\r\n                            || sdtParent is W.TableCell)\r\n                        {\r\n                            // Insert the converted elements as they come\r\n                            foreach (OpenXmlElement convertedElement in convertedElements)\r\n                            {\r\n                                // Insert the element\r\n                                OpenXmlElement insertedElement = convertedElement.CloneNode(true);\r\n                                sdtInsertBefore.InsertBeforeSelf(insertedElement);\r\n                                var hpElement = insertedElement.Descendants<W.Hyperlink>().FirstOrDefault();\r\n                                if (hpElement != null)\r\n                                {\r\n                                    string relationId = hpElement.Id;\r\n                                    if (relationId != string.Empty)\r\n                                    {\r\n                                        // get current relation\r\n                                        var hr = convertedDocument.MainDocumentPart.HyperlinkRelationships.FirstOrDefault(a => a.Id == relationId);\r\n                                        if (hr == null) continue;\r\n                                        var fieldName = hr.Uri.ToString();\r\n                                        \r\n                                    }\r\n                                }\r\n\r\n                                // Import its numbering from the converted document while avoid conflicts with\r\n                                // numbering IDs in the current document.\r\n                                ResetNumbering(insertedElement, convertedDocument.MainDocumentPart.NumberingDefinitionsPart, numberingIdsProcessed);\r\n\r\n                                // Copy the run properties to each run element\r\n                                if (runProperties != null)\r\n                                {\r\n                                    foreach (W.Run run in insertedElement.Descendants<W.Run>())\r\n                                    {\r\n                                        run.InsertAt<OpenXmlElement>(runProperties.CloneNode(true), 0);\r\n                                    }\r\n                                }\r\n\r\n                                // Copy the paragraph properties to the paragraph\r\n                                if (paragraphProperties != null)\r\n                                {\r\n                                    if (insertedElement is W.Paragraph)\r\n                                    {\r\n                                        // Copy the paragraph properties\r\n                                        insertedElement.InsertAt<OpenXmlElement>(paragraphProperties.CloneNode(true), 0);\r\n                                        // If the paragraph properties represent a list item, reset it\r\n                                        // in order to avoid inserting next converted paragraphs as extra list items\r\n                                        W.ParagraphStyleId paragraphStyle = ((W.ParagraphProperties)paragraphProperties).ParagraphStyleId;\r\n                                        if (paragraphStyle != null && paragraphStyle.Val == \"ListParagraph\")\r\n                                        {\r\n                                            paragraphProperties = null;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                // Add to the list of inserted elements\r\n                                insertedElements.Add(insertedElement);\r\n                            }\r\n\r\n                            // Remove the replaced element\r\n                            W.SdtBlock sdtBlock = sdtElement as W.SdtBlock;\r\n                            if (sdtBlock != null)\r\n                            {\r\n                                sdtBlock.SdtContentBlock.RemoveAllChildren();\r\n                            }\r\n                            else\r\n                            {\r\n                                // Get the tag associated with the replaced element\r\n                                W.Tag tag = sdtElement.SdtProperties.Elements<W.Tag>().FirstOrDefault();\r\n\r\n                                // Find the highest parent that contains the replaced tag (and only this one)\r\n                                OpenXmlElement sdtDelete = null;\r\n                                for (OpenXmlElement sdtCandidate = sdtElement.Parent;\r\n                                    sdtCandidate != sdtParent; \r\n                                    sdtCandidate = sdtCandidate.Parent)\r\n                                {\r\n                                    // Does the candidate contains the replaced tag and only it?\r\n                                    IEnumerable<W.Tag> tags = sdtCandidate.Descendants<W.Tag>().ToArray();\r\n                                    if (tags.Count() == 1 && tags.First() == tag)\r\n                                    {\r\n                                        // Save it for deletion\r\n                                        sdtDelete = sdtCandidate;\r\n                                        continue;\r\n                                    }\r\n\r\n                                    // Stop\r\n                                    break;\r\n                                }\r\n\r\n                                // Delete it\r\n                                if (sdtDelete != null)\r\n                                    sdtDelete.Remove();\r\n                            }\r\n                                // Stop\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                }\r\n                finally\r\n                {\r\n                    // convertedDocument.Dispose() also disposes the stream it was instantiated with (i.e. wordMLStream)\r\n                    convertedDocument.Dispose();\r\n                    wordMLStream = null;\r\n                }\r\n            }\r\n\r\n        }`\r\n\r\n\r\n**Observed**\r\n\r\nHyperlink does't work with convertedlement having w:hyperlink node\r\n\r\n**Expected**\r\n\r\nHyperlink should work post replacement in dotx file"}],"ResultType":"GitHubEvent"},"PowerTools":{"Events":[],"ResultType":"GitHubEvent"}},"RunOn":"2021-04-12T05:30:39.2558118Z","RunDurationInMilliseconds":663}