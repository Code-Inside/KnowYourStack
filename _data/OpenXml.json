{"Data":{"Sdk":{"Events":[{"Id":"46327346356","Type":"IssuesEvent","CreatedAt":"2025-02-07T07:14:33","Actor":"Yaroslav-Andrieiev-Net","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1801","RelatedDescription":"Closed issue \"Open XML SDK System.IO.IOException: \"Entries cannot be opened multiple times in Update mode\" during disposal\" (#1801) at dotnet/Open-XML-SDK","RelatedBody":"### **Describe the bug**\r\nHi everyone, we faced an issue after \"DocumentFormat.OpenXml\" migration from **2.20.0** to latest **3.1.0** (issue reproduces in versions 3.0.0 - 3.1.0).\r\nIt happens on disposal of WordprocessingDocument\r\n**Stacktrace:**\r\n`- System.IO.IOException: Entries cannot be opened multiple times in Update mode.\r\n   at System.IO.Compression.ZipArchiveEntry.OpenInUpdateMode()\r\n   at System.IO.Packaging.ZipStreamManager.Open(ZipArchiveEntry zipArchiveEntry, FileAccess streamFileAccess)\r\n   at System.IO.Packaging.ZipPackagePart.GetStreamCore(FileMode streamFileMode, FileAccess streamFileAccess)\r\n   at DocumentFormat.OpenXml.Packaging.OpenXmlPart.LoadDomTree[T]()\r\n   at DocumentFormat.OpenXml.Packaging.MainDocumentPart.get_PartRootElement()\r\n   at DocumentFormat.OpenXml.Packaging.OpenXmlPackage.SavePartContents(Boolean save)\r\n   at DocumentFormat.OpenXml.Packaging.OpenXmlPackage.Dispose(Boolean disposing)\r\n   at DocumentFormat.OpenXml.Packaging.OpenXmlPackage.Dispose()\r\n   at Edocs.Infrastructure.Services.Conversion.OpenXMLCorrector.FixSharePointFile(MemoryStream stream, IFileLoggerInfo fileLoggerInfo, String extension) `\r\n\r\n**Issue reproduces only with particular .docx file**:  [File.docx](https://github.com/user-attachments/files/17244541/File.docx)\r\n\r\n\r\n\r\n### **Code**\r\n```csharp\r\npublic void FixSharePointFile(MemoryStream stream, IFileLoggerInfo fileLoggerInfo, string extension)\r\n{\r\n    WordprocessingDocument wordDoc = null;\r\n    try\r\n    {\r\n        try\r\n        {\r\n            wordDoc = WordprocessingDocument.Open(stream, true);\r\n        }\r\n        catch (InvalidOperationException e)\r\n        {\r\n            Log.Error($\"OpenXML file open exception. CaseFileId: {fileLoggerInfo.FileId}, file name: {fileLoggerInfo.FileName}\", e);\r\n            throw new BusinessException(LocalizedString.Get(Messages.OpenXMLFileOpenError));\r\n        }\r\n\r\n        var partsAndBindings = wordDoc.MainDocumentPart.GetXMLPartsAndBindings();\r\n        var doc = wordDoc.MainDocumentPart.GetXmlDocByNamespace(EdocsConversionConstants.Myns);\r\n\r\n        if (doc is { ChildNodes.Count: > 0 })\r\n        {\r\n            var namespaceManager = new XmlNamespaceManager(doc.NameTable);\r\n            var xDoc = doc.ToXDocument();\r\n\r\n            foreach (var part in partsAndBindings)\r\n            {\r\n\r\n                foreach (var binding in part.Item2)\r\n                {\r\n                    var xpath = binding.Attribute(EdocsConversionConstants.W + \"xpath\")?.Value;\r\n\r\n                    var prefix = binding.Attribute(EdocsConversionConstants.W + \"prefixMappings\")?.Value;\r\n                    this.PrefixResolver(prefix, namespaceManager);\r\n\r\n                    if (xpath.IsNotEmpty())\r\n                    {\r\n                        var sdtPrCollection = binding.Parent?.Parent?.Descendants(EdocsConversionConstants.W + \"sdtPr\");\r\n                        var rCollection = binding.Parent?.Parent?.Descendants(EdocsConversionConstants.W + \"r\");\r\n\r\n                        if (sdtPrCollection.Any() && rCollection.Any())\r\n                        {\r\n                            var r = rCollection?.GetFirstAndRemoveOthers();\r\n\r\n                            var sdtPr = sdtPrCollection?.First();\r\n\r\n                            var rprCollection = sdtPr?.Descendants(EdocsConversionConstants.W + \"rPr\");\r\n\r\n                            if (rprCollection.Any())\r\n                            {\r\n                                var rPr = rprCollection?.First();\r\n                                var rPrRCollection = r?.Descendants(EdocsConversionConstants.W + \"rPr\");\r\n                                if (rPrRCollection.Any())\r\n                                {\r\n                                    rPrRCollection.First()?.ReplaceWith(rPr);\r\n                                }\r\n                            }\r\n\r\n                            var t = r?.Descendants(EdocsConversionConstants.W + \"t\")?.GetFirstAndRemoveOthers();\r\n\r\n                            r?.Descendants(EdocsConversionConstants.W + \"tab\")?.GetFirstAndRemoveOthers()?.Remove();\r\n                            r?.Descendants(EdocsConversionConstants.W + \"br\")?.GetFirstAndRemoveOthers()?.Remove();\r\n\r\n                            if (t != null)\r\n                            {\r\n                                var v = xDoc?.XPathSelectElement(xpath, namespaceManager)?.Value;\r\n                                if (v.IsEmpty())\r\n                                {\r\n                                    t.Remove();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                part.Item1.PutXDocument();\r\n            }\r\n        }\r\n\r\n        wordDoc?.Dispose(); // exception throwed here!\r\n\r\n        stream?.Seek(0, SeekOrigin.Begin);\r\n    }\r\n    finally\r\n    {\r\n        wordDoc?.Dispose();\r\n    }\r\n}\r\n```\r\n**Extenstion methods:**\r\n```csharp\r\npublic static List<Tuple<OpenXmlPart, IEnumerable<XElement>>> GetXMLPartsAndBindings(this MainDocumentPart mainPart)\r\n{\r\n    var partsAndBindings = new List<Tuple<OpenXmlPart, IEnumerable<XElement>>>();\r\n\r\n    foreach (var header in mainPart.HeaderParts)\r\n    {\r\n        var headerDoc = header.GetXDocument();\r\n\r\n        var headerBinding = headerDoc?.Descendants(w + \"dataBinding\");\r\n        if (headerBinding != null)\r\n        {\r\n            partsAndBindings.Add(new Tuple<OpenXmlPart, IEnumerable<XElement>>(header, headerBinding));\r\n        }\r\n    }\r\n\r\n    foreach (var footer in mainPart.FooterParts)\r\n    {\r\n        var footerDoc = footer.GetXDocument();\r\n\r\n        var footerBinding = footerDoc?.Descendants(w + \"dataBinding\");\r\n        if (footerBinding != null)\r\n        {\r\n            partsAndBindings.Add(new Tuple<OpenXmlPart, IEnumerable<XElement>>(footer, footerBinding));\r\n        }\r\n    }\r\n    var mainXml = mainPart.GetXDocument();\r\n    var bindings = mainXml?.Descendants(w + \"dataBinding\");\r\n\r\n    if (bindings != null)\r\n    {\r\n        partsAndBindings.Add(new Tuple<OpenXmlPart, IEnumerable<XElement>>(mainPart, bindings));\r\n    }\r\n\r\n    return partsAndBindings;\r\n}\r\n```\r\n```csharp\r\npublic static XmlDocument GetXmlDocByNamespace(this MainDocumentPart mainPart, string nameSpace)\r\n{\r\n    var doc = new XmlDocument();\r\n\r\n    foreach (var part in mainPart.CustomXmlParts)\r\n    {\r\n        using (var stream = part.GetStream())\r\n        {\r\n            if (stream.Length == 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            doc.Load(stream);\r\n\r\n            if (doc?.DocumentElement?.NamespaceURI == nameSpace)\r\n            {\r\n                return doc;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\n```csharp\r\npublic static XDocument ToXDocument(this XmlDocument document)\r\n {\r\n     return document.ToXDocument(LoadOptions.None);\r\n }\r\n\r\n public static XDocument ToXDocument(this XmlDocument document, LoadOptions options)\r\n {\r\n     using (var reader = new XmlNodeReader(document))\r\n     {\r\n         return XDocument.Load(reader, options);\r\n     }\r\n }\r\n```\r\n```csharp\r\n\r\n public static void PutXDocument(this OpenXmlPart part)\r\n {\r\n     var xdoc = part.GetXDocument();\r\n     xdoc.PutXDocument(part);\r\n }\r\n\r\n public static void PutXDocument(this XDocument xdoc, OpenXmlPart part)\r\n {\r\n     if (xdoc != null)\r\n     {\r\n         using (var xw =\r\n             XmlWriter.Create(part.GetStream\r\n                 (FileMode.Create, FileAccess.Write)))\r\n         {\r\n             xdoc.Save(xw);\r\n         }\r\n     }\r\n }\r\n```\r\nThanks in advance for any assistance!\r\n "},{"Id":"46250759651","Type":"IssuesEvent","CreatedAt":"2025-02-05T10:50:44","Actor":"ChandrasekarML","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1867","RelatedDescription":"Opened issue \"AcceptAllChanges word document Open XML SDK\" (#1867) at dotnet/Open-XML-SDK","RelatedBody":"It seems like you're trying to read and accept all changes in a Word document using C#. However, you're facing an issue where the MoveTo method is not properly cloning the data. Kindly help me.\n\nPlease find below a sample code for AcceptAll changes:\n\nprivate void AcceptAllChanges(string filePath)\n{\n    using (WordprocessingDocument doc = WordprocessingDocument.Open(filePath, true))\n    {\n        var body = doc.MainDocumentPart.Document.Body;\n\n        // Accept Inserted text (InsertedRun elements)\n        var insertedRuns = body.Descendants<InsertedRun>().ToList();\n        foreach (var insertedRun in insertedRuns)\n        {\n            var parent = insertedRun.Parent;\n            foreach (var child in insertedRun.ChildElements.ToList())\n            {\n                parent.InsertBefore(child.CloneNode(true), insertedRun);\n            }\n            insertedRun.Remove();\n        }\n\n        // Remove Deleted text (DeletedRun elements)\n        var deletedRuns = body.Descendants<DeletedRun>().ToList();\n        foreach (var deletedRun in deletedRuns)\n        {\n            deletedRun.Remove();\n        }\n\n        // Remove MoveFrom and MoveTo elements\n        var moveFromElements = body.Descendants<MoveFrom>().ToList();\n        var moveToElements = body.Descendants<MoveTo>().ToList();\n\n        foreach (var moveFrom in moveFromElements)\n        {\n            moveFrom.Remove();\n        }\n\n        //foreach (var moveTo in moveToElements)\n        //{\n        //    var parent = moveTo.Parent;\n        //    foreach (var child in moveTo.ChildElements.ToList())\n        //    {\n        //        parent.InsertBefore(child.CloneNode(true), moveTo);\n        //    }\n        //    moveTo.Remove();\n        //}\n        foreach (var moveTo in moveToElements)\n        {\n            // Iterate over the Run elements inside MoveTo\n            foreach (var run in moveTo.Elements<Run>())\n            {\n                // Now iterate over the Text elements inside each Run\n                foreach (var text in run.Elements<Text>())\n                {\n                    // Append the text content from MoveTo elements\n                    //sb.Append(text.Text);\n                    Console.WriteLine($\"Moved Insertion Text: {text.Text}\");  // For debugging\n                }\n            }\n\n            // Optional: If you want to move the content out of MoveTo and remove the MoveTo element\n            var parent = moveTo.Parent;\n            foreach (var run in moveTo.Elements<Run>())\n            {\n                foreach (var child in run.ChildElements)\n                {\n                    parent.InsertBefore(child.CloneNode(true), moveTo); // Insert content before the MoveTo element\n                }\n            }\n            moveTo.Remove(); // Remove the MoveTo element itself\n        }\n\n        // Remove other tracked changes (paragraph properties, table properties, etc.)\n        var pPrChanges = body.Descendants<ParagraphPropertiesChange>().ToList();\n        foreach (var pPrChange in pPrChanges)\n        {\n            pPrChange.Remove();\n        }\n\n        var tblPrChanges = body.Descendants<TablePropertiesChange>().ToList();\n        foreach (var tblPrChange in tblPrChanges)\n        {\n            tblPrChange.Remove();\n        }\n\n        // Save the changes\n        doc.MainDocumentPart.Document.Save();\n    }\n}"},{"Id":"46229467341","Type":"PullRequestEvent","CreatedAt":"2025-02-04T20:24:00","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1863","RelatedDescription":"Merged pull request \"Optimize ToFlatOpcString to reduce memory usage and improve performan…\" (#1863) at dotnet/Open-XML-SDK","RelatedBody":"## Optimized the ToFlatOpcString method to address high memory usage and improve performance. \r\n\r\nThe previous implementation relied on LINQ, which created a significant amount of intermediate collections and dictionaries, leading to inefficiency, especially when working with Word documents containing images. \r\n\r\nThis update removes unnecessary LINQ operations and reduces memory overhead, replace manual chunking logic with Convert.ToBase64String using Base64FormattingOptions.InsertLineBreaks. \r\n\r\nThis approach eliminates the need for LINQ-based chunking and aggregation, resulting in cleaner, more efficient code while adhering to the MIME specification for line breaks in Base64 encoding.\r\n\r\nA sample benchmark output when working with a 822KB-word document.\r\n\r\n![image](https://github.com/user-attachments/assets/3efadb6b-9f0f-41d5-9e8d-9992d0296469)\r\n"}],"ResultType":"GitHubEvent"}},"RunOn":"2025-02-08T03:30:21.8446223Z","RunDurationInMilliseconds":694}