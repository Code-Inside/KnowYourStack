{"Data":{"Sdk":{"Events":[{"Id":"50853219800","Type":"IssuesEvent","CreatedAt":"2025-06-13T04:41:38","Actor":"pratap10","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1937","RelatedDescription":"Opened issue \"Bug with Open XML SDK\" (#1937) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\nImproper Handling of Indentation and Hierarchy in Word Document Extraction Using Open XML\n**Screenshots**\n\n<!-- Failed to upload \"SnipImage.JPG\" -->\n\n**To Reproduce**\nbelow is the code i am using \n private static string ConvertParagraphToHtml(WordprocessingDocument doc, Paragraph paragraph)\n {\n     StringBuilder paraHtml = new StringBuilder();\n     bool inBold = false;\n     const float PointsPerInch = 72.0f;\n     const float TabWidthInInches = 0.5f;\n     const int TwipsPerPoint = 20; // 1 point = 20 twips\n     const string TabRepresentation = \"<t>\"; // Use <t> to represent a tab in HTML\n\n     string paragraphText = GetParagraphText(paragraph).TrimEnd('\\r', '\\n');\n     if (string.IsNullOrEmpty(paragraphText))\n     {\n         return \"\";\n     }\n\n     // Handle initial tabs before numbering\n     StringBuilder preNumberingTabs = new StringBuilder();\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         if (run.Elements<TabChar>().Any())\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n         else\n         {\n             // Stop collecting tabs once we hit non-tab content\n             if (!string.IsNullOrEmpty(run.InnerText))\n                 break;\n         }\n     }\n\n     // Handle indentation\n     ParagraphProperties paraProps = paragraph.GetFirstChild<ParagraphProperties>();\n     Indentation indentation = paraProps?.GetFirstChild<Indentation>();\n\n     float leftIndentPoints = indentation?.Left != null && int.TryParse(indentation.Left, out int leftTwips)\n         ? leftTwips / (float)TwipsPerPoint : 0f;\n     float firstLineIndentPoints = indentation?.FirstLine != null && int.TryParse(indentation.FirstLine, out int firstLineTwips)\n         ? firstLineTwips / (float)TwipsPerPoint : 0f;\n     float rightIndentPoints = indentation?.Right != null && int.TryParse(indentation.Right, out int rightTwips)\n         ? rightTwips / (float)TwipsPerPoint : 0f;\n\n     float leftIndentInches = leftIndentPoints / PointsPerInch;\n     if (leftIndentInches > 0)\n     {\n         var loopTimes = (int)(leftIndentInches / TabWidthInInches);\n         for (int i = 0; i < loopTimes; i++)\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n     }\n\n     // Append pre-numbering tabs and indentation\n     paraHtml.Append(preNumberingTabs.ToString());\n\n     // Handle list numbering\n     string listPrefix = \"\";\n     var numberingProperties = paragraph.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n     var numberingId = numberingProperties?.NumberingId?.Val?.Value;\n     var numberingLevel = numberingProperties?.NumberingLevelReference?.Val?.Value ?? 0;\n\n     if (numberingProperties != null && numberingId.HasValue)\n     {\n         try\n         {\n             var numberingPart = doc.MainDocumentPart?.NumberingDefinitionsPart;\n             var numbering = numberingPart?.Numbering;\n             var abstractNumId = numbering?.Elements<NumberingInstance>()\n                 .FirstOrDefault(n => n.NumberID?.Value == numberingId)?.AbstractNumId?.Val?.Value;\n             var abstractNum = numbering?.Elements<AbstractNum>()\n                 .FirstOrDefault(n => n.AbstractNumberId?.Value == abstractNumId);\n             var level = abstractNum?.Elements<Level>().FirstOrDefault(l => l.LevelIndex?.Value == numberingLevel);\n             if (level != null)\n             {\n                 int listItemCount = 0;\n                 var paragraphs = doc.MainDocumentPart?.Document.Body.Elements<Paragraph>();\n                 if (paragraphs != null)\n                 {\n                     foreach (var p in paragraphs)\n                     {\n                         var np = p.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n                         var pNumId = np?.NumberingId?.Val?.Value;\n                         var pLevel = np?.NumberingLevelReference?.Val?.Value ?? 0;\n                         if (pNumId == numberingId && pLevel == numberingLevel)\n                         {\n                             listItemCount++;\n                             if (p == paragraph)\n                                 break;\n                         }\n                     }\n                 }\n\n                 string listNumber = listItemCount.ToString();\n                 var numberFormatMap = new Dictionary<NumberFormatValues, string>\n         {\n             { NumberFormatValues.Decimal, \"decimal\" },\n             { NumberFormatValues.LowerLetter, \"lowerletter\" },\n             { NumberFormatValues.UpperLetter, \"upperletter\" },\n             { NumberFormatValues.LowerRoman, \"lowerroman\" },\n             { NumberFormatValues.UpperRoman, \"upperroman\" },\n             { NumberFormatValues.Bullet, \"bullet\" }\n         };\n                 var numberStyle = numberFormatMap.TryGetValue(level.NumberingFormat?.Val?.Value ?? NumberFormatValues.Decimal, out var style)\n                     ? style\n                     : \"decimal\";\n                 switch (numberStyle.ToLower())\n                 {\n                     case \"lowerletter\":\n                         listNumber = ((char)('a' + listItemCount - 1)).ToString();\n                         break;\n                     case \"upperletter\":\n                         listNumber = ((char)('A' + listItemCount - 1)).ToString();\n                         break;\n                     case \"lowerroman\":\n                         listNumber = ToRoman(listItemCount).ToLower();\n                         break;\n                     case \"upperroman\":\n                         listNumber = ToRoman(listItemCount).ToUpper();\n                         break;\n                     case \"bullet\":\n                         listNumber = level.LevelText?.Val?.Value ?? \"â€¢\";\n                         break;\n                     default:\n                         listNumber = listItemCount.ToString(); // Decimal\n                         break;\n                 }\n\n                 string numberFormat = level.LevelText?.Val?.Value ?? \"%1.\";\n                 listPrefix = numberFormat.Replace(\"%1\", listNumber);\n                 // Add tab after number if not a bullet\n                 if (numberStyle.ToLower() != \"bullet\")\n                 {\n                     listPrefix += TabRepresentation;\n                 }\n             }\n         }\n         catch (Exception ex)\n         {\n             Console.WriteLine($\"Error processing list numbering: {ex.Message}\");\n             listPrefix = \"\"; // Fallback to empty prefix\n         }\n     }\n\n     // Append list prefix after tabs and indentation\n     paraHtml.Append(listPrefix);\n\n     // Process runs for bold formatting, text, and tabs\n     bool numberProcessed = string.IsNullOrEmpty(listPrefix); // Skip runs until numbering is processed\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         // Skip runs that are part of numbering if listPrefix was generated\n         if (!numberProcessed && run.InnerText == listPrefix.TrimEnd(TabRepresentation.ToCharArray()))\n         {\n             numberProcessed = true;\n             continue;\n         }\n\n         // Handle tab elements\n         if (run.Elements<TabChar>().Any())\n         {\n             paraHtml.Append(TabRepresentation);\n             continue;\n         }\n\n         string runText = run.InnerText ?? \"\";\n         bool isRunBold = run.RunProperties?.Bold != null;\n\n         if (string.IsNullOrEmpty(runText))\n             continue;\n\n         if (runText == \"\\n\")\n         {\n             paraHtml.Append(\"\\n\");\n         }\n         else if (runText == \"\\t\")\n         {\n             paraHtml.Append(TabRepresentation);\n         }\n         else\n         {\n             if (isRunBold && !inBold)\n             {\n                 paraHtml.Append(\"<b>\");\n                 inBold = true;\n             }\n             else if (!isRunBold && inBold)\n             {\n                 paraHtml.Append(\"</b>\");\n                 inBold = false;\n             }\n             paraHtml.Append(runText);\n         }\n     }\n\n     if (inBold)\n     {\n         paraHtml.Append(\"</b>\");\n     }\n\n     // Clean up HTML\n     paraHtml.Replace(\"{\", \"[\");\n     paraHtml.Replace(\"}\", \"]\");\n     paraHtml.Replace(\"<b>\\r</b>\", \"\");\n     paraHtml.Replace(\"\\r</b>\", \"</b>\");\n     paraHtml.Replace(\"\\r\", \"\");\n     paraHtml.Replace(\"<b></b>\", \"\");\n     paraHtml.Replace(\"<t>. <t>\", \".<t>\");\n     paraHtml.Replace(\"<t>.<t>\", \".<t>\");\n     paraHtml.Replace(\"(<t>\", \"(\");\n     paraHtml.Replace(\" <t>\", TabRepresentation); // Preserve tabs\n\n     Console.WriteLine($\"Converted HTML: {paraHtml.ToString()}\");\n     return paraHtml.ToString();\n }\n       .\n\n\n**Observed behavior**\nindentation mismatched\n\n**Expected behavior**\nI want indentation to display as per the source document \n\n**Desktop (please complete the following information):**\n - OS: [e.g. Windows]\n - Office version [e.g. 16.0.15427.20178]\n - .NET Target: 4.6.3\n - DocumentFormat.OpenXml Version: (e.g. 3.3..00)\n\n**Additional context**\nAdd any other context about the problem here.\n i dont have permisison to add files here"},{"Id":"50773833942","Type":"PullRequestEvent","CreatedAt":"2025-06-11T12:56:31","Actor":"mkaszewiak","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1936","RelatedDescription":"Opened pull request \"CreateElement calls now 3 parameter constructor of UnknownOpenXmlElement\" (#1936) at dotnet/Open-XML-SDK","RelatedBody":"Fixes #1933 "},{"Id":"50693142433","Type":"IssuesEvent","CreatedAt":"2025-06-09T20:27:26","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1925","RelatedDescription":"Closed issue \"Keep original data type when creating a CellValue instead of converting to string to save memory.\" (#1925) at dotnet/Open-XML-SDK","RelatedBody":"**Is your feature request related to a problem? Please describe.**\nWhen writing millions of cells to a sheet the memory usage is very high.\n\n**Describe the solution you'd like**\nCurrently `CellValue` converts all values added to strings. \nFor example:\n```\npublic CellValue(int value)\n   : this(value.ToString(CultureInfo.InvariantCulture))\n{\n}\n```\nWould it not make more sense to add (keep) the `int` (or whatever native type is being added) and write that to the `XmlWriter` when serializing the data to reduce the memory footprint?\n\n"}],"ResultType":"GitHubEvent"}},"RunOn":"2025-06-17T03:30:21.8425051Z","RunDurationInMilliseconds":507}