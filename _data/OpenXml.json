{"Data":{"Sdk":{"Events":[{"Id":"13304153855","Type":"PullRequestEvent","CreatedAt":"2020-08-25T16:29:49","Actor":"twsouthwick","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/794","RelatedDescription":"Merged pull request \"Add copy constructor for OpenSettings\" (#794) at OfficeDev/Open-XML-SDK","RelatedBody":""},{"Id":"13294181740","Type":"IssuesEvent","CreatedAt":"2020-08-24T22:12:12","Actor":"hypnopotamus","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/795","RelatedDescription":"Opened issue \"Can't Create Lists in the NumberingDefinitionsPart as expected\" (#795) at OfficeDev/Open-XML-SDK","RelatedBody":"Is this a:\r\n- [ X ] Issue with the OpenXml library\r\n- [ maybe? ] Question on library usage\r\n\r\n**Description**\r\n\r\nWhen trying to create paragraphs in a list allowing the Numbering instance that contains the numbering definitions fails produce listed output in the document file if it is referenced by the NumberingDefinitionsPart.Numbering property\r\n\r\n**Information**\r\n\r\n- .NET Target: .NET Core 3.1\r\n- DocumentFormat.OpenXml Version: 2.11.3\r\n\r\n**Repro**\r\n\r\n```csharp\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing DocumentFormat.OpenXml;\r\nusing DocumentFormat.OpenXml.Packaging;\r\nusing DocumentFormat.OpenXml.Wordprocessing;\r\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\r\n\r\nnamespace OpenXmlNumberingPartBusted\r\n{\r\n    [TestClass]\r\n    [TestCategory(\"Integration\")]\r\n    public class OpenXmlNumberingPartTests\r\n    {\r\n        private static IEnumerable<object[]> Factories => new[]\r\n        {\r\n            new object[] { new NumberingFactoryExpectedToWork() }, //will pass unit tests but produces documents without lists\r\n            new object[] { new NumberingFactoryWorkaround() } //will produce documents with numbered lists but will not pass tests\r\n        };\r\n\r\n        [TestMethod]\r\n        [DynamicData(nameof(Factories))]\r\n        public void CreateADocument_WithNumberingParts_PartsComeOutNumbered(INumberingFactory numberingFactory)\r\n        {\r\n            var fileLocation = $\"./TestResults/{Guid.NewGuid()}.docx\"; // Using a real file instead of a memory stream so that the actual output can be inspected\r\n            using var document = WordprocessingDocument.Create(fileLocation, WordprocessingDocumentType.Document);\r\n            var mainPart = document.AddMainDocumentPart();\r\n            mainPart.Document = new Document();\r\n            mainPart.Document.AppendChild(new Body());\r\n\r\n            var numbering1 = numberingFactory.CreateNewNumberingSequence(document);\r\n            var paragraph = document.MainDocumentPart.Document.Body.AppendChild(new Paragraph());\r\n            var properties = paragraph.ParagraphProperties ??= new ParagraphProperties();\r\n            properties.AppendChild(numbering1.CloneNode(true));\r\n            paragraph.AppendChild(new Run(new Text(\"1\")));\r\n            paragraph = document.MainDocumentPart.Document.Body.AppendChild(new Paragraph());\r\n            properties = paragraph.ParagraphProperties ??= new ParagraphProperties();\r\n            properties.AppendChild(numbering1.CloneNode(true));\r\n            paragraph.AppendChild(new Run(new Text(\"2\")));\r\n\r\n            var numbering2 = numberingFactory.CreateNewNumberingSequence(document);\r\n            paragraph = document.MainDocumentPart.Document.Body.AppendChild(new Paragraph());\r\n            properties = paragraph.ParagraphProperties ??= new ParagraphProperties();\r\n            properties.AppendChild(numbering2.CloneNode(true));\r\n            paragraph.AppendChild(new Run(new Text(\"one\")));\r\n            paragraph = document.MainDocumentPart.Document.Body.AppendChild(new Paragraph());\r\n            properties = paragraph.ParagraphProperties ??= new ParagraphProperties();\r\n            properties.AppendChild(numbering2.CloneNode(true));\r\n            paragraph.AppendChild(new Run(new Text(\"two\")));\r\n\r\n            document.Save();\r\n            Console.WriteLine(fileLocation);\r\n            document.Close();\r\n            // Even when saved to disk and restored one method passes unit tests but does not produce numbers on the list and one produces numbers on the list but fails the test.\r\n            using var saveDocument = WordprocessingDocument.Open(fileLocation, false);\r\n            Assert.AreEqual(2, saveDocument.MainDocumentPart.NumberingDefinitionsPart.Numbering.Descendants<AbstractNum>().Count());\r\n            Assert.AreEqual(2, saveDocument.MainDocumentPart.NumberingDefinitionsPart.Numbering.Descendants<NumberingInstance>().Count());\r\n        }\r\n\r\n        public interface INumberingFactory\r\n        {\r\n            NumberingProperties CreateNewNumberingSequence(WordprocessingDocument document);\r\n        }\r\n\r\n        private class NumberingFactoryExpectedToWork : INumberingFactory\r\n        {\r\n            public NumberingProperties CreateNewNumberingSequence(WordprocessingDocument document)\r\n            {\r\n                var definitions = document.MainDocumentPart.NumberingDefinitionsPart ??\r\n                                  document.MainDocumentPart.AddNewPart<NumberingDefinitionsPart>();\r\n                var numbering = definitions.Numbering ??= new Numbering(); // The property should be initialized since it is the root of the part.  Not that big a deal though.\r\n\r\n                var baseNumbering = numbering.AppendChild\r\n                (\r\n                    new AbstractNum\r\n                    (\r\n                        new Level\r\n                        {\r\n                            NumberingFormat = new NumberingFormat\r\n                            {\r\n                                Val = NumberFormatValues.Decimal\r\n                            },\r\n                            LevelIndex = 0\r\n                        }\r\n                    )\r\n                    {\r\n                        AbstractNumberId = numbering\r\n                            .Descendants<AbstractNum>()\r\n                            .Select<AbstractNum, int>(an => an.AbstractNumberId)\r\n                            .DefaultIfEmpty(0)\r\n                            .Max() + 1,\r\n                        MultiLevelType = new MultiLevelType {Val = MultiLevelValues.SingleLevel},\r\n                    }\r\n                );\r\n                var numberingInstance = numbering.AppendChild\r\n                (\r\n                    new NumberingInstance\r\n                    {\r\n                        NumberID = numbering\r\n                            .Descendants<NumberingInstance>()\r\n                            .Select<NumberingInstance, int>(an => an.NumberID)\r\n                            .DefaultIfEmpty(0)\r\n                            .Max() + 1,\r\n                        AbstractNumId = new AbstractNumId {Val = baseNumbering.AbstractNumberId}\r\n                    }\r\n                );\r\n\r\n                // It doesn't make a difference if it gets saved or not.\r\n                // If the instance of Numbering is associated with the Numbering property of the part the resulting document will not be numbered.\r\n                //numbering.Save(definitions);\r\n\r\n                return new NumberingProperties\r\n                {\r\n                    NumberingId = new NumberingId { Val = numberingInstance.NumberID },\r\n                    NumberingLevelReference = new NumberingLevelReference { Val = 0 }\r\n                };\r\n            }\r\n        }\r\n\r\n        private class NumberingFactoryWorkaround : INumberingFactory\r\n        {\r\n            //save the numbering instance away from the part so that it can be repeatedly saved with more elements\r\n            private readonly Numbering _numbering = new Numbering();\r\n\r\n            public NumberingProperties CreateNewNumberingSequence(WordprocessingDocument document)\r\n            {\r\n                // The numbering part API does not work correctly.\r\n                // Any Numbering instance that becomes associated with the part as its property does not produce numbering in the final document\r\n\r\n                var definitions = document.MainDocumentPart.NumberingDefinitionsPart ??\r\n                                  document.MainDocumentPart.AddNewPart<NumberingDefinitionsPart>();\r\n                definitions.Numbering ??= new Numbering(); // The property must be accessed but cannot be used.  It is null even on a new instance where this is the root part.\r\n                // Using Numbering.Load produces the same result.\r\n\r\n                var baseNumbering = new AbstractNum\r\n                (\r\n                    new Level\r\n                    {\r\n                        NumberingFormat = new NumberingFormat\r\n                        {\r\n                            Val = NumberFormatValues.Decimal\r\n                        },\r\n                        LevelIndex = 0\r\n                    }\r\n                )\r\n                {\r\n                    AbstractNumberId = _numbering\r\n                        .Descendants<AbstractNum>()\r\n                        .Select<AbstractNum, int>(an => an.AbstractNumberId)\r\n                        .DefaultIfEmpty(0)\r\n                        .Max() + 1,\r\n                    MultiLevelType = new MultiLevelType {Val = MultiLevelValues.SingleLevel},\r\n                };\r\n                var numberingInstance = new NumberingInstance\r\n                {\r\n                    NumberID = _numbering\r\n                        .Descendants<NumberingInstance>()\r\n                        .Select<NumberingInstance, int>(an => an.NumberID)\r\n                        .DefaultIfEmpty(0)\r\n                        .Max() + 1,\r\n                    AbstractNumId = new AbstractNumId {Val = baseNumbering.AbstractNumberId}\r\n                };\r\n\r\n                _numbering.AppendChild(baseNumbering);\r\n                _numbering.AppendChild(numberingInstance);\r\n                _numbering.Save(definitions);\r\n                // Assigning a new Numbering to the property has the same result as using one accessed from the property, even if it was saved first.\r\n\r\n                return new NumberingProperties\r\n                {\r\n                    NumberingId = new NumberingId {Val = numberingInstance.NumberID},\r\n                    NumberingLevelReference = new NumberingLevelReference {Val = 0}\r\n                };\r\n            }\r\n        }\r\n    }\r\n}\r\n``` \r\nhttps://github.com/hypnopotamus/OpenXmlNumberingPartBusted\r\n\r\n**Observed**\r\n\r\nIt doesn't seem to matter what else happens, if the Numbering instance is references as the root element (in the Numbering property) of the NumberingDefinitionsPart of the document then the output will not be displayed in a list.  Creating a new Numbering with child elements and calling it's Save method with the NumberingDefinitionsPart as a parameter will produce listed output in the document, so long as that Numbering instance is not referenced by the part's property.  Creating a new Numbering instance and calling Load with the part as a parameter produces the same result, child elements of that Numbering will not be reflected in the final document output.\r\n\r\nCreating numbering definitions using the workaround does not allow those definitions to be inspected through the document, they must be held outside the document (e.g. adding additional numberings after the first, unit testing)\r\n\r\n**Expected**\r\n\r\nThe Numbering property of NumberingDefinitionsPart should have a reference to a valid element after being created and adding valid child elements to it then using the NumberingID on a paragraph's properties, should produce a listed output in the document and should be visible in the in-memory representation of the document.\r\n"},{"Id":"13293959031","Type":"PullRequestEvent","CreatedAt":"2020-08-24T21:46:10","Actor":"twsouthwick","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/794","RelatedDescription":"Opened pull request \"Add copy constructor for OpenSettings\" (#794) at OfficeDev/Open-XML-SDK","RelatedBody":""}],"ResultType":"GitHubEvent"},"PowerTools":{"Events":[],"ResultType":"GitHubEvent"}},"RunOn":"2020-08-27T05:30:41.4260182Z","RunDurationInMilliseconds":1005}