{"Data":{"Sdk":{"Events":[{"Id":"4009970788","Type":"IssuesEvent","CreatedAt":"2025-10-13T16:07:01","Actor":"mkaszewiak","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"assigned","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1966","RelatedDescription":null,"RelatedBody":"Can someone provide an example?\n\nthanks\n\nThe current approach is to save the original document as a new file, delete all the body content, place the relevant XML into the paragraph, and generate a new document. However, there is some error.\n```csharp\nopenXmlElement2 is DocumentFormat.OpenXml.Wordprocessing.Run\n<w:r> <w:drawing> <wp:inline>\n\nDocumentFormat.OpenXml.Wordprocessing.Paragraph paragraph6 = new DocumentFormat.OpenXml.Wordprocessing.Paragraph();\nforeach (OpenXmlElement element in openXmlElement1.Elements<DocumentFormat.OpenXml.Wordprocessing.ParagraphProperties>())\n{\n    OpenXmlElement newChild6 = element.CloneNode(true);\n    newChild6.RemoveAllChildren<SectionProperties>();\n    newChild6.RemoveAllChildren<ParagraphBorders>();\n    paragraph6.AppendChild<OpenXmlElement>(newChild6);\n}\nparagraph6.AppendChild<OpenXmlElement>(openXmlElement2.CloneNode(true));\ntableXmlElementList.Add(openXmlElement2);\ntablebody2.AppendChild<OpenXmlElement>(paragraph6.CloneNode(true));\n\nusing (WordprocessingDocument wordprocessingDocument2 = WordprocessingDocument.Open(temp1, true))\n{\n    Body body1 = wordprocessingDocument2.MainDocumentPart.Document.Body;\n\n    OpenXmlElement newChild11 = body1.Elements<SectionProperties>().FirstOrDefault<SectionProperties>().CloneNode(true);\n    newChild11.RemoveAllChildren<FooterReference>();\n    newChild11.RemoveAllChildren<HeaderReference>();\n    IEnumerable<PageMargin> source = newChild11.Descendants<PageMargin>();\n    if (source.Count<PageMargin>() > 0)\n        source.FirstOrDefault<PageMargin>().Bottom = (Int32Value)1710;\n    else\n        newChild11.Append((OpenXmlElement)new PageMargin()\n        {\n            Bottom = (Int32Value)1710\n        });\n    mathbody.AppendChild<OpenXmlElement>(newChild11);\n    wordprocessingDocument2.MainDocumentPart.Document.RemoveAllChildren<Body>();\n    wordprocessingDocument2.MainDocumentPart.Document.RemoveAllChildren<DocumentBackground>();\n    wordprocessingDocument2.MainDocumentPart.Document.Append((OpenXmlElement)mathbody);\n    wordprocessingDocument2.Save();\n}\n```\n=========================================\n```xml\n-<w:drawing>\n\n\n-<wp:inline wp14:editId=\"7BB75690\" wp14:anchorId=\"3EDB3CC6\" distR=\"0\" distL=\"0\" distB=\"0\" distT=\"0\">\n\n<wp:extent cx=\"3960000\" cy=\"2412000\"/>\n\n<wp:effectExtent r=\"2540\" b=\"7620\" t=\"0\" l=\"0\"/>\n\n\n-<wp:docPr name=\"图表 1\" id=\"6\">\n\n\n-<a:extLst xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">\n\n\n-<a:ext uri=\"{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}\">\n\n<a16:creationId id=\"{05A109B0-8715-5C68-1F51-FAAAA0F641B6}\" xmlns:a16=\"http://schemas.microsoft.com/office/drawing/2014/main\"/>\n\n</a:ext>\n\n</a:extLst>\n\n</wp:docPr>\n\n<wp:cNvGraphicFramePr/>\n\n\n-<a:graphic xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">\n\n\n-<a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/chart\">\n\n<c:chart xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:id=\"rId4\" xmlns:c=\"http://schemas.openxmlformats.org/drawingml/2006/chart\"/>\n\n</a:graphicData>\n\n</a:graphic>\n\n</wp:inline>\n\n</w:drawing>\n```"},{"Id":"4001558512","Type":"IssuesEvent","CreatedAt":"2025-10-13T09:36:10","Actor":"billpeace","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1966","RelatedDescription":"Opened issue \"how to copy  <w:drawing> <wp:inline  to other docx？\" (#1966) at dotnet/Open-XML-SDK","RelatedBody":"Can someone provide an example?\n\nthanks\n\nThe current approach is to save the original document as a new file, delete all the body content, place the relevant XML into the paragraph, and generate a new document. However, there is some error.\n```csharp\nopenXmlElement2 is DocumentFormat.OpenXml.Wordprocessing.Run\n<w:r> <w:drawing> <wp:inline>\n\nDocumentFormat.OpenXml.Wordprocessing.Paragraph paragraph6 = new DocumentFormat.OpenXml.Wordprocessing.Paragraph();\nforeach (OpenXmlElement element in openXmlElement1.Elements<DocumentFormat.OpenXml.Wordprocessing.ParagraphProperties>())\n{\n    OpenXmlElement newChild6 = element.CloneNode(true);\n    newChild6.RemoveAllChildren<SectionProperties>();\n    newChild6.RemoveAllChildren<ParagraphBorders>();\n    paragraph6.AppendChild<OpenXmlElement>(newChild6);\n}\nparagraph6.AppendChild<OpenXmlElement>(openXmlElement2.CloneNode(true));\ntableXmlElementList.Add(openXmlElement2);\ntablebody2.AppendChild<OpenXmlElement>(paragraph6.CloneNode(true));\n\nusing (WordprocessingDocument wordprocessingDocument2 = WordprocessingDocument.Open(temp1, true))\n{\n    Body body1 = wordprocessingDocument2.MainDocumentPart.Document.Body;\n\n    OpenXmlElement newChild11 = body1.Elements<SectionProperties>().FirstOrDefault<SectionProperties>().CloneNode(true);\n    newChild11.RemoveAllChildren<FooterReference>();\n    newChild11.RemoveAllChildren<HeaderReference>();\n    IEnumerable<PageMargin> source = newChild11.Descendants<PageMargin>();\n    if (source.Count<PageMargin>() > 0)\n        source.FirstOrDefault<PageMargin>().Bottom = (Int32Value)1710;\n    else\n        newChild11.Append((OpenXmlElement)new PageMargin()\n        {\n            Bottom = (Int32Value)1710\n        });\n    mathbody.AppendChild<OpenXmlElement>(newChild11);\n    wordprocessingDocument2.MainDocumentPart.Document.RemoveAllChildren<Body>();\n    wordprocessingDocument2.MainDocumentPart.Document.RemoveAllChildren<DocumentBackground>();\n    wordprocessingDocument2.MainDocumentPart.Document.Append((OpenXmlElement)mathbody);\n    wordprocessingDocument2.Save();\n}\n```\n=========================================\n```xml\n-<w:drawing>\n\n\n-<wp:inline wp14:editId=\"7BB75690\" wp14:anchorId=\"3EDB3CC6\" distR=\"0\" distL=\"0\" distB=\"0\" distT=\"0\">\n\n<wp:extent cx=\"3960000\" cy=\"2412000\"/>\n\n<wp:effectExtent r=\"2540\" b=\"7620\" t=\"0\" l=\"0\"/>\n\n\n-<wp:docPr name=\"图表 1\" id=\"6\">\n\n\n-<a:extLst xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">\n\n\n-<a:ext uri=\"{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}\">\n\n<a16:creationId id=\"{05A109B0-8715-5C68-1F51-FAAAA0F641B6}\" xmlns:a16=\"http://schemas.microsoft.com/office/drawing/2014/main\"/>\n\n</a:ext>\n\n</a:extLst>\n\n</wp:docPr>\n\n<wp:cNvGraphicFramePr/>\n\n\n-<a:graphic xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">\n\n\n-<a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/chart\">\n\n<c:chart xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:id=\"rId4\" xmlns:c=\"http://schemas.openxmlformats.org/drawingml/2006/chart\"/>\n\n</a:graphicData>\n\n</a:graphic>\n\n</wp:inline>\n\n</w:drawing>\n```"},{"Id":"3744928074","Type":"IssuesEvent","CreatedAt":"2025-09-29T16:48:25","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1965","RelatedDescription":"Opened issue \"Use specialized URI type for package spec that is more relaxed than System.Uri\" (#1965) at dotnet/Open-XML-SDK","RelatedBody":"**Is your feature request related to a problem? Please describe.**\nThe current Uri usage in the System.IO.Packaging is very strict to the official RFC, but appears to be too strict for what Office documents can have\n\n**Describe the solution you'd like**\nWe should have a generalized type (i.e. `OpenXmlUri`) that will easily convert to System.Uri or string representations.\n\n**Describe alternatives you've considered**\nThere are a few attempts at handling this, most recently, this:\n\nhttps://github.com/dotnet/Open-XML-SDK/blob/307fa23e7f92222230216bb73a756022b8104046/src/DocumentFormat.OpenXml.Framework/Packaging/PackageUriHandlingExtensions.cs#L228-L241\n\nIt may be useful to start with.\n\nTODO:\n\n- [x] Find where in the spec the Uri type is defined for the packaging spec"}],"ResultType":"GitHubEvent"}},"RunOn":"2025-10-20T03:30:24.048976Z","RunDurationInMilliseconds":716}