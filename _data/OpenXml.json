{"Data":{"Sdk":{"Events":[{"Id":"16144916488","Type":"PullRequestEvent","CreatedAt":"2021-04-29T22:26:26","Actor":"twsouthwick","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/928","RelatedDescription":null,"RelatedBody":""},{"Id":"16144916264","Type":"PullRequestEvent","CreatedAt":"2021-04-29T22:26:24","Actor":"twsouthwick","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/928","RelatedDescription":"Closed pull request \"Add commentsids part to maindocumentpart relationship\" (#928) at OfficeDev/Open-XML-SDK","RelatedBody":""},{"Id":"16144908836","Type":"PullRequestEvent","CreatedAt":"2021-04-29T22:25:37","Actor":"twsouthwick","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/924","RelatedDescription":null,"RelatedBody":"If a document happened to have a large number of elements that have the\r\nUniqueAttributeValueConstraint validation, it will end up recalculating\r\nthe values for the constraint way too often. This was because the\r\nconstraint was generating the cached lookup with a key using the\r\nattribute text itself. This change updates the lookup to cache all\r\npossible duplicates for the element in question so it only has to be\r\nsearched once.\r\n\r\nFixes #918 "},{"Id":"16144908557","Type":"PullRequestEvent","CreatedAt":"2021-04-29T22:25:35","Actor":"twsouthwick","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/924","RelatedDescription":"Closed pull request \"Cache search better in UniqueAttributeValueConstraint\" (#924) at OfficeDev/Open-XML-SDK","RelatedBody":"If a document happened to have a large number of elements that have the\r\nUniqueAttributeValueConstraint validation, it will end up recalculating\r\nthe values for the constraint way too often. This was because the\r\nconstraint was generating the cached lookup with a key using the\r\nattribute text itself. This change updates the lookup to cache all\r\npossible duplicates for the element in question so it only has to be\r\nsearched once.\r\n\r\nFixes #918 "},{"Id":"16114114184","Type":"PullRequestEvent","CreatedAt":"2021-04-28T03:57:57","Actor":"tomjebo","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/928","RelatedDescription":"Opened pull request \"Add commentsids part to maindocumentpart relationship\" (#928) at OfficeDev/Open-XML-SDK","RelatedBody":""},{"Id":"16111944414","Type":"PullRequestEvent","CreatedAt":"2021-04-27T22:52:51","Actor":"twsouthwick","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/924","RelatedDescription":null,"RelatedBody":"If a document happened to have a large number of elements that have the\r\nUniqueAttributeValueConstraint validation, it will end up recalculating\r\nthe values for the constraint way too often. This was because the\r\nconstraint was generating the cached lookup with a key using the\r\nattribute text itself. This change updates the lookup to cache all\r\npossible duplicates for the element in question so it only has to be\r\nsearched once.\r\n\r\nFixes #918 "},{"Id":"16111944166","Type":"PullRequestEvent","CreatedAt":"2021-04-27T22:52:50","Actor":"twsouthwick","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/924","RelatedDescription":"Closed pull request \"Cache search better in UniqueAttributeValueConstraint\" (#924) at OfficeDev/Open-XML-SDK","RelatedBody":"If a document happened to have a large number of elements that have the\r\nUniqueAttributeValueConstraint validation, it will end up recalculating\r\nthe values for the constraint way too often. This was because the\r\nconstraint was generating the cached lookup with a key using the\r\nattribute text itself. This change updates the lookup to cache all\r\npossible duplicates for the element in question so it only has to be\r\nsearched once.\r\n\r\nFixes #918 "},{"Id":"16074538642","Type":"IssuesEvent","CreatedAt":"2021-04-25T04:51:46","Actor":"foxjazz","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/927","RelatedDescription":"Opened issue \"using memory stream doesn't work when adding chunked content\" (#927) at OfficeDev/Open-XML-SDK","RelatedBody":"# Before submitting an issue, please fill this out\r\n\r\nIs this a:\r\nThis is using openxml worddocument processing.\r\n\r\nIf you have answered that this is a question, please ask it on StackOverflow instead of here.\r\nThis issue tracker is meant to track product issues while StackOverflow excels at answering questions\r\n\r\n---------------- Remove this line and above before posting ----------------\r\n\r\n**Description**\r\n\r\nWhen opening the document from a file, the functions for adding content behave differently than when using memorystream to open the document.\r\n\r\n"},{"Id":"16062675753","Type":"IssuesEvent","CreatedAt":"2021-04-23T14:34:27","Actor":"zakkar1","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/926","RelatedDescription":"Opened issue \"Cannot apply styleindex in Excel using OpenXml SDK\" (#926) at OfficeDev/Open-XML-SDK","RelatedBody":"Hi ,\r\nI'm using a template xlsx file which contains some columns with Formats.\r\nWhen I populate my new Excel file I can replace the values but I cannot accomplish the format of the cells\r\nThe workflow is as follows\r\na. I'm taking the excel template which contains the preformatted columns. I have for example a column with number format , a column with a datetime format etc.\r\nb. I'm creating the new xlsx file according to my original template and then with code I'm replacing the values to each column. The values are replaces CORRECTLY so let's not stick to that.\r\n\r\nThe problem starts that If I have a value , a number let's say 34567 and in my excel I want to show it as Currency , in the generated excel I can see the number without the format.\r\n\r\nAlthough I have applied the styleindex property.\r\n\r\nBelow is some sample code from the last actions that my app is doing.\r\n\r\nThe InsertCellInWorkSheet contains the styleindex which originally came from the template\r\n\r\n```\r\nprivate static Cell InsertCellInWorksheet(Celll celll, WorksheetPart worksheetPart, SingleValues value)\r\n{\r\nvar worksheet = worksheetPart.Worksheet;\r\nvar sheetData = worksheet.GetFirstChild<SheetData>();\r\n\r\n          var rowIndex = Convert.ToUInt32(RowReg.Match(celll.CellReference).Value);\r\n          // If the worksheet does not contain a row with the specified row index, insert one.\r\n    \r\n          //this will be current row, next row or null\r\n          var nextOrCurrentRow = sheetData\r\n              .Elements<Row>() //take all rows\r\n              .Where(r => r.RowIndex.Value >= rowIndex) //where index equal or greater of current\r\n              .OrderBy(x => x.RowIndex.Value) //order by index\r\n              .FirstOrDefault();\r\n    \r\n          Row row = null;\r\n          //if it current row use it\r\n          if (nextOrCurrentRow != null && nextOrCurrentRow.RowIndex.Value == rowIndex)\r\n              row = nextOrCurrentRow;\r\n    \r\n          if (row == null)\r\n          {\r\n              row = new Row { RowIndex = new UInt32Value(rowIndex) };\r\n              //if not null then this is next row\r\n              if (nextOrCurrentRow != null)\r\n                  sheetData.InsertBefore(row, nextOrCurrentRow);\r\n              else\r\n                  sheetData.Append(row);\r\n          }\r\n    \r\n          // If there is not a cell with the specified column name, insert one.\r\n          if (row.Elements<Cell>().Any(c => c.CellReference.Value == celll.CellReference))\r\n          {\r\n              return row.Elements<Cell>().First(c => c.CellReference.Value == celll.CellReference);\r\n    \r\n          }\r\n    \r\n          // Cells must be in sequential order according to CellReference. Determine where to insert the new cell.\r\n          var newid = Common.Ab4ToInt(celll.CellReference.ToUpper());\r\n    \r\n          var refCell = row.Elements<Cell>()\r\n              .FirstOrDefault(\r\n                  cell => Common.Ab4ToInt(cell.CellReference.Value.ToUpper()) > newid);\r\n              \r\n          var newCell = new Cell { CellReference = celll.CellReference, StyleIndex = celll.StyleIndex  };\r\n                \r\n          row.InsertBefore(newCell, refCell);\r\n    \r\n          return newCell;\r\n}\r\n```\r\n\r\nEverything is SharedString\r\n\r\n```\r\nprivate static void SetCellValue(OpenXmlPartContainer wbPart, WorksheetPart worksheetPart, Celll celll, SingleValues value)\r\n{\r\nvar sheetCell = InsertCellInWorksheet(celll, worksheetPart,value);\r\n\r\n         //return;\r\n          var cellText = GetCellValue(sheetCell, wbPart);\r\n    \r\n          if (sheetCell.DataType == null)\r\n          {\r\n              //new cell?\r\n              sheetCell.DataType = new EnumValue<CellValues>(CellValues.String);\r\n              cellText = celll.Template;\r\n          }\r\n          var safeText = value.FirstOrDefault(x => x.Replaceable == celll.Label)?.Value?.Trim();\r\n          cellText = ResultToValue(safeText);\r\n    \r\n    \r\n          switch (sheetCell.DataType.Value)\r\n          {\r\n              case CellValues.SharedString:\r\n                  var sharedStringId = InsertSharedStringItem(cellText, wbPart , sheetCell).ToString(CultureInfo.InvariantCulture);\r\n                  sheetCell.CellValue = new CellValue(sharedStringId);\r\n                  break;\r\n              default:\r\n                  var textNode = new Text(cellText);\r\n                  sheetCell.CellValue = new CellValue(textNode.Text);\r\n                  break;\r\n          }\r\n    \r\n      }\r\nprivate static int InsertSharedStringItem(string text, OpenXmlPartContainer wbPart , Cell cell=null)\r\n{\r\nvar shareStringPart = GetOrCreateSharedStringTablePart(wbPart);\r\nvar i = 0;\r\n\r\n          // Iterate through all the items in the SharedStringTable. If the text already exists, return its index.\r\n          foreach (var item in shareStringPart.SharedStringTable.Elements<SharedStringItem>())\r\n          {\r\n              if (item.InnerText == text)\r\n                  return i;\r\n              i++;\r\n          }\r\n          // The text does not exist in the part. Create the SharedStringItem and return its index.\r\n              \r\n          shareStringPart.SharedStringTable.AppendChild(new SharedStringItem(new Text(text)));\r\n          shareStringPart.SharedStringTable.Save();\r\n    \r\n          return i;\r\n      }\r\n\r\n```\r\n\r\nCan anyone assist me on this ?\r\nI want to insert the data which is in string format and let Excel handle the formating which is already applied.\r\nAppreciate any help you could give me"}],"ResultType":"GitHubEvent"},"PowerTools":{"Events":[],"ResultType":"GitHubEvent"}},"RunOn":"2021-04-30T05:30:37.8880778Z","RunDurationInMilliseconds":739}