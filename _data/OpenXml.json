{"Data":{"Sdk":{"Events":[{"Id":"51389278047","Type":"IssuesEvent","CreatedAt":"2025-06-26T17:00:36","Actor":"alexa-padberg","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1948","RelatedDescription":"Opened issue \"Getting Error that Powerpoint needs to be repaired after adding video through open xml\" (#1948) at dotnet/Open-XML-SDK","RelatedBody":"I am currently trying to add in a video element to a powerpoint that I am creating. I have tried both of microsofts functions in the openxml sdk\nas well as a chat line on github about having a similar issue. https://github.com/dotnet/Open-XML-SDK/issues/1740\n\nI am not entirely sure what the problem is, but I always get a notification that the powerpoint has to be repaired and every time I open it, there is not video or image displayed on the slide. Oddly enough, when I open the powerpoint, the video is displayed on the slide correcntly. I cannot figure out where the xml is messed up and causing the repair error.  Here is my current function\n\n public async static Task AddVideo(PresentationDocument presentationDocument, SlidePart slidePart, string videoFilePath, string coverPicPath)\n {\n\n     string imgEmbedId = \"imgid\", embedId = \"embedid\", mediaEmbedId = \"mediaid\";\n     UInt32Value shapeId = 5;\n   \n         PresentationPart presentationPart = presentationDocument.PresentationPart;\n\n         //Get slides ids.\n         OpenXmlElementList slidesIds = presentationPart.Presentation.SlideIdList.ChildElements;\n\n       \n\n         //Get slide part by relationshipID\n         //SlidePart? slidePart = (SlidePart)presentationPart.GetPartById(videoSldRelationshipId);\n\n         // Create video Media Data Part (content type, extension)\n         MediaDataPart mediaDataPart = presentationDocument.CreateMediaDataPart(\"video/mp4\", \".mp4\");\n\n         //Get the video file and feed the stream\n         using (Stream mediaDataPartStream = File.OpenRead(videoFilePath))\n         {\n             mediaDataPart.FeedData(mediaDataPartStream);\n         }\n         //Adds a VideoReferenceRelationship to the MainDocumentPart\n         slidePart.AddVideoReferenceRelationship(mediaDataPart, embedId);\n\n         //Adds a MediaReferenceRelationship to the SlideLayoutPart\n         slidePart.AddMediaReferenceRelationship(mediaDataPart, mediaEmbedId);\n\n         NonVisualDrawingProperties nonVisualDrawingProperties = new NonVisualDrawingProperties() { Id = shapeId, Name = \"video\" };\n         A.VideoFromFile videoFromFile = new A.VideoFromFile() { Link = embedId };\n\n         ApplicationNonVisualDrawingProperties appNonVisualDrawingProperties = new ApplicationNonVisualDrawingProperties();\n         appNonVisualDrawingProperties.Append(videoFromFile);\n\n         //adds sample image to the slide with id to be used as reference in blip\n         ImagePart imagePart = slidePart.AddImagePart(ImagePartType.Png, imgEmbedId);\n         using (Stream data = File.OpenRead(coverPicPath))\n         {\n             imagePart.FeedData(data);\n         }\n\n         if (slidePart!.Slide!.CommonSlideData!.ShapeTree == null)\n         {\n             throw new NullReferenceException(\"Presentation shape tree is empty\");\n         }\n\n         //Getting existing shape tree object from PowerPoint\n         P.ShapeTree shapeTree = slidePart.Slide.CommonSlideData.ShapeTree;\n\n         // specifies the existence of a picture within a presentation.\n         // It can have non-visual properties, a picture fill as well as shape properties attached to it.\n         Picture picture = new Picture();\n         NonVisualPictureProperties nonVisualPictureProperties = new NonVisualPictureProperties();\n\n       //  A.HyperlinkOnClick hyperlinkOnClick = new A.HyperlinkOnClick() { Id = \"\", Action = \"ppaction://media\" };\n        // nonVisualDrawingProperties.Append(hyperlinkOnClick);\n\n         NonVisualPictureDrawingProperties nonVisualPictureDrawingProperties = new NonVisualPictureDrawingProperties();\n         A.PictureLocks pictureLocks = new A.PictureLocks() { NoChangeAspect = true };\n         nonVisualPictureDrawingProperties.Append(pictureLocks);\n\n         ApplicationNonVisualDrawingPropertiesExtensionList appNonVisualDrawingPropertiesExtensionList = new ApplicationNonVisualDrawingPropertiesExtensionList();\n         ApplicationNonVisualDrawingPropertiesExtension appNonVisualDrawingPropertiesExtension = new ApplicationNonVisualDrawingPropertiesExtension() { Uri = \"{DAA4B4D4-6D71-4841-9C94-3DE7FCFB9230}\" };\n\n     P14.Media media = new() { Embed = mediaEmbedId };\n     media.AddNamespaceDeclaration(\"p14\", \"http://schemas.microsoft.com/office/powerpoint/2010/main\");\n\n     appNonVisualDrawingPropertiesExtension.Append(media);\n     appNonVisualDrawingPropertiesExtensionList.Append(appNonVisualDrawingPropertiesExtension);\n     appNonVisualDrawingProperties.Append(appNonVisualDrawingPropertiesExtensionList);\n\n          nonVisualPictureProperties.Append(nonVisualDrawingProperties);\n         nonVisualPictureProperties.Append(nonVisualPictureDrawingProperties);\n     //start here for commenting shit out\n         nonVisualPictureProperties.Append(appNonVisualDrawingProperties);\n\n         //Prepare shape properties to display picture\n         BlipFill blipFill = new BlipFill();\n         A.Blip blip = new A.Blip() { Embed = imgEmbedId };\n     A.Stretch stretch = new A.Stretch();\n     A.FillRectangle fillRectangle = new A.FillRectangle();\n     A.Transform2D transform2D = new A.Transform2D();\n     A.Offset offset = new A.Offset() { X = 4801938, Y = 1960881 };\n     A.Extents extents = new A.Extents() { Cx = 7410381, Cy = 3165566 };\n\n     \n      long arialX = (long)GeoPoserPowerPointFrame.arialX;  // Horizontal position\n     long arialY = (long)GeoPoserPowerPointFrame.arialY;\n\n     A.PresetGeometry presetGeometry = new A.PresetGeometry() { Preset = A.ShapeTypeValues.Rectangle };\n     A.AdjustValueList adjValueList = new A.AdjustValueList();\n\n     stretch.Append(fillRectangle);\n         blipFill.Append(blip);\n         blipFill.Append(stretch);\n         transform2D.Append(offset);\n         transform2D.Append(extents);\n         presetGeometry.Append(adjValueList);\n     P.ShapeProperties pShapeProperties = new P.ShapeProperties();\n\n     ShapeProperties shapeProperties = new ShapeProperties();\n         pShapeProperties.Append(transform2D);\n         pShapeProperties.Append(presetGeometry);\n\n         //adds all elements to the slide's shape tree\n         picture.Append(nonVisualPictureProperties);\n         picture.Append(blipFill);\n         picture.Append(pShapeProperties);\n\n         shapeTree.Append(picture);\n     \n }"},{"Id":"51296437578","Type":"IssuesEvent","CreatedAt":"2025-06-24T20:47:37","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1947","RelatedDescription":"Opened issue \"Remove PivotCacheRichInfo\" (#1947) at dotnet/Open-XML-SDK","RelatedBody":"odoc:omit=\"true\" fails  on CT_PivotCacheRichInfo, so PivotCacheRichInfo should be removed in v4 unless the odoc:omit status has changed."},{"Id":"51296395149","Type":"IssuesEvent","CreatedAt":"2025-06-24T20:46:22","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1946","RelatedDescription":"Opened issue \"Obsolete PivotCacheRichInfo\" (#1946) at dotnet/Open-XML-SDK","RelatedBody":"CT_PivotCacheRichInfo is odoc:omit=\"true\" but it failed, so PivotCacheRichInfo should be obsoleted then removed in v4"},{"Id":"51291183387","Type":"IssuesEvent","CreatedAt":"2025-06-24T18:19:36","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1945","RelatedDescription":"Opened issue \"Remove PivotCacheDynamicArray class\" (#1945) at dotnet/Open-XML-SDK","RelatedBody":"The PivotCacheDynamicArray is obsoleted and should be removed in v4"},{"Id":"51291130846","Type":"IssuesEvent","CreatedAt":"2025-06-24T18:18:11","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1944","RelatedDescription":"Opened issue \"Obsolete PivotCacheDynamicArray class\" (#1944) at dotnet/Open-XML-SDK","RelatedBody":"CT_PivotCacheDynamicArrayExt has been removed in the latest schema update so PivotCacheDynamicArray should be obsoleted until it can be removed in v4"},{"Id":"51288387697","Type":"IssuesEvent","CreatedAt":"2025-06-24T17:06:49","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1943","RelatedDescription":"Opened issue \"Add Feature Extension and List for CT_CustomSheetView and CT_SheetView\" (#1943) at dotnet/Open-XML-SDK","RelatedBody":"CT_CustomSheetView and CT_SheetView need feature extension and list added to patch file"},{"Id":"51267492361","Type":"IssuesEvent","CreatedAt":"2025-06-24T09:42:32","Actor":"JoseAngelSalmeronMorote","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1942","RelatedDescription":"Opened issue \"Bug with Open XML SDK Disposing SpreadsheetDocument\" (#1942) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\n\nReading metadata properties of an Excel file containing `ContentTypeId` metadata attribute leads to a huge increase of memory while disposing SpreadsheetDocument.\n\n**Screenshots**\n\nMemory issue on Spreadsheetdocument disposal:\n![Image](https://github.com/user-attachments/assets/d14783e9-a9b6-4ec3-8f84-e54e0c5976f0)\n\nMetadata attribute causing the trouble:\n\n![Image](https://github.com/user-attachments/assets/f51e95ce-5a5d-4228-aef9-33f06fa753fd)\n\n**To Reproduce**\n\nMinimal repro:\n\nvar openSettings = new OpenSettings\n{\n    RelationshipErrorHandlerFactory = package =>\n    {\n        return new UriRelationshipErrorHandler();\n    }\n};\nusing (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))\n{\n    using (SpreadsheetDocument myDoc = SpreadsheetDocument.Open(fs, true, openSettings))\n    {\n        //Access main part of document \n        CustomFilePropertiesPart FileProperties = myDoc.CustomFilePropertiesPart;\n\n        if (FileProperties == null)\n        {\n            output = MetadataError.ThereAreNoProperties;\n            return output;\n        }\n\n        // Bug here: Executing this line leads to later issue while disposing 'myDoc'.\n        // I assume it's related to the 'LoadDom<Properties>' executed inside of it.\n        DocumentFormat.OpenXml.CustomProperties.Properties props = FileProperties.Properties;\n        output = MetadataError.Ok;\n    } // Issue here: this line never returns.\n    fs.Close(); // Line never reached.\n}\n\nSteps to reproduce the behavior:\n1. Get an Excel file of 100Mb.\n2. Add this metadata attribute: 'ContentTypeId' of type 'Text' with value '0x010100FA10029CDD445747B364374CC14F16B5' (this is automatically added by SharePoint if you just upload/download the document).\n3. Execute above code.\n4. See how memory increases until several Gb and the process hang.\n\n**Observed behavior**\n\nMemory increases until its limit. Dispose line never returns.\n\n**Expected behavior**\nMemory should not increase and .Disposing the SpreadsheetDocument should not hang the application.\n\n**Desktop (please complete the following information):**\n - OS: [Windows Server 2022 Datacenter Evaluation]\n - Office version [N/A]\n - .NET Target: reproduced with .NETStandard 2.0 and .NETFramework 4.0\n - DocumentFormat.OpenXml Version: 2.12.0\n\n**Additional context**\n\n"},{"Id":"51238106194","Type":"PullRequestEvent","CreatedAt":"2025-06-23T18:09:58","Actor":"tomjebo","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1941","RelatedDescription":"Opened pull request \"Fixes #1033 by adding oMath element to CT_TextMath\" (#1941) at dotnet/Open-XML-SDK","RelatedBody":""},{"Id":"51138970132","Type":"IssuesEvent","CreatedAt":"2025-06-20T09:34:15","Actor":"lindexi","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1940","RelatedDescription":"Opened issue \"The `DocumentFormat.OpenXml.Office2010.Drawing.TextMath` should not inherit OpenXmlLeafElement\" (#1940) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\n\nThe  `DocumentFormat.OpenXml.Office2010.Drawing.TextMath` (`a14:m`) is inherit OpenXmlLeafElement now. But as the document says, the  `DocumentFormat.OpenXml.Office2010.Drawing.TextMath` (`a14:m`)  will contain the OfficeMath element.\n\nThe sample OpenXML document:\n\n```xml\n              <a:p>\n                <a:r>\n                  <a:rPr lang=\"en-US\" altLang=\"zh-CN\" dirty=\"0\" />\n                  <a:t>123</a:t>\n                </a:r>\n                <a14:m>\n                  <m:oMath xmlns:m=\"http://schemas.openxmlformats.org/officeDocument/2006/math\">\n                    <m:r>\n                      <a:rPr lang=\"en-US\" altLang=\"zh-CN\" b=\"0\" i=\"1\" smtClean=\"0\">\n                        <a:latin typeface=\"Cambria Math\" panose=\"02040503050406030204\" pitchFamily=\"18\" charset=\"0\" />\n                      </a:rPr>\n                      <m:t>123</m:t>\n                    </m:r>\n                  </m:oMath>\n                </a14:m>\n                <a:endParaRPr lang=\"zh-CN\" altLang=\"en-US\" dirty=\"0\" />\n              </a:p>\n```\n\n**Screenshots**\nIf applicable, add screenshots to help explain your problem.\n\n**To Reproduce**\nNone.\n\n**Observed behavior**\n\nWe can not get the ChildElements from `DocumentFormat.OpenXml.Office2010.Drawing.TextMath`. And it will cause some unexpected behavior, such as https://github.com/dotnet/Open-XML-SDK/issues/1033\n\n**Expected behavior**\n\nThe `DocumentFormat.OpenXml.Office2010.Drawing.TextMath` should inherit OpenXmlCompositeElement type.\n\n**Desktop (please complete the following information):**\n - OS: [e.g. Windows]\n - Office version [e.g. 16.0.15427.20178]\n - .NET Target: (e.g. .NET Framework, .NET Core, UWP, Xamarin...)\n - DocumentFormat.OpenXml Version: (e.g. 2.11.0)\n\n**Additional context**\nAdd any other context about the problem here.\n"},{"Id":"51107002973","Type":"IssuesEvent","CreatedAt":"2025-06-19T13:34:13","Actor":"mkaszewiak","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1937","RelatedDescription":"Closed issue \"Bug with Open XML SDK\" (#1937) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\nImproper Handling of Indentation and Hierarchy in Word Document Extraction Using Open XML\n**Screenshots**\n\n<!-- Failed to upload \"SnipImage.JPG\" -->\n\n**To Reproduce**\nbelow is the code i am using \n ```csharp private static string ConvertParagraphToHtml(WordprocessingDocument doc, Paragraph paragraph)\n {\n     StringBuilder paraHtml = new StringBuilder();\n     bool inBold = false;\n     const float PointsPerInch = 72.0f;\n     const float TabWidthInInches = 0.5f;\n     const int TwipsPerPoint = 20; // 1 point = 20 twips\n     const string TabRepresentation = \"<t>\"; // Use <t> to represent a tab in HTML\n\n     string paragraphText = GetParagraphText(paragraph).TrimEnd('\\r', '\\n');\n     if (string.IsNullOrEmpty(paragraphText))\n     {\n         return \"\";\n     }\n\n     // Handle initial tabs before numbering\n     StringBuilder preNumberingTabs = new StringBuilder();\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         if (run.Elements<TabChar>().Any())\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n         else\n         {\n             // Stop collecting tabs once we hit non-tab content\n             if (!string.IsNullOrEmpty(run.InnerText))\n                 break;\n         }\n     }\n\n     // Handle indentation\n     ParagraphProperties paraProps = paragraph.GetFirstChild<ParagraphProperties>();\n     Indentation indentation = paraProps?.GetFirstChild<Indentation>();\n\n     float leftIndentPoints = indentation?.Left != null && int.TryParse(indentation.Left, out int leftTwips)\n         ? leftTwips / (float)TwipsPerPoint : 0f;\n     float firstLineIndentPoints = indentation?.FirstLine != null && int.TryParse(indentation.FirstLine, out int firstLineTwips)\n         ? firstLineTwips / (float)TwipsPerPoint : 0f;\n     float rightIndentPoints = indentation?.Right != null && int.TryParse(indentation.Right, out int rightTwips)\n         ? rightTwips / (float)TwipsPerPoint : 0f;\n\n     float leftIndentInches = leftIndentPoints / PointsPerInch;\n     if (leftIndentInches > 0)\n     {\n         var loopTimes = (int)(leftIndentInches / TabWidthInInches);\n         for (int i = 0; i < loopTimes; i++)\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n     }\n\n     // Append pre-numbering tabs and indentation\n     paraHtml.Append(preNumberingTabs.ToString());\n\n     // Handle list numbering\n     string listPrefix = \"\";\n     var numberingProperties = paragraph.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n     var numberingId = numberingProperties?.NumberingId?.Val?.Value;\n     var numberingLevel = numberingProperties?.NumberingLevelReference?.Val?.Value ?? 0;\n\n     if (numberingProperties != null && numberingId.HasValue)\n     {\n         try\n         {\n             var numberingPart = doc.MainDocumentPart?.NumberingDefinitionsPart;\n             var numbering = numberingPart?.Numbering;\n             var abstractNumId = numbering?.Elements<NumberingInstance>()\n                 .FirstOrDefault(n => n.NumberID?.Value == numberingId)?.AbstractNumId?.Val?.Value;\n             var abstractNum = numbering?.Elements<AbstractNum>()\n                 .FirstOrDefault(n => n.AbstractNumberId?.Value == abstractNumId);\n             var level = abstractNum?.Elements<Level>().FirstOrDefault(l => l.LevelIndex?.Value == numberingLevel);\n             if (level != null)\n             {\n                 int listItemCount = 0;\n                 var paragraphs = doc.MainDocumentPart?.Document.Body.Elements<Paragraph>();\n                 if (paragraphs != null)\n                 {\n                     foreach (var p in paragraphs)\n                     {\n                         var np = p.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n                         var pNumId = np?.NumberingId?.Val?.Value;\n                         var pLevel = np?.NumberingLevelReference?.Val?.Value ?? 0;\n                         if (pNumId == numberingId && pLevel == numberingLevel)\n                         {\n                             listItemCount++;\n                             if (p == paragraph)\n                                 break;\n                         }\n                     }\n                 }\n\n                 string listNumber = listItemCount.ToString();\n                 var numberFormatMap = new Dictionary<NumberFormatValues, string>\n         {\n             { NumberFormatValues.Decimal, \"decimal\" },\n             { NumberFormatValues.LowerLetter, \"lowerletter\" },\n             { NumberFormatValues.UpperLetter, \"upperletter\" },\n             { NumberFormatValues.LowerRoman, \"lowerroman\" },\n             { NumberFormatValues.UpperRoman, \"upperroman\" },\n             { NumberFormatValues.Bullet, \"bullet\" }\n         };\n                 var numberStyle = numberFormatMap.TryGetValue(level.NumberingFormat?.Val?.Value ?? NumberFormatValues.Decimal, out var style)\n                     ? style\n                     : \"decimal\";\n                 switch (numberStyle.ToLower())\n                 {\n                     case \"lowerletter\":\n                         listNumber = ((char)('a' + listItemCount - 1)).ToString();\n                         break;\n                     case \"upperletter\":\n                         listNumber = ((char)('A' + listItemCount - 1)).ToString();\n                         break;\n                     case \"lowerroman\":\n                         listNumber = ToRoman(listItemCount).ToLower();\n                         break;\n                     case \"upperroman\":\n                         listNumber = ToRoman(listItemCount).ToUpper();\n                         break;\n                     case \"bullet\":\n                         listNumber = level.LevelText?.Val?.Value ?? \"•\";\n                         break;\n                     default:\n                         listNumber = listItemCount.ToString(); // Decimal\n                         break;\n                 }\n\n                 string numberFormat = level.LevelText?.Val?.Value ?? \"%1.\";\n                 listPrefix = numberFormat.Replace(\"%1\", listNumber);\n                 // Add tab after number if not a bullet\n                 if (numberStyle.ToLower() != \"bullet\")\n                 {\n                     listPrefix += TabRepresentation;\n                 }\n             }\n         }\n         catch (Exception ex)\n         {\n             Console.WriteLine($\"Error processing list numbering: {ex.Message}\");\n             listPrefix = \"\"; // Fallback to empty prefix\n         }\n     }\n\n     // Append list prefix after tabs and indentation\n     paraHtml.Append(listPrefix);\n\n     // Process runs for bold formatting, text, and tabs\n     bool numberProcessed = string.IsNullOrEmpty(listPrefix); // Skip runs until numbering is processed\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         // Skip runs that are part of numbering if listPrefix was generated\n         if (!numberProcessed && run.InnerText == listPrefix.TrimEnd(TabRepresentation.ToCharArray()))\n         {\n             numberProcessed = true;\n             continue;\n         }\n\n         // Handle tab elements\n         if (run.Elements<TabChar>().Any())\n         {\n             paraHtml.Append(TabRepresentation);\n             continue;\n         }\n\n         string runText = run.InnerText ?? \"\";\n         bool isRunBold = run.RunProperties?.Bold != null;\n\n         if (string.IsNullOrEmpty(runText))\n             continue;\n\n         if (runText == \"\\n\")\n         {\n             paraHtml.Append(\"\\n\");\n         }\n         else if (runText == \"\\t\")\n         {\n             paraHtml.Append(TabRepresentation);\n         }\n         else\n         {\n             if (isRunBold && !inBold)\n             {\n                 paraHtml.Append(\"<b>\");\n                 inBold = true;\n             }\n             else if (!isRunBold && inBold)\n             {\n                 paraHtml.Append(\"</b>\");\n                 inBold = false;\n             }\n             paraHtml.Append(runText);\n         }\n     }\n\n     if (inBold)\n     {\n         paraHtml.Append(\"</b>\");\n     }\n\n     // Clean up HTML\n     paraHtml.Replace(\"{\", \"[\");\n     paraHtml.Replace(\"}\", \"]\");\n     paraHtml.Replace(\"<b>\\r</b>\", \"\");\n     paraHtml.Replace(\"\\r</b>\", \"</b>\");\n     paraHtml.Replace(\"\\r\", \"\");\n     paraHtml.Replace(\"<b></b>\", \"\");\n     paraHtml.Replace(\"<t>. <t>\", \".<t>\");\n     paraHtml.Replace(\"<t>.<t>\", \".<t>\");\n     paraHtml.Replace(\"(<t>\", \"(\");\n     paraHtml.Replace(\" <t>\", TabRepresentation); // Preserve tabs\n\n     Console.WriteLine($\"Converted HTML: {paraHtml.ToString()}\");\n     return paraHtml.ToString();\n }\n ```\n\n\n**Observed behavior**\nindentation mismatched\n\n**Expected behavior**\nI want indentation to display as per the source document \n\n**Desktop (please complete the following information):**\n - OS: [e.g. Windows]\n - Office version [e.g. 16.0.15427.20178]\n - .NET Target: 4.6.3\n - DocumentFormat.OpenXml Version: (e.g. 3.3..00)\n\n**Additional context**\nAdd any other context about the problem here.\n i dont have permisison to add files here"},{"Id":"51094897971","Type":"IssuesEvent","CreatedAt":"2025-06-19T08:43:03","Actor":"mkaszewiak","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1937","RelatedDescription":"Reopened issue \"Bug with Open XML SDK\" (#1937) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\nImproper Handling of Indentation and Hierarchy in Word Document Extraction Using Open XML\n**Screenshots**\n\n<!-- Failed to upload \"SnipImage.JPG\" -->\n\n**To Reproduce**\nbelow is the code i am using \n ```csharp private static string ConvertParagraphToHtml(WordprocessingDocument doc, Paragraph paragraph)\n {\n     StringBuilder paraHtml = new StringBuilder();\n     bool inBold = false;\n     const float PointsPerInch = 72.0f;\n     const float TabWidthInInches = 0.5f;\n     const int TwipsPerPoint = 20; // 1 point = 20 twips\n     const string TabRepresentation = \"<t>\"; // Use <t> to represent a tab in HTML\n\n     string paragraphText = GetParagraphText(paragraph).TrimEnd('\\r', '\\n');\n     if (string.IsNullOrEmpty(paragraphText))\n     {\n         return \"\";\n     }\n\n     // Handle initial tabs before numbering\n     StringBuilder preNumberingTabs = new StringBuilder();\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         if (run.Elements<TabChar>().Any())\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n         else\n         {\n             // Stop collecting tabs once we hit non-tab content\n             if (!string.IsNullOrEmpty(run.InnerText))\n                 break;\n         }\n     }\n\n     // Handle indentation\n     ParagraphProperties paraProps = paragraph.GetFirstChild<ParagraphProperties>();\n     Indentation indentation = paraProps?.GetFirstChild<Indentation>();\n\n     float leftIndentPoints = indentation?.Left != null && int.TryParse(indentation.Left, out int leftTwips)\n         ? leftTwips / (float)TwipsPerPoint : 0f;\n     float firstLineIndentPoints = indentation?.FirstLine != null && int.TryParse(indentation.FirstLine, out int firstLineTwips)\n         ? firstLineTwips / (float)TwipsPerPoint : 0f;\n     float rightIndentPoints = indentation?.Right != null && int.TryParse(indentation.Right, out int rightTwips)\n         ? rightTwips / (float)TwipsPerPoint : 0f;\n\n     float leftIndentInches = leftIndentPoints / PointsPerInch;\n     if (leftIndentInches > 0)\n     {\n         var loopTimes = (int)(leftIndentInches / TabWidthInInches);\n         for (int i = 0; i < loopTimes; i++)\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n     }\n\n     // Append pre-numbering tabs and indentation\n     paraHtml.Append(preNumberingTabs.ToString());\n\n     // Handle list numbering\n     string listPrefix = \"\";\n     var numberingProperties = paragraph.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n     var numberingId = numberingProperties?.NumberingId?.Val?.Value;\n     var numberingLevel = numberingProperties?.NumberingLevelReference?.Val?.Value ?? 0;\n\n     if (numberingProperties != null && numberingId.HasValue)\n     {\n         try\n         {\n             var numberingPart = doc.MainDocumentPart?.NumberingDefinitionsPart;\n             var numbering = numberingPart?.Numbering;\n             var abstractNumId = numbering?.Elements<NumberingInstance>()\n                 .FirstOrDefault(n => n.NumberID?.Value == numberingId)?.AbstractNumId?.Val?.Value;\n             var abstractNum = numbering?.Elements<AbstractNum>()\n                 .FirstOrDefault(n => n.AbstractNumberId?.Value == abstractNumId);\n             var level = abstractNum?.Elements<Level>().FirstOrDefault(l => l.LevelIndex?.Value == numberingLevel);\n             if (level != null)\n             {\n                 int listItemCount = 0;\n                 var paragraphs = doc.MainDocumentPart?.Document.Body.Elements<Paragraph>();\n                 if (paragraphs != null)\n                 {\n                     foreach (var p in paragraphs)\n                     {\n                         var np = p.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n                         var pNumId = np?.NumberingId?.Val?.Value;\n                         var pLevel = np?.NumberingLevelReference?.Val?.Value ?? 0;\n                         if (pNumId == numberingId && pLevel == numberingLevel)\n                         {\n                             listItemCount++;\n                             if (p == paragraph)\n                                 break;\n                         }\n                     }\n                 }\n\n                 string listNumber = listItemCount.ToString();\n                 var numberFormatMap = new Dictionary<NumberFormatValues, string>\n         {\n             { NumberFormatValues.Decimal, \"decimal\" },\n             { NumberFormatValues.LowerLetter, \"lowerletter\" },\n             { NumberFormatValues.UpperLetter, \"upperletter\" },\n             { NumberFormatValues.LowerRoman, \"lowerroman\" },\n             { NumberFormatValues.UpperRoman, \"upperroman\" },\n             { NumberFormatValues.Bullet, \"bullet\" }\n         };\n                 var numberStyle = numberFormatMap.TryGetValue(level.NumberingFormat?.Val?.Value ?? NumberFormatValues.Decimal, out var style)\n                     ? style\n                     : \"decimal\";\n                 switch (numberStyle.ToLower())\n                 {\n                     case \"lowerletter\":\n                         listNumber = ((char)('a' + listItemCount - 1)).ToString();\n                         break;\n                     case \"upperletter\":\n                         listNumber = ((char)('A' + listItemCount - 1)).ToString();\n                         break;\n                     case \"lowerroman\":\n                         listNumber = ToRoman(listItemCount).ToLower();\n                         break;\n                     case \"upperroman\":\n                         listNumber = ToRoman(listItemCount).ToUpper();\n                         break;\n                     case \"bullet\":\n                         listNumber = level.LevelText?.Val?.Value ?? \"•\";\n                         break;\n                     default:\n                         listNumber = listItemCount.ToString(); // Decimal\n                         break;\n                 }\n\n                 string numberFormat = level.LevelText?.Val?.Value ?? \"%1.\";\n                 listPrefix = numberFormat.Replace(\"%1\", listNumber);\n                 // Add tab after number if not a bullet\n                 if (numberStyle.ToLower() != \"bullet\")\n                 {\n                     listPrefix += TabRepresentation;\n                 }\n             }\n         }\n         catch (Exception ex)\n         {\n             Console.WriteLine($\"Error processing list numbering: {ex.Message}\");\n             listPrefix = \"\"; // Fallback to empty prefix\n         }\n     }\n\n     // Append list prefix after tabs and indentation\n     paraHtml.Append(listPrefix);\n\n     // Process runs for bold formatting, text, and tabs\n     bool numberProcessed = string.IsNullOrEmpty(listPrefix); // Skip runs until numbering is processed\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         // Skip runs that are part of numbering if listPrefix was generated\n         if (!numberProcessed && run.InnerText == listPrefix.TrimEnd(TabRepresentation.ToCharArray()))\n         {\n             numberProcessed = true;\n             continue;\n         }\n\n         // Handle tab elements\n         if (run.Elements<TabChar>().Any())\n         {\n             paraHtml.Append(TabRepresentation);\n             continue;\n         }\n\n         string runText = run.InnerText ?? \"\";\n         bool isRunBold = run.RunProperties?.Bold != null;\n\n         if (string.IsNullOrEmpty(runText))\n             continue;\n\n         if (runText == \"\\n\")\n         {\n             paraHtml.Append(\"\\n\");\n         }\n         else if (runText == \"\\t\")\n         {\n             paraHtml.Append(TabRepresentation);\n         }\n         else\n         {\n             if (isRunBold && !inBold)\n             {\n                 paraHtml.Append(\"<b>\");\n                 inBold = true;\n             }\n             else if (!isRunBold && inBold)\n             {\n                 paraHtml.Append(\"</b>\");\n                 inBold = false;\n             }\n             paraHtml.Append(runText);\n         }\n     }\n\n     if (inBold)\n     {\n         paraHtml.Append(\"</b>\");\n     }\n\n     // Clean up HTML\n     paraHtml.Replace(\"{\", \"[\");\n     paraHtml.Replace(\"}\", \"]\");\n     paraHtml.Replace(\"<b>\\r</b>\", \"\");\n     paraHtml.Replace(\"\\r</b>\", \"</b>\");\n     paraHtml.Replace(\"\\r\", \"\");\n     paraHtml.Replace(\"<b></b>\", \"\");\n     paraHtml.Replace(\"<t>. <t>\", \".<t>\");\n     paraHtml.Replace(\"<t>.<t>\", \".<t>\");\n     paraHtml.Replace(\"(<t>\", \"(\");\n     paraHtml.Replace(\" <t>\", TabRepresentation); // Preserve tabs\n\n     Console.WriteLine($\"Converted HTML: {paraHtml.ToString()}\");\n     return paraHtml.ToString();\n }\n ```\n\n\n**Observed behavior**\nindentation mismatched\n\n**Expected behavior**\nI want indentation to display as per the source document \n\n**Desktop (please complete the following information):**\n - OS: [e.g. Windows]\n - Office version [e.g. 16.0.15427.20178]\n - .NET Target: 4.6.3\n - DocumentFormat.OpenXml Version: (e.g. 3.3..00)\n\n**Additional context**\nAdd any other context about the problem here.\n i dont have permisison to add files here"},{"Id":"51063125910","Type":"IssuesEvent","CreatedAt":"2025-06-18T15:14:36","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1939","RelatedDescription":"Opened issue \"Remove DocumentFormat.OpenXml.Office.SpreadSheetML.Y2024.PivotDynamicArrays namespace\" (#1939) at dotnet/Open-XML-SDK","RelatedBody":"Remove DocumentFormat.OpenXml.Office.SpreadSheetML.Y2024.PivotDynamicArrays namespace and all related classes. They were added in error."}],"ResultType":"GitHubEvent"}},"RunOn":"2025-06-27T03:30:24.9215797Z","RunDurationInMilliseconds":459}