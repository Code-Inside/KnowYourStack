{"Data":{"Sdk":{"Events":[{"Id":"20789728234","Type":"PullRequestEvent","CreatedAt":"2022-03-16T23:45:41","Actor":"mikeebowen","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/pull/1137","RelatedDescription":"Opened pull request \"move PowerPointCommentPart relationship to SlidePart\" (#1137) at OfficeDev/Open-XML-SDK","RelatedBody":"This commit corrects the relationship between PowerPointCommentPart (modern comments) and SlidePart. This fixes #1133."},{"Id":"20783950274","Type":"IssuesEvent","CreatedAt":"2022-03-16T17:05:45","Actor":"m-gallesio","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/1136","RelatedDescription":"Opened issue \"Ambiguous OpenXmlElement constructors\" (#1136) at OfficeDev/Open-XML-SDK","RelatedBody":"**Description**\r\n\r\nGreetings.\r\nSome time ago we started analyzing our code with [SonarQube](https://www.sonarqube.org/), and I have noticed a large number of reports in cases like these:\r\n\r\n```csharp\r\nplaceholder.InsertBeforeSelf(new Paragraph(new ParagraphProperties(new SpacingBetweenLines() { After = \"0\" })));\r\n```\r\n\r\nwhich lead to warnings like this:\r\n\r\n>[S3220](https://rules.sonarsource.com/csharp/RSPEC-3220): Review this call, which partially matches an overload without 'params'. The partial match is 'Paragraph.Paragraph(IEnumerable<DocumentFormat.OpenXml.OpenXmlElement> childElements)'.\r\n\r\nThis happens because\r\n- all (most?) `OpenXmlElement`s define two constructors:\r\n    - one accepting an `IEnumerable<OpenXmlElement>`\r\n    - one accepting an `OpenXmlElement[]` as `params`\r\n- `OpenXmlElement` implements `IEnumerable<OpenXmlElement>`\r\n\r\nA call with a single `OpenXmlElement` as the argument is correctly resolved with the params[] overload, so this does not cause actual problems. However, this report shows this usage is king of ambiguous which I agree with (note also `OpenXmlElement.Append` and `Linq.Enumerable.Append`).\r\n\r\n**Information**\r\n\r\n- .NET Target: .NET Core (irrelevant)\r\n- DocumentFormat.OpenXml Version: 2.16.0 (and previous)\r\n\r\n**Expected**\r\n\r\nI guess adding an `OpenXmlElement(OpenXmlElement)` constructor would solve this issue, but I understand this would be an immense undertaking (every single OpenXmlElement would have to include it) which is likely not worth the time for this little gain. Moreover, while I understand and agree with this specific rule, I do not know how SonarQube rules are regarded in general / whether others share this sentiment.\r\n\r\nPlease consider this as just a comment about something I noticed and not as a strong request."},{"Id":"20755056349","Type":"IssuesEvent","CreatedAt":"2022-03-15T11:22:15","Actor":"andrewmolyneux","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/1133","RelatedDescription":"Reopened issue \"Support for modern comments in presentation files?\" (#1133) at OfficeDev/Open-XML-SDK","RelatedBody":"I've recently implemented support for comments in my code (finding comment XML via the SlideCommentsPart property of SlidePart) but I've noticed that it doesn't pick up \"modern\" comments which apparently were implemented in Office 365 starting in late 2020 or early 2021. Is support for this on the roadmap to be added to the SDK, or should I roll my own solution?"},{"Id":"20751995535","Type":"IssuesEvent","CreatedAt":"2022-03-15T08:36:39","Actor":"Kalle4242","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/1135","RelatedDescription":"Opened issue \"The second attempt to open an unchanged presentation file for edit throws a \"file contains corrupted data\" error. \" (#1135) at OfficeDev/Open-XML-SDK","RelatedBody":"**Description**\r\n\r\nWe are trying to access PowerPoint presentation via MS-Graph from a SharepPoint Online document library.\r\n\r\nOur PowerPoint Addin adds data as CustomXmlParts to presentation and the slides as well. It can be opened, manipulated and saved without problems as long as working files arer on a local computer.\r\n\r\nThe problem occurs when the file is uploaded to a SharePoint document library. \r\nI open a small example presentation file as a stream, copy it to a memory stream and provide it to the presentation document to open it for edit. I do not change anything and after saving the presentation I copy the stream back to the SharePoint replacing the previously opened file. This works well!\r\nBut, trying this for the second time, a \"File contains corrupted data.\" occurs, when trying to open the presentation document for edit  from the memory stream.\r\n\r\nThe error's stack trace suggest that \"MS.Internal.IO.Zip.ZipIOLocalFileBlock.Validate\" has a problem with the data from the second stream.\r\n\r\n`   at MS.Internal.IO.Zip.ZipIOLocalFileBlock.Validate(String fileName, ZipIOCentralDirectoryBlock centralDir, ZipIOCentralDirectoryFileHeader centralDirFileHeader)\r\n   at MS.Internal.IO.Zip.ZipIOLocalFileBlock.ParseRecord(BinaryReader reader, String fileName, Int64 position, ZipIOCentralDirectoryBlock centralDir, ZipIOCentralDirectoryFileHeader centralDirFileHeader)\r\n   at MS.Internal.IO.Zip.ZipIOLocalFileBlock.SeekableLoad(ZipIOBlockManager blockManager, String fileName)\r\n   at MS.Internal.IO.Zip.ZipIOBlockManager.LoadLocalFileBlock(String zipFileName)\r\n   at MS.Internal.IO.Zip.ZipArchive.GetFile(String zipFileName)\r\n   at MS.Internal.IO.Zip.ZipArchive.GetFiles()\r\n   at System.IO.Packaging.ZipPackage.ContentTypeHelper..ctor(ZipArchive zipArchive, IgnoredItemHelper ignoredItemHelper)\r\n   at System.IO.Packaging.ZipPackage..ctor(Stream s, FileMode mode, FileAccess access, Boolean streaming)\r\n   at System.IO.Packaging.Package.Open(Stream stream, FileMode packageMode, FileAccess packageAccess, Boolean streaming)\r\n   at DocumentFormat.OpenXml.Packaging.PackageLoader.OpenCore(Stream stream, Boolean readWriteMode)\r\n   at DocumentFormat.OpenXml.Packaging.PresentationDocument.Open(Stream stream, Boolean isEditable, OpenSettings openSettings)\r\n   at DocumentFormat.OpenXml.Packaging.PresentationDocument.Open(Stream stream, Boolean isEditable)\r\n   at StrategyCompass.Common.ArtifactAccess.UnitTests.TestSharePointDocUpload.OpenAndClose(IReadOnlyStorageAccessInfo \r\n...`\r\n\r\nEven the \"corrupted\" file can be opened from SharePoint in a PowerPoint browser app. After a small change, it is saved automatically and after this I can reopen and save it as often as I like to. It seems as if this has a healing effect on the file. \r\n\r\nI know that different opening and saving mechanisms use different methods optimizing OpenXml files. I know as well that these mechanisms use different zippers, but I cannot steer, to use right one for my file.\r\n\r\nComparing both files (corrupted and healed) shows that the CustomXmlParts are reorganized and renumbered in the healed one. By I cannot find a crucial difference.\r\n\r\nThe question is, what is going wrong or is processed different in \"MS.Internal.IO.Zip.ZipIOLocalFileBlock.Validate\"? What can it\r\n not accept that is accepted elsewhere?\r\n\r\n[CorruptedAtSecondOpen.pptx](https://github.com/OfficeDev/Open-XML-SDK/files/8251294/CorruptedAtSecondOpen.pptx)\r\n\r\n**Information**\r\n\r\n- .NET Target: Net4.8\r\n- DocumentFormat.OpenXml Version: (2.15.0)\r\n\r\n**Repro**\r\n\r\n```csharp\r\n        private bool OpenCloseAndSave(IReadOnlyStorageAccessInfo presAccessInfo)\r\n        {\r\n            try\r\n            {\r\n                using (MemoryStream memStream = OpenPresentationAsWritableStream(presAccessInfo))\r\n                {\r\n                    using (var presentationDocument = PresentationDocument.Open(memStream, true))\r\n                    {\r\n                        // Save the presentation.\r\n                        presentationDocument.PresentationPart.Presentation.Save();\r\n                        presentationDocument.Save();\r\n                        presentationDocument.Close();\r\n\r\n                        if (presAccessInfo is IEditableStorageAccessInfo editablePresentationStorageInfo)\r\n                        {\r\n                            editablePresentationStorageInfo.SaveStream(memStream);\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Logging.Log.Error(nameof(TestSharePointDocUpload), nameof(OpenCloseAndSave), ex);\r\n            }\r\n            return false;\r\n        }\r\n``` \r\n\r\n**Observed**\r\n\r\nOpening a by user unchanged file for the second time causes a \"file contains corrupted data\" error. \r\n\r\n**Expected**\r\n\r\nOpening a by user unchanged file for the second time should be opened without error as it was openend for the first time.\r\n"},{"Id":"20736093985","Type":"IssuesEvent","CreatedAt":"2022-03-14T13:52:23","Actor":"andrewmolyneux","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/1133","RelatedDescription":"Closed issue \"Support for modern comments in presentation files?\" (#1133) at OfficeDev/Open-XML-SDK","RelatedBody":"I've recently implemented support for comments in my code (finding comment XML via the SlideCommentsPart property of SlidePart) but I've noticed that it doesn't pick up \"modern\" comments which apparently were implemented in Office 365 starting in late 2020 or early 2021. Is support for this on the roadmap to be added to the SDK, or should I roll my own solution?"}],"ResultType":"GitHubEvent"}},"RunOn":"2022-03-18T03:30:24.879838Z","RunDurationInMilliseconds":597}