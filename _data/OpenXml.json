{"Data":{"Sdk":{"Events":[{"Id":"27429295445","Type":"PullRequestEvent","CreatedAt":"2023-03-01T23:14:29","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1351","RelatedDescription":"Opened pull request \"fix casing on customXml folder. This fixes #1350\" (#1351) at dotnet/Open-XML-SDK","RelatedBody":""},{"Id":"27419787586","Type":"IssuesEvent","CreatedAt":"2023-03-01T15:59:29","Actor":"SimonSchwendele","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1350","RelatedDescription":"Opened issue \"CustomXmlPart incorrectly created as \"customXML\" rather than \"customXml\"\" (#1350) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nWhen I create a new CustomXmlPart in an existing document it is created in \"./customXML/item[id].xml\" whereas \r\nword created the directory as \"./customXml\" rendering the document incomplete.\r\n\r\nSteps to reproduce the behavior:\r\n\r\n```csharp\r\n\r\nvar xmlPart =  \"\"\"\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n  <test:testCustom xmlns:test=\"http://testag.ch/testCustom\">\r\n    <test:CMX_LoremIpsum>\r\n      <test:Para1>Lorem Ipsum</test:Para1>\r\n      <test:Para2>Dolor sit amet</test:Para2>\r\n      <test:Para3>Consectetur adipiscing elit</test:Para3>\r\n      <test:Para4>den Rest müsste ich googlen</test:Para4>\r\n    </test:CMX_LoremIpsum>\r\n    <test:CMX_DummyTexts>\r\n      <test:Text1>Some text for Field 'Text1'</test:Text1>\r\n      <test:Text2>(ノಠ益ಠ)ノ彡┻━┻</test:Text2>\r\n    </test:CMX_DummyTexts>\r\n  </test:testCustom>\r\n\"\"\";\r\n\r\nvar part = Document.GetOrCreateCmiCustomXmlPart();\r\nusing var partStream = part.GetStream(FileMode.Create,\r\n                                              FileAccess.ReadWrite);\r\n\r\nif (partStream.CanSeek)\r\n            partStream.Seek(0, SeekOrigin.Begin);\r\n\r\nvar doc = XDocument.Parse(xmlPart);\r\n\r\nusing var xmlWriter = XmlWriter.Create(partStream);\r\ndoc.Save(xmlWriter);\r\n\r\n\r\n\r\n    public static CustomXmlPart GetOrCreateCustomXmlPart(this WordprocessingDocument wordDoc,\r\n                                                         string partId)\r\n    {\r\n        wordDoc.MainDocumentPart!.TryGetPartById(partId,\r\n                                                 out var found);\r\n        var part = found as CustomXmlPart;\r\n\r\n        part ??= wordDoc.MainDocumentPart!.AddCustomXmlPart(CustomXmlPartType.CustomXml,\r\n                                                            partId);\r\n\r\n        var customXmlProps = part.CustomXmlPropertiesPart ?? part.AddNewPart<CustomXmlPropertiesPart>();\r\n        customXmlProps.DataStoreItem ??= new DataStoreItem() { ItemId = Guid.NewGuid().ToString(\"B\") };\r\n\r\n        return part;\r\n    }\r\n```\r\n\r\n**Observed behavior**\r\n`AddCustomXmlPart` appears to create a new directory **customXML**:\r\n```bash\r\n├── [Content_Types].xml\r\n├── customXml\r\n│   ├── item1.xml\r\n│   ├── item2.xml\r\n│   ├── item3.xml\r\n│   ├── item4.xml\r\n│   ├── itemProps1.xml\r\n│   ├── itemProps2.xml\r\n│   ├── itemProps3.xml\r\n│   ├── itemProps4.xml\r\n│   └── _rels\r\n│       ├── item1.xml.rels\r\n│       ├── item2.xml.rels\r\n│       ├── item3.xml.rels\r\n│       └── item4.xml.rels\r\n├── customXML\r\n│   ├── item5.xml\r\n│   ├── itemProps5.xml\r\n│   └── _rels\r\n│       └── item5.xml.rels\r\n├── docProps\r\n│   ├── app.xml\r\n│   ├── core.xml\r\n│   └── custom.xml\r\n├── _rels\r\n└── word\r\n    ├── document.xml\r\n    ├── fontTable.xml\r\n    ├── glossary\r\n    │   ├── document.xml\r\n    │   ├── fontTable.xml\r\n    │   ├── _rels\r\n    │   │   └── document.xml.rels\r\n    │   ├── settings.xml\r\n    │   ├── styles.xml\r\n    │   └── webSettings.xml\r\n    ├── _rels\r\n    │   └── document.xml.rels\r\n    ├── settings.xml\r\n    ├── styles.xml\r\n    ├── theme\r\n    │   └── theme1.xml\r\n    └── webSettings.xml\r\n\r\n12 directories, 32 files\r\n```\r\n\r\n**Expected behavior**\r\nThe new files should be created within **customXml**\r\n\r\n```bash\r\n.\r\n├── [Content_Types].xml\r\n├── customXml\r\n│   ├── item1.xml\r\n│   ├── item2.xml\r\n│   ├── item3.xml\r\n│   ├── item4.xml\r\n│   ├── item5.xml\r\n│   ├── itemProps1.xml\r\n│   ├── itemProps2.xml\r\n│   ├── itemProps3.xml\r\n│   ├── itemProps4.xml\r\n│   ├── itemProps5.xml\r\n│   └── _rels\r\n│       ├── item1.xml.rels\r\n│       ├── item2.xml.rels\r\n│       ├── item3.xml.rels\r\n│       ├── item4.xml.rels\r\n│       └── item5.xml.rels\r\n├── docProps\r\n│   ├── app.xml\r\n│   ├── core.xml\r\n│   └── custom.xml\r\n├── _rels\r\n└── word\r\n    ├── document.xml\r\n    ├── fontTable.xml\r\n    ├── glossary\r\n    │   ├── document.xml\r\n    │   ├── fontTable.xml\r\n    │   ├── _rels\r\n    │   │   └── document.xml.rels\r\n    │   ├── settings.xml\r\n    │   ├── styles.xml\r\n    │   └── webSettings.xml\r\n    ├── _rels\r\n    │   └── document.xml.rels\r\n    ├── settings.xml\r\n    ├── styles.xml\r\n    ├── theme\r\n    │   └── theme1.xml\r\n    └── webSettings.xml\r\n\r\n10 directories, 32 files\r\n```\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows Server 2022 / Fedora 37\r\n - Office version -\r\n - .NET Target: .NET Framework 4.8\r\n - DocumentFormat.OpenXml Version: 2.19.0\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n"},{"Id":"27402513112","Type":"IssuesEvent","CreatedAt":"2023-03-01T02:30:33","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1349","RelatedDescription":"Opened issue \"Ensure a package only references the types *needed*\" (#1349) at dotnet/Open-XML-SDK","RelatedBody":"Currently, there are some generated helper features/methods that will unintentionally link types together that may never be needed. For example, parts that are only for spreadsheets will be referenced by a word document. This prevents the IL trimmer from removing unused code for purposes of trimming and AOT.\r\n\r\nSpecifically, we should:\r\n\r\n- [ ] Implement package specific implementations of `IRootElementFactory`\r\n- [ ] Ensure any element activation code is only linked via pathways where it will be used"},{"Id":"27402483810","Type":"IssuesEvent","CreatedAt":"2023-03-01T02:28:11","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1348","RelatedDescription":"Opened issue \"Enable better AOT support for SDK\" (#1348) at dotnet/Open-XML-SDK","RelatedBody":"This is an issue to track all related issues for AOT compatibility that we may try to do for v3.0. This is a continuation of issue #753.\r\n\r\nWork to investigate so far (which may overlap with some needs for #1313):\r\n\r\n- [ ] A single generated file is used for all the root part generation - this would need to be separated out to be per-document type\r\n- [ ] TypedOpenXmlPartReader was introduced in 2.19 as a type that provides the typed factories for use of OpenXmlPartReader with just a stream. This would need to be replaced with a doc specific one\r\n- [ ] https://github.com/dotnet/Open-XML-SDK/issues/1347"},{"Id":"27402446312","Type":"IssuesEvent","CreatedAt":"2023-03-01T02:25:19","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1347","RelatedDescription":"Opened issue \"Consider replacing enum usage with readonly structs\" (#1347) at dotnet/Open-XML-SDK","RelatedBody":"There are many enums that are generated for use with the SDK. In order to convert between a string representation and the enum value itself, we must use reflection to grab the `EnumStringAttribute` value. This ends up adding around 20% of the size of an AOT compiled assembly.\r\n\r\nI propose we switch the enums to readonly structs that can contain all the information:\r\n\r\n```csharp\r\npublic class EnumValue<T> : OpenXmlSimpleValue<T>\r\n    where T : struct, IEnumValue, IEnumValueFactory<T>\r\n{\r\n...\r\n}\r\n\r\npublic interface IEnumValue\r\n{\r\n    /// <summary>\r\n    /// Gets a value indicating whether the current value is valid.\r\n    /// </summary>\r\n    bool IsValid { get; }\r\n\r\n    /// <summary>\r\n    /// Gets the version this type was introduced in.\r\n    /// </summary>\r\n    FileFormatVersions Version { get; }\r\n\r\n    /// <summary>\r\n    /// Gets the value of the enum.\r\n    /// </summary>\r\n    string Value { get; }\r\n}\r\n\r\npublic interface IEnumValueFactory<T>\r\n    where T : IEnumValue\r\n{\r\n    /// <summary>\r\n    /// Creates an enum value with the supplied value.\r\n    /// </summary>\r\n    /// <param name=\"value\">Value of enum</param>\r\n    /// <returns>Constructed enum.</returns>\r\n    T Create(string value);\r\n}\r\n```\r\n\r\nAn example of the change would be:\r\n\r\n```cs\r\npublic enum ClipboardFormatValues\r\n{\r\n    /// <summary>\r\n    /// WMF.\r\n    /// <para>When the item is serialized out as xml, its value is \"PictOld\".</para>\r\n    /// </summary>\r\n    [EnumString(\"PictOld\")]\r\n    PictureOld,\r\n    /// <summary>\r\n    /// EMF.\r\n    /// <para>When the item is serialized out as xml, its value is \"Pict\".</para>\r\n    /// </summary>\r\n    [EnumString(\"Pict\")]\r\n    Picture,\r\n    /// <summary>\r\n    /// Bitmap.\r\n    /// <para>When the item is serialized out as xml, its value is \"Bitmap\".</para>\r\n    /// </summary>\r\n    [EnumString(\"Bitmap\")]\r\n    Bitmap,\r\n    /// <summary>\r\n    /// Printer Picture.\r\n    /// <para>When the item is serialized out as xml, its value is \"PictPrint\".</para>\r\n    /// </summary>\r\n    [EnumString(\"PictPrint\")]\r\n    PicturePrint,\r\n    /// <summary>\r\n    /// Screen Picture EMF.\r\n    /// <para>When the item is serialized out as xml, its value is \"PictScreen\".</para>\r\n    /// </summary>\r\n    [EnumString(\"PictScreen\")]\r\n    PictureScreen\r\n}\r\n```\r\n\r\nwould be \r\n\r\n```cs\r\npublic readonly record struct ClipboardFormatValues : IEnumValue, IEnumValueFactory<ClipboardFormatValues>\r\n{\r\n    private readonly string? _value;\r\n    /// <summary>\r\n    /// Creates a new ClipboardFormatValues enum instance\r\n    /// </summary>\r\n    public ClipboardFormatValues(string value) => _value = value;\r\n    ClipboardFormatValues IEnumValueFactory<ClipboardFormatValues>.Create(string name) => new(name);\r\n    bool IEnumValue.IsValid => InternalValue switch\r\n    {\r\n        \"PictOld\" => true,\r\n        \"Pict\" => true,\r\n        \"Bitmap\" => true,\r\n        \"PictPrint\" => true,\r\n        \"PictScreen\" => true,\r\n        _ => false\r\n    };\r\n    string IEnumValue.Value => InternalValue;\r\n    private string InternalValue => _value ?? \"PictOld\";\r\n    FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;\r\n    /// <summary>\r\n    /// WMF.\r\n    /// <para>When the item is serialized out as xml, its value is \"PictOld\".</para>\r\n    /// </summary>\r\n    public static ClipboardFormatValues PictureOld => new(\"PictOld\");\r\n    /// <summary>\r\n    /// EMF.\r\n    /// <para>When the item is serialized out as xml, its value is \"Pict\".</para>\r\n    /// </summary>\r\n    public static ClipboardFormatValues Picture => new(\"Pict\");\r\n    /// <summary>\r\n    /// Bitmap.\r\n    /// <para>When the item is serialized out as xml, its value is \"Bitmap\".</para>\r\n    /// </summary>\r\n    public static ClipboardFormatValues Bitmap => new(\"Bitmap\");\r\n    /// <summary>\r\n    /// Printer Picture.\r\n    /// <para>When the item is serialized out as xml, its value is \"PictPrint\".</para>\r\n    /// </summary>\r\n    public static ClipboardFormatValues PicturePrint => new(\"PictPrint\");\r\n    /// <summary>\r\n    /// Screen Picture EMF.\r\n    /// <para>When the item is serialized out as xml, its value is \"PictScreen\".</para>\r\n    /// </summary>\r\n    public static ClipboardFormatValues PictureScreen => new(\"PictScreen\");\r\n\r\n}\r\n```\r\n\r\n## Benefits:\r\n- Enums are user definable if needed now\r\n- Massive size improvement for AOT compilation (20% reduction)\r\n- No reflection needed\r\n- Generally source compatible\r\n\r\n## Downsides:\r\n- Non-AOT assembly sees a 8% increase in size\r\n- Enum values no longer work in constant situations (i.e. as attribute values)"},{"Id":"27366015734","Type":"PullRequestEvent","CreatedAt":"2023-02-27T19:14:05","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1346","RelatedDescription":"Merged pull request \"Update SDK to 7.0.200\" (#1346) at dotnet/Open-XML-SDK","RelatedBody":""},{"Id":"27333908159","Type":"PullRequestEvent","CreatedAt":"2023-02-26T00:33:46","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1346","RelatedDescription":"Opened pull request \"Update SDK to 7.0.200\" (#1346) at dotnet/Open-XML-SDK","RelatedBody":""},{"Id":"27325344984","Type":"PullRequestEvent","CreatedAt":"2023-02-25T01:22:20","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1345","RelatedDescription":"Opened pull request \"Convert LINQ generator to run as source generator\" (#1345) at dotnet/Open-XML-SDK","RelatedBody":"This change integrates the LINQ generator with the source generator infrastructure so things will stay up-to-date as well as use a single source of truth.\n"}],"ResultType":"GitHubEvent"}},"RunOn":"2023-03-02T03:30:27.9127015Z","RunDurationInMilliseconds":747}