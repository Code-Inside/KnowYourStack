{"Data":{"Sdk":{"Events":[{"Id":"15777298981","Type":"IssuesEvent","CreatedAt":"2021-04-01T06:07:51","Actor":"Jenifer-TheCoder","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/915","RelatedDescription":"Opened issue \"Replacing sdtelement in dotx file with HTML that has hyperlink doesn't work\" (#915) at OfficeDev/Open-XML-SDK","RelatedBody":"\r\n**Description**\r\n\r\nI am trying to replace dotx sdtElement with html content that has hyperlink, but the link doesn't work. w:hyperlink's relationship with link doesn't seem to be working.\r\n\r\n**Information**\r\n\r\n- .NET Target: NET Framework 4.8\r\n- DocumentFormat.OpenXml Version: 2.0.5022.0\r\n\r\n**Issue in depth:**\r\n\r\n- I have a dotx file which has [Text] that has to be replaced with html that has \r\n<body <a href=\"www.google.com>How are You\">\r\n</a>Hi\r\n</body>\r\n\r\n- Replacement happens with just text  but hyperlink doesn't seem to be working. Instead of www.google.com, it has hyperlink of <localhost>\\word\\settings.xml\r\n- Could see the convertedelement has w:hyperlink on it but still unable to retrieve hyperlink \r\n- Do i need to add anything more to Run/Paragraph-properties to get hyperlink working?\r\n\r\nThe function that replaces sdtelement is as follows:\r\n`private void WriteReplacementHtml(W.SdtElement sdtElement, Stream wordMLStream)\r\n        {\r\n            // Replace spaces between images and texts with non breaking spaces\r\n            // http://stackoverflow.com/questions/43659775/regex-to-match-images-followed-with-a-space-in-an-html-string\r\n            html = WordMLTemplateProcessor.ImageFollowedWithSpaceRegex.Replace(html, \"$1&nbsp;\");\r\n\r\n            try\r\n            {\r\n\r\n                WordprocessingDocument convertedDocument = WordprocessingDocument.Open(wordMLStream, false);\r\n                var convertedElements = convertedDocument.MainDocumentPart.RootElement.Descendants<W.Body>().Single().Elements();\r\n                // Skim the fat (SectionProperties) or risk screwing up your document\r\n                convertedElements = convertedElements.Except(convertedElements.OfType<W.SectionProperties>()).ToArray();\r\n                try\r\n                {\r\n                    List<int> numberingIdsProcessed = new List<int>();\r\n\r\n                    OpenXmlElement paragraphProperties = null;\r\n                    OpenXmlElement runProperties = null;\r\n\r\n                    List<OpenXmlElement> insertedElements = new List<OpenXmlElement>();\r\n\r\n                    // Find the first parent that can contain a block such as a paragraph or a table,\r\n                    // and keep track of the element before which we'll have to insert content\r\n                    for (OpenXmlElement sdtParent = sdtElement.Parent, sdtInsertBefore = sdtElement;\r\n                        sdtParent != null;\r\n                        sdtInsertBefore = sdtParent, sdtParent = sdtParent.Parent)\r\n                    {\r\n                        // Save the paragraph and run properties of the element (if not yet done)\r\n                        if (paragraphProperties == null) paragraphProperties = sdtInsertBefore.Descendants<W.ParagraphProperties>().FirstOrDefault();\r\n                        if (runProperties == null)\r\n                        {\r\n                            W.SdtElement element = sdtInsertBefore as W.SdtElement;\r\n                            if (element != null)\r\n                                runProperties = element.SdtProperties.Descendants<W.RunProperties>().FirstOrDefault();\r\n                        }\r\n\r\n                        // Can the parent contain a paragraph or table?\r\n                        if (sdtParent is W.Body\r\n                            || sdtParent is W.Comment\r\n                            || sdtParent is W.CustomXmlBlock\r\n                            || sdtParent is W.DocPartBody\r\n                            || sdtParent is W.Endnote\r\n                            || sdtParent is W.Footnote\r\n                            || sdtParent is W.Footer\r\n                            || sdtParent is W.Header\r\n                            || sdtParent is W.SdtContentBlock\r\n                            || sdtParent is W.TableCell)\r\n                        {\r\n                            // Insert the converted elements as they come\r\n                            foreach (OpenXmlElement convertedElement in convertedElements)\r\n                            {\r\n                                // Insert the element\r\n                                OpenXmlElement insertedElement = convertedElement.CloneNode(true);\r\n                                sdtInsertBefore.InsertBeforeSelf(insertedElement);\r\n                                var hpElement = insertedElement.Descendants<W.Hyperlink>().FirstOrDefault();\r\n                                if (hpElement != null)\r\n                                {\r\n                                    string relationId = hpElement.Id;\r\n                                    if (relationId != string.Empty)\r\n                                    {\r\n                                        // get current relation\r\n                                        var hr = convertedDocument.MainDocumentPart.HyperlinkRelationships.FirstOrDefault(a => a.Id == relationId);\r\n                                        if (hr == null) continue;\r\n                                        var fieldName = hr.Uri.ToString();\r\n                                        \r\n                                    }\r\n                                }\r\n\r\n                                // Import its numbering from the converted document while avoid conflicts with\r\n                                // numbering IDs in the current document.\r\n                                ResetNumbering(insertedElement, convertedDocument.MainDocumentPart.NumberingDefinitionsPart, numberingIdsProcessed);\r\n\r\n                                // Copy the run properties to each run element\r\n                                if (runProperties != null)\r\n                                {\r\n                                    foreach (W.Run run in insertedElement.Descendants<W.Run>())\r\n                                    {\r\n                                        run.InsertAt<OpenXmlElement>(runProperties.CloneNode(true), 0);\r\n                                    }\r\n                                }\r\n\r\n                                // Copy the paragraph properties to the paragraph\r\n                                if (paragraphProperties != null)\r\n                                {\r\n                                    if (insertedElement is W.Paragraph)\r\n                                    {\r\n                                        // Copy the paragraph properties\r\n                                        insertedElement.InsertAt<OpenXmlElement>(paragraphProperties.CloneNode(true), 0);\r\n                                        // If the paragraph properties represent a list item, reset it\r\n                                        // in order to avoid inserting next converted paragraphs as extra list items\r\n                                        W.ParagraphStyleId paragraphStyle = ((W.ParagraphProperties)paragraphProperties).ParagraphStyleId;\r\n                                        if (paragraphStyle != null && paragraphStyle.Val == \"ListParagraph\")\r\n                                        {\r\n                                            paragraphProperties = null;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                // Add to the list of inserted elements\r\n                                insertedElements.Add(insertedElement);\r\n                            }\r\n\r\n                            // Remove the replaced element\r\n                            W.SdtBlock sdtBlock = sdtElement as W.SdtBlock;\r\n                            if (sdtBlock != null)\r\n                            {\r\n                                sdtBlock.SdtContentBlock.RemoveAllChildren();\r\n                            }\r\n                            else\r\n                            {\r\n                                // Get the tag associated with the replaced element\r\n                                W.Tag tag = sdtElement.SdtProperties.Elements<W.Tag>().FirstOrDefault();\r\n\r\n                                // Find the highest parent that contains the replaced tag (and only this one)\r\n                                OpenXmlElement sdtDelete = null;\r\n                                for (OpenXmlElement sdtCandidate = sdtElement.Parent;\r\n                                    sdtCandidate != sdtParent; \r\n                                    sdtCandidate = sdtCandidate.Parent)\r\n                                {\r\n                                    // Does the candidate contains the replaced tag and only it?\r\n                                    IEnumerable<W.Tag> tags = sdtCandidate.Descendants<W.Tag>().ToArray();\r\n                                    if (tags.Count() == 1 && tags.First() == tag)\r\n                                    {\r\n                                        // Save it for deletion\r\n                                        sdtDelete = sdtCandidate;\r\n                                        continue;\r\n                                    }\r\n\r\n                                    // Stop\r\n                                    break;\r\n                                }\r\n\r\n                                // Delete it\r\n                                if (sdtDelete != null)\r\n                                    sdtDelete.Remove();\r\n                            }\r\n                                // Stop\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                }\r\n                finally\r\n                {\r\n                    // convertedDocument.Dispose() also disposes the stream it was instantiated with (i.e. wordMLStream)\r\n                    convertedDocument.Dispose();\r\n                    wordMLStream = null;\r\n                }\r\n            }\r\n\r\n        }`\r\n\r\n\r\n**Observed**\r\n\r\nHyperlink does't work with convertedlement having w:hyperlink node\r\n\r\n**Expected**\r\n\r\nHyperlink should work post replacement in dotx file"},{"Id":"15755927861","Type":"IssuesEvent","CreatedAt":"2021-03-31T02:37:39","Actor":"swiftinitdotcom","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/914","RelatedDescription":"Opened issue \"is there any latest productvity tool like 2.5\" (#914) at OfficeDev/Open-XML-SDK","RelatedBody":"\r\nhttps://www.microsoft.com/en-in/download/details.aspx?id=30425\r\nis there any latest?\r\n"},{"Id":"15726888341","Type":"IssuesEvent","CreatedAt":"2021-03-29T11:57:26","Actor":"clement911","Repository":"OfficeDev/Open-XML-SDK","Organization":"OfficeDev","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/OfficeDev/Open-XML-SDK/issues/913","RelatedDescription":"Opened issue \"Writing asynchronously with OpenXmlWriter\" (#913) at OfficeDev/Open-XML-SDK","RelatedBody":"The `OpenXmlWriter` doesn't appear to have any async overloads.\r\nIs it not possible to write in a asynchronous fashion?"}],"ResultType":"GitHubEvent"},"PowerTools":{"Events":[],"ResultType":"GitHubEvent"}},"RunOn":"2021-04-05T05:30:32.1947187Z","RunDurationInMilliseconds":747}