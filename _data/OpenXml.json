{"Data":{"Sdk":{"Events":[{"Id":"40505452373","Type":"IssuesEvent","CreatedAt":"2024-07-26T19:20:57","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1755","RelatedDescription":"Closed issue \"Unable to Write Shared String Table Part using OpenXmlWriter\" (#1755) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nWhen using the OpenXmlWriter to write the Shared String Table part, the resulting sharedStrings.xml document saved to disk does not contain any string items. I've created a very simple script that creates an excel document, a default sheet, and tries to updated the shared string table to contain one entry. (The next step would be to use OpenXmlWriter to write one row with one cell with shared string value)\r\n\r\n**To Reproduce**\r\n```\r\nCancellationToken ct = CancellationToken.None;\r\n\r\nvoid Main()\r\n{\r\n\tusing (FileStream destinationFileStream = File.Create(@\"C:\\temp\\Simple_Doc_Using_OpenXml_Sax_SharedString.xlsx\", 1024 * 16))\r\n\tusing (var destinationSpreadsheetDocument = CreateNewSpreadsheet(destinationFileStream))\r\n\t{\r\n\t\tvar newWorksheetPart = CreateWorksheet(destinationSpreadsheetDocument, \"Sheet1\");\r\n\t\t\r\n\t\t// Use XmlWriter to write the SharedString contents - SAX model - writing start to end\r\n\t\tusing (var sharedStringTablePartWriter = OpenXmlWriter.Create(destinationSpreadsheetDocument.WorkbookPart.SharedStringTablePart))\r\n\t\t{\r\n\t\t\tsharedStringTablePartWriter.WriteStartDocument();\r\n\t\t\tsharedStringTablePartWriter.WriteStartElement(new SharedStringTable());\r\n\r\n\t\t\tsharedStringTablePartWriter.WriteElement(new SharedStringItem(new Text(\"Is Current\")));\r\n\r\n\t\t\t// End tag for SharedStringTable element.\r\n\t\t\tsharedStringTablePartWriter.WriteEndElement();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nSpreadsheetDocument CreateNewSpreadsheet(Stream stream)\r\n{\r\n\tSpreadsheetDocument newDoc = SpreadsheetDocument.Create(stream, SpreadsheetDocumentType.Workbook);\r\n\r\n\t// Add a WorkbookPart to the document.\r\n\tWorkbookPart workbookPart = newDoc.AddWorkbookPart();\r\n\t//workbookPart.Workbook = new Workbook();\r\n\r\n\t// Add Sheets section to the Workbook.\r\n\t//Sheets sheets = newDoc.WorkbookPart.Workbook.AppendChild<Sheets>(new Sheets());\r\n\r\n\t// Add a SharedStringTablePart to the WorkbookPart.\r\n\tSharedStringTablePart sharedStringTablePart = workbookPart.AddNewPart<SharedStringTablePart>();\r\n\tsharedStringTablePart.SharedStringTable = new SharedStringTable();\r\n\r\n\t// Add a WorkbookStylesPart to the WorkbookPart, and create default styles.\r\n\tWorkbookStylesPart workStylePart = workbookPart.AddNewPart<WorkbookStylesPart>();\r\n\tworkStylePart.Stylesheet = new Stylesheet();\r\n\r\n\tworkStylePart.Stylesheet.Borders = new Borders() { Count = 1 };\r\n\tworkStylePart.Stylesheet.Borders.AppendChild(new Border { LeftBorder = new LeftBorder(), RightBorder = new RightBorder(), TopBorder = new TopBorder(), BottomBorder = new BottomBorder(), DiagonalBorder = new DiagonalBorder() });\r\n\r\n\tworkStylePart.Stylesheet.CellFormats = new CellFormats() { Count = 1 };\r\n\tworkStylePart.Stylesheet.CellFormats.AppendChild(new CellFormat { NumberFormatId = 0, FontId = 0, FillId = 0, BorderId = 0 }); // empty one for index 0, seems to be required\r\n\r\n\tworkStylePart.Stylesheet.CellStyleFormats = new CellStyleFormats() { Count = 1 };\r\n\tworkStylePart.Stylesheet.CellStyleFormats.AppendChild(new CellFormat { NumberFormatId = 0, FontId = 0, FillId = 0, BorderId = 0, FormatId = 0 });\r\n\r\n\tworkStylePart.Stylesheet.DifferentialFormats = new DifferentialFormats() { Count = 0 };\r\n\r\n\tworkStylePart.Stylesheet.Fills = new Fills() { Count = 2 };\r\n\tworkStylePart.Stylesheet.Fills.AppendChild(new Fill { PatternFill = new PatternFill { PatternType = PatternValues.None } }); // required, reserved by Excel\r\n\tworkStylePart.Stylesheet.Fills.AppendChild(new Fill { PatternFill = new PatternFill { PatternType = PatternValues.Gray125 } }); // required, reserved by Excel\r\n\r\n\tworkStylePart.Stylesheet.Fonts = new Fonts() { Count = 1 };\r\n\tworkStylePart.Stylesheet.Fonts.AppendChild(\r\n\t\tnew Font()\r\n\t\t{\r\n\t\t\tFontName = new FontName() { Val = \"Calibri\" },\r\n\t\t\tFontSize = new FontSize() { Val = 11 }\r\n\t\t});\r\n\r\n\tworkStylePart.Stylesheet.TableStyles = new TableStyles() { Count = 0, DefaultTableStyle = \"TableStyleMedium2\", DefaultPivotStyle = \"PivotStyleLight16\" };\r\n\r\n\treturn newDoc;\r\n}\r\n\r\nWorksheetPart CreateWorksheet(SpreadsheetDocument doc, string sheetName)\r\n{\r\n\tvar newWorksheetPart = doc.WorkbookPart.AddNewPart<WorksheetPart>();\r\n\t\r\n\t// Updating the workbook part done via DOM since we just want to append a sheet to the end, and the workbook xml is not so large, loading it into memory won't be a significan cost.\r\n\tif (doc.WorkbookPart.Workbook == null)\r\n\t{\r\n\t\tdoc.WorkbookPart.Workbook = new Workbook();\r\n\t}\r\n\t\r\n\tif (doc.WorkbookPart.Workbook.Sheets == null)\r\n\t{\r\n\t\tdoc.WorkbookPart.Workbook.Sheets = new Sheets();\r\n\t}\r\n\r\n\tSheet sheet = new Sheet() { Id = doc.WorkbookPart.GetIdOfPart(newWorksheetPart), SheetId = Convert.ToUInt32(doc.WorkbookPart.Workbook.Sheets.Count() + 1), Name = sheetName };\r\n\tdoc.WorkbookPart.Workbook.Sheets.Append(sheet);\r\n\r\n\t// Saves data in Workbook DOM tree back to the WorkbookPart.\r\n\tdoc.WorkbookPart.Workbook.Save();\r\n\r\n\treturn newWorksheetPart;\r\n}\r\n```\r\n\r\nSteps to reproduce the behavior:\r\n1. Execute Main method\r\n2. Rename xlsx file to .zip file\r\n3. Extract contents of zip file\r\n4. Review contents of sharedStrings.xml in text editor. Observe issue, that no Shared String has been added.\r\n\r\n**Observed behavior**\r\nThe sharedStrings.xml is minimal, containing only the xml root tag and shared string table tag, with no children.\r\n\r\n**Expected behavior**\r\nThe sharedStrings.xml should have xml defining a shared string item with child Text item with value \"Is Current\"\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows\r\n - Office version [e.g. 16.0.15427.20178]\r\n - .NET Target: (e.g. .NET Framework, .NET Core, UWP, Xamarin...)\r\n - DocumentFormat.OpenXml Version 3.0.2\r\n\r\n**Additional context**\r\nI need to use the SAX model using OpenXmlWriter to write the content, and not the DOM model, as I'm working with large data sets across multiple spreadsheets and doing merge/copy operations, and need to be mindful of memory usage.\r\n"},{"Id":"40505452361","Type":"IssuesEvent","CreatedAt":"2024-07-26T19:20:57","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1755","RelatedDescription":"Closed issue \"Unable to Write Shared String Table Part using OpenXmlWriter\" (#1755) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nWhen using the OpenXmlWriter to write the Shared String Table part, the resulting sharedStrings.xml document saved to disk does not contain any string items. I've created a very simple script that creates an excel document, a default sheet, and tries to updated the shared string table to contain one entry. (The next step would be to use OpenXmlWriter to write one row with one cell with shared string value)\r\n\r\n**To Reproduce**\r\n```\r\nCancellationToken ct = CancellationToken.None;\r\n\r\nvoid Main()\r\n{\r\n\tusing (FileStream destinationFileStream = File.Create(@\"C:\\temp\\Simple_Doc_Using_OpenXml_Sax_SharedString.xlsx\", 1024 * 16))\r\n\tusing (var destinationSpreadsheetDocument = CreateNewSpreadsheet(destinationFileStream))\r\n\t{\r\n\t\tvar newWorksheetPart = CreateWorksheet(destinationSpreadsheetDocument, \"Sheet1\");\r\n\t\t\r\n\t\t// Use XmlWriter to write the SharedString contents - SAX model - writing start to end\r\n\t\tusing (var sharedStringTablePartWriter = OpenXmlWriter.Create(destinationSpreadsheetDocument.WorkbookPart.SharedStringTablePart))\r\n\t\t{\r\n\t\t\tsharedStringTablePartWriter.WriteStartDocument();\r\n\t\t\tsharedStringTablePartWriter.WriteStartElement(new SharedStringTable());\r\n\r\n\t\t\tsharedStringTablePartWriter.WriteElement(new SharedStringItem(new Text(\"Is Current\")));\r\n\r\n\t\t\t// End tag for SharedStringTable element.\r\n\t\t\tsharedStringTablePartWriter.WriteEndElement();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nSpreadsheetDocument CreateNewSpreadsheet(Stream stream)\r\n{\r\n\tSpreadsheetDocument newDoc = SpreadsheetDocument.Create(stream, SpreadsheetDocumentType.Workbook);\r\n\r\n\t// Add a WorkbookPart to the document.\r\n\tWorkbookPart workbookPart = newDoc.AddWorkbookPart();\r\n\t//workbookPart.Workbook = new Workbook();\r\n\r\n\t// Add Sheets section to the Workbook.\r\n\t//Sheets sheets = newDoc.WorkbookPart.Workbook.AppendChild<Sheets>(new Sheets());\r\n\r\n\t// Add a SharedStringTablePart to the WorkbookPart.\r\n\tSharedStringTablePart sharedStringTablePart = workbookPart.AddNewPart<SharedStringTablePart>();\r\n\tsharedStringTablePart.SharedStringTable = new SharedStringTable();\r\n\r\n\t// Add a WorkbookStylesPart to the WorkbookPart, and create default styles.\r\n\tWorkbookStylesPart workStylePart = workbookPart.AddNewPart<WorkbookStylesPart>();\r\n\tworkStylePart.Stylesheet = new Stylesheet();\r\n\r\n\tworkStylePart.Stylesheet.Borders = new Borders() { Count = 1 };\r\n\tworkStylePart.Stylesheet.Borders.AppendChild(new Border { LeftBorder = new LeftBorder(), RightBorder = new RightBorder(), TopBorder = new TopBorder(), BottomBorder = new BottomBorder(), DiagonalBorder = new DiagonalBorder() });\r\n\r\n\tworkStylePart.Stylesheet.CellFormats = new CellFormats() { Count = 1 };\r\n\tworkStylePart.Stylesheet.CellFormats.AppendChild(new CellFormat { NumberFormatId = 0, FontId = 0, FillId = 0, BorderId = 0 }); // empty one for index 0, seems to be required\r\n\r\n\tworkStylePart.Stylesheet.CellStyleFormats = new CellStyleFormats() { Count = 1 };\r\n\tworkStylePart.Stylesheet.CellStyleFormats.AppendChild(new CellFormat { NumberFormatId = 0, FontId = 0, FillId = 0, BorderId = 0, FormatId = 0 });\r\n\r\n\tworkStylePart.Stylesheet.DifferentialFormats = new DifferentialFormats() { Count = 0 };\r\n\r\n\tworkStylePart.Stylesheet.Fills = new Fills() { Count = 2 };\r\n\tworkStylePart.Stylesheet.Fills.AppendChild(new Fill { PatternFill = new PatternFill { PatternType = PatternValues.None } }); // required, reserved by Excel\r\n\tworkStylePart.Stylesheet.Fills.AppendChild(new Fill { PatternFill = new PatternFill { PatternType = PatternValues.Gray125 } }); // required, reserved by Excel\r\n\r\n\tworkStylePart.Stylesheet.Fonts = new Fonts() { Count = 1 };\r\n\tworkStylePart.Stylesheet.Fonts.AppendChild(\r\n\t\tnew Font()\r\n\t\t{\r\n\t\t\tFontName = new FontName() { Val = \"Calibri\" },\r\n\t\t\tFontSize = new FontSize() { Val = 11 }\r\n\t\t});\r\n\r\n\tworkStylePart.Stylesheet.TableStyles = new TableStyles() { Count = 0, DefaultTableStyle = \"TableStyleMedium2\", DefaultPivotStyle = \"PivotStyleLight16\" };\r\n\r\n\treturn newDoc;\r\n}\r\n\r\nWorksheetPart CreateWorksheet(SpreadsheetDocument doc, string sheetName)\r\n{\r\n\tvar newWorksheetPart = doc.WorkbookPart.AddNewPart<WorksheetPart>();\r\n\t\r\n\t// Updating the workbook part done via DOM since we just want to append a sheet to the end, and the workbook xml is not so large, loading it into memory won't be a significan cost.\r\n\tif (doc.WorkbookPart.Workbook == null)\r\n\t{\r\n\t\tdoc.WorkbookPart.Workbook = new Workbook();\r\n\t}\r\n\t\r\n\tif (doc.WorkbookPart.Workbook.Sheets == null)\r\n\t{\r\n\t\tdoc.WorkbookPart.Workbook.Sheets = new Sheets();\r\n\t}\r\n\r\n\tSheet sheet = new Sheet() { Id = doc.WorkbookPart.GetIdOfPart(newWorksheetPart), SheetId = Convert.ToUInt32(doc.WorkbookPart.Workbook.Sheets.Count() + 1), Name = sheetName };\r\n\tdoc.WorkbookPart.Workbook.Sheets.Append(sheet);\r\n\r\n\t// Saves data in Workbook DOM tree back to the WorkbookPart.\r\n\tdoc.WorkbookPart.Workbook.Save();\r\n\r\n\treturn newWorksheetPart;\r\n}\r\n```\r\n\r\nSteps to reproduce the behavior:\r\n1. Execute Main method\r\n2. Rename xlsx file to .zip file\r\n3. Extract contents of zip file\r\n4. Review contents of sharedStrings.xml in text editor. Observe issue, that no Shared String has been added.\r\n\r\n**Observed behavior**\r\nThe sharedStrings.xml is minimal, containing only the xml root tag and shared string table tag, with no children.\r\n\r\n**Expected behavior**\r\nThe sharedStrings.xml should have xml defining a shared string item with child Text item with value \"Is Current\"\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows\r\n - Office version [e.g. 16.0.15427.20178]\r\n - .NET Target: (e.g. .NET Framework, .NET Core, UWP, Xamarin...)\r\n - DocumentFormat.OpenXml Version 3.0.2\r\n\r\n**Additional context**\r\nI need to use the SAX model using OpenXmlWriter to write the content, and not the DOM model, as I'm working with large data sets across multiple spreadsheets and doing merge/copy operations, and need to be mindful of memory usage.\r\n"},{"Id":"40505452055","Type":"PullRequestEvent","CreatedAt":"2024-07-26T19:20:56","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1760","RelatedDescription":"Merged pull request \"Unload root element if Part.GetStream updates the underlying value\" (#1760) at dotnet/Open-XML-SDK","RelatedBody":"Fixes #1755\n"},{"Id":"40505386718","Type":"PullRequestEvent","CreatedAt":"2024-07-26T19:17:47","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1759","RelatedDescription":"Merged pull request \"Office Update for May 2024\" (#1759) at dotnet/Open-XML-SDK","RelatedBody":"### Added\r\n- DocumentFormat.OpenXml.Office.SpreadSheetML.Y2024.PivotAutoRefresh namespace\r\n- DocumentFormat.OpenXml.Office.SpreadSheetML.Y2024.PivotDynamicArrays namespace\r\n\r\n"},{"Id":"40477604646","Type":"PullRequestEvent","CreatedAt":"2024-07-25T22:54:46","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1760","RelatedDescription":"Opened pull request \"Unload root element if Part.GetStream updates the underlying value\" (#1760) at dotnet/Open-XML-SDK","RelatedBody":"Fixes #1755\n"},{"Id":"40471538454","Type":"PullRequestEvent","CreatedAt":"2024-07-25T18:20:04","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1759","RelatedDescription":"Opened pull request \"Office Update for May 2024\" (#1759) at dotnet/Open-XML-SDK","RelatedBody":"### Added\r\n- DocumentFormat.OpenXml.Office.SpreadSheetML.Y2024.PivotAutoRefresh namespace\r\n- DocumentFormat.OpenXml.Office.SpreadSheetML.Y2024.PivotDynamicArrays namespace\r\n\r\n"},{"Id":"40461217377","Type":"IssuesEvent","CreatedAt":"2024-07-25T13:07:04","Actor":"seanblac8","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1758","RelatedDescription":"Opened issue \"Bug with RdRichValueWebImagePart of Open XML SDK\" (#1758) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nIf I use Open XML SDK 3.02 to read a xlsx file, /xl/richData/rdRichValueWebImage.xml of xlsx file is a DocumentFormat.OpenXml.Packaging.ExtendedPart instead of RdRichValueWebImagePart.\r\n\r\nThe workbook has _webimages, but the workbookPart.RdRichValueWebImagePart is null.\r\n\r\n**Screenshots**\r\nIf applicable, add screenshots to help explain your problem.\r\n![image](https://github.com/user-attachments/assets/ea5a0e27-523c-487e-a7d7-3296cb85ee72)\r\n\r\n\r\n**To Reproduce**\r\n// Please add a self-contained, minimum viable repro of the issue.\r\n// If you require external resources, please provide a gist or GitHub repro\r\n// An Xunit style test is preferred, but a console application would work too.\r\n\r\nSteps to reproduce the behavior:\r\n1. Go to '...'\r\n2. Click on '....'\r\n3. Scroll down to '....'\r\n4. See error\r\n\r\n**Observed behavior**\r\nA clear and concise description of what you expected to happen.\r\n\r\n**Expected behavior**\r\nA clear and concise description of what you expected to happen.\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: [e.g. Windows]\r\n - Office version [e.g. 16.0.15427.20178]\r\n - .NET Target: (e.g. .NET Framework, .NET Core, UWP, Xamarin...)\r\n - DocumentFormat.OpenXml Version: (e.g. 2.11.0)\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n"},{"Id":"40439088397","Type":"IssuesEvent","CreatedAt":"2024-07-24T20:45:33","Actor":"tomjebo","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1751","RelatedDescription":"Closed issue \"Found OpenXmlUnknownElement instead of CommentPropertiesExtension\" (#1751) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\n```xml\r\nIn part \\ppt\\comment\\modernComment... part is coded in the SDK metadata as p188:ext. This causes OpenXmlUnknownElement to be assigned as the child of p188:extLst.\r\n       <p188:extLst>\r\n            <p:ext xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\" uri=\"{5BB2D875-25FF-4072-B9AC-8F64D62656EB}\">\r\n                <p228:taskDetails xmlns:p228=\"http://schemas.microsoft.com/office/powerpoint/2022/08/main\">\r\n                    <p228:history>\r\n                        <p228:event time=\"2024-07-16T05:56:24.928\" id=\"{22A90AAB-29DC-4F45-80B8-41660EB3CE91}\">\r\n                            <p228:atrbtn authorId=\"{DDBD2B34-3E97-38F7-B7A9-5BD8D52D7288}\"/>\r\n                            <p228:anchr>\r\n                                <p228:comment id=\"{C5BB4569-00FC-429B-B44C-282847B06E34}\"/>\r\n                            </p228:anchr>\r\n                            <p228:add/>\r\n```\r\n\r\nThis should be fixed on our schema processor.\r\n\r\n**To Reproduce**\r\nCreate a presentation with a modern comment. Then inspect the \\ppt\\comment\\modernCommentXXXX.xml part. The above shows p:ext and that is per the Office schemas. \r\n\r\nHowever, when parsing in SDK code: \r\n\r\n```csharp\r\n    SlidePart sp = pd.PresentationPart.GetPartsOfType<SlidePart>().First();\r\n\r\n    PowerPointCommentPart ppcp = sp.GetPartsOfType<PowerPointCommentPart>().First();\r\n\r\n    if (ppcp.RootElement is null)\r\n    {\r\n        throw new InvalidDataException(\"no root element!\");\r\n    }\r\n\r\n    CommentPropertiesExtensionList cpel = ppcp.RootElement.Descendants<CommentPropertiesExtensionList>().First();\r\n\r\n    if (cpel is null)\r\n    {\r\n        throw new InvalidDataException(\"Presentation modern comment part is missing p188:extlst\");\r\n    }\r\n\r\n    CommentPropertiesExtension cpe = cpel.ChildElements.First<CommentPropertiesExtension>();\r\n    \r\n    if (cpe is null)\r\n    {\r\n// This line will throw because cpe is null due to the p:ext being wrapped by OpenXmlUnknownElement. \r\n// In our patched schemas we code this as p188:ext which is wrong. \r\n        throw new InvalidDataException(\"Presentation modern comment part is missing p188:ext\");\r\n    }\r\n```\r\n**Steps to reproduce the behavior:**\r\nUse the code above to access the ext child element the extLst in a p188:cm block.\r\n\r\n**Observed behavior**\r\n`cpe` is null.\r\n\r\n**Expected behavior**\r\nIn the code above, cpe should be a valid CommentPropertiesExtension object wrapping the p:ext.\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows\r\n - .NET Target: .Net 8.0\r\n - DocumentFormat.OpenXml Version: 3.0.2\r\n\r\n\r\n"},{"Id":"40439088340","Type":"IssuesEvent","CreatedAt":"2024-07-24T20:45:33","Actor":"tomjebo","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1751","RelatedDescription":"Closed issue \"Found OpenXmlUnknownElement instead of CommentPropertiesExtension\" (#1751) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\n```xml\r\nIn part \\ppt\\comment\\modernComment... part is coded in the SDK metadata as p188:ext. This causes OpenXmlUnknownElement to be assigned as the child of p188:extLst.\r\n       <p188:extLst>\r\n            <p:ext xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\" uri=\"{5BB2D875-25FF-4072-B9AC-8F64D62656EB}\">\r\n                <p228:taskDetails xmlns:p228=\"http://schemas.microsoft.com/office/powerpoint/2022/08/main\">\r\n                    <p228:history>\r\n                        <p228:event time=\"2024-07-16T05:56:24.928\" id=\"{22A90AAB-29DC-4F45-80B8-41660EB3CE91}\">\r\n                            <p228:atrbtn authorId=\"{DDBD2B34-3E97-38F7-B7A9-5BD8D52D7288}\"/>\r\n                            <p228:anchr>\r\n                                <p228:comment id=\"{C5BB4569-00FC-429B-B44C-282847B06E34}\"/>\r\n                            </p228:anchr>\r\n                            <p228:add/>\r\n```\r\n\r\nThis should be fixed on our schema processor.\r\n\r\n**To Reproduce**\r\nCreate a presentation with a modern comment. Then inspect the \\ppt\\comment\\modernCommentXXXX.xml part. The above shows p:ext and that is per the Office schemas. \r\n\r\nHowever, when parsing in SDK code: \r\n\r\n```csharp\r\n    SlidePart sp = pd.PresentationPart.GetPartsOfType<SlidePart>().First();\r\n\r\n    PowerPointCommentPart ppcp = sp.GetPartsOfType<PowerPointCommentPart>().First();\r\n\r\n    if (ppcp.RootElement is null)\r\n    {\r\n        throw new InvalidDataException(\"no root element!\");\r\n    }\r\n\r\n    CommentPropertiesExtensionList cpel = ppcp.RootElement.Descendants<CommentPropertiesExtensionList>().First();\r\n\r\n    if (cpel is null)\r\n    {\r\n        throw new InvalidDataException(\"Presentation modern comment part is missing p188:extlst\");\r\n    }\r\n\r\n    CommentPropertiesExtension cpe = cpel.ChildElements.First<CommentPropertiesExtension>();\r\n    \r\n    if (cpe is null)\r\n    {\r\n// This line will throw because cpe is null due to the p:ext being wrapped by OpenXmlUnknownElement. \r\n// In our patched schemas we code this as p188:ext which is wrong. \r\n        throw new InvalidDataException(\"Presentation modern comment part is missing p188:ext\");\r\n    }\r\n```\r\n**Steps to reproduce the behavior:**\r\nUse the code above to access the ext child element the extLst in a p188:cm block.\r\n\r\n**Observed behavior**\r\n`cpe` is null.\r\n\r\n**Expected behavior**\r\nIn the code above, cpe should be a valid CommentPropertiesExtension object wrapping the p:ext.\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows\r\n - .NET Target: .Net 8.0\r\n - DocumentFormat.OpenXml Version: 3.0.2\r\n\r\n\r\n"},{"Id":"40439087954","Type":"PullRequestEvent","CreatedAt":"2024-07-24T20:45:32","Actor":"tomjebo","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1754","RelatedDescription":"Merged pull request \"Change commentextensionlist ext element to 2006/main namespace\" (#1754) at dotnet/Open-XML-SDK","RelatedBody":"- fixes #1751 \r\n"}],"ResultType":"GitHubEvent"}},"RunOn":"2024-07-29T03:30:21.9291763Z","RunDurationInMilliseconds":640}