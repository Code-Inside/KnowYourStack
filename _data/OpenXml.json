{"Data":{"Sdk":{"Events":[{"Id":"30381203200","Type":"PullRequestEvent","CreatedAt":"2023-07-12T19:33:23","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1491","RelatedDescription":"Opened pull request \"Add feature to track calculation chain changes\" (#1491) at dotnet/Open-XML-SDK","RelatedBody":"This is an example of how we may be able to support calculation chain tracking. It does not handle all cases, nor set all values necessary for the calculation chain. It does, however, show how we can track additions or removals of formulas and react accordingly.\r\n"},{"Id":"30355482986","Type":"IssuesEvent","CreatedAt":"2023-07-11T23:05:09","Actor":"AlfredHellstern","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1490","RelatedDescription":"Opened issue \"CancellationToken in DocumentFormat.OpemXml.Packaging.SpreadsheetDocument.Open function\" (#1490) at dotnet/Open-XML-SDK","RelatedBody":"### Discussed in https://github.com/dotnet/Open-XML-SDK/discussions/1489\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **ahsanaman92** July  7, 2023</sup>\r\nVersion: DocumentFormat.OpenXml v2.20.0\r\n\r\nI am working on an issue where the customer has reported that it takes a while for the _DocumentFormat.OpemXml.Packaging.SpreadsheetDocument.Open_ function to determine a large Excel document (329 MB) is invalid over the network. Is there a plan to be able to pass a CancellationToken to the open function? \r\n\r\nThe function is passed a _System.IO.Stream input_ like this: using (SpreadsheetDocument Doc = SpreadsheetDocument.Open(input, false))</div>"},{"Id":"30355114772","Type":"IssuesEvent","CreatedAt":"2023-07-11T22:37:32","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1305","RelatedDescription":"Closed issue \"New ImagePart is created as .bin instead of real extension\" (#1305) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nI have asked the question on Stackoverflow:\r\nhttps://stackoverflow.com/questions/75100804/embedding-image-as-new-imagepart-creates-a-bin-file-using-open-xml-sdk\r\n\r\nI don't expect to get any answer there, and I am also increasingly curious whether, this is an implementation error but an issue in the SDK.\r\n\r\nIssue is, I create new embedded image in Excel and it is saved to ```/xl/media/image.[WhatEverExtensionItIs]```\r\nIf I create a new ImagePart with the SDK and feed it data like this:\r\n\r\n```\r\nImagePart new_ImagePart = worksheetPart.AddImagePart(ImagePartType.Tiff);\r\nstream.Position = 0;\r\nnew_ImagePart.FeedData(stream);\r\n```\r\n\r\nThen the file will be saved as ```/xl/media/image.bin```.\r\n\r\nThis behaviour it should not do. It should write the extension as .tiff, since this is the ```ImagePartType```, that I specify. Or secondly it should read the stream and identify it as .tiff through i.e. a magic number.\r\n\r\nIf you unzip the package and change the image extension to real extension, then the image will open perfectly and I have used a TIFF validator to confirm the image is well-formed. \r\n\r\nWhat do you think of this? Am I doing anything wrong in my implementation, or can we change the SDK to write real extension like Excel does?\r\n\r\n**Screenshots**\r\nIf applicable, add screenshots to help explain your problem.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Use the supplied code to stream any TIFF image (or change ImagePartType to any other image type) to a new ImagePart\r\n2. Unzip the spreadsheet and go to /xl/media/ to find the file as a .bin\r\n3. Change extension to .tiff and the image will open perfectly\r\n\r\n**Observed behavior**\r\nImagePart creates a new image with .bin extension\r\n\r\n**Expected behavior**\r\nImagePart should create a new image with extension based on ImagePartType.\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows 11\r\n - Office version: 2212\r\n - .NET Target: .Net latest version\r\n - DocumentFormat.OpenXml Version: 2.19"},{"Id":"30355084421","Type":"IssuesEvent","CreatedAt":"2023-07-11T22:35:22","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1305","RelatedDescription":"Reopened issue \"New ImagePart is created as .bin instead of real extension\" (#1305) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nI have asked the question on Stackoverflow:\r\nhttps://stackoverflow.com/questions/75100804/embedding-image-as-new-imagepart-creates-a-bin-file-using-open-xml-sdk\r\n\r\nI don't expect to get any answer there, and I am also increasingly curious whether, this is an implementation error but an issue in the SDK.\r\n\r\nIssue is, I create new embedded image in Excel and it is saved to ```/xl/media/image.[WhatEverExtensionItIs]```\r\nIf I create a new ImagePart with the SDK and feed it data like this:\r\n\r\n```\r\nImagePart new_ImagePart = worksheetPart.AddImagePart(ImagePartType.Tiff);\r\nstream.Position = 0;\r\nnew_ImagePart.FeedData(stream);\r\n```\r\n\r\nThen the file will be saved as ```/xl/media/image.bin```.\r\n\r\nThis behaviour it should not do. It should write the extension as .tiff, since this is the ```ImagePartType```, that I specify. Or secondly it should read the stream and identify it as .tiff through i.e. a magic number.\r\n\r\nIf you unzip the package and change the image extension to real extension, then the image will open perfectly and I have used a TIFF validator to confirm the image is well-formed. \r\n\r\nWhat do you think of this? Am I doing anything wrong in my implementation, or can we change the SDK to write real extension like Excel does?\r\n\r\n**Screenshots**\r\nIf applicable, add screenshots to help explain your problem.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Use the supplied code to stream any TIFF image (or change ImagePartType to any other image type) to a new ImagePart\r\n2. Unzip the spreadsheet and go to /xl/media/ to find the file as a .bin\r\n3. Change extension to .tiff and the image will open perfectly\r\n\r\n**Observed behavior**\r\nImagePart creates a new image with .bin extension\r\n\r\n**Expected behavior**\r\nImagePart should create a new image with extension based on ImagePartType.\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows 11\r\n - Office version: 2212\r\n - .NET Target: .Net latest version\r\n - DocumentFormat.OpenXml Version: 2.19"},{"Id":"30355009766","Type":"IssuesEvent","CreatedAt":"2023-07-11T22:30:03","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1147","RelatedDescription":"Reopened issue \"`PresentationDocument.Save()` doesn't apply changes\" (#1147) at dotnet/Open-XML-SDK","RelatedBody":"**Description**\r\n\r\n`PresentationDocument.Save()` doesn't apply changes that are deleting presentation sections. It works if I call `doc.Close()` _(check Repro)_, but I don't wanna close presentation before `mStream.ToArray()`.\r\n\r\nLooks like `PresentationDocument.Save()` doesn't flush changes to `mStream` stream.\r\n\r\n**Information**\r\n\r\n- .NET Target: .NET 6\r\n- DocumentFormat.OpenXml Version: 2.16.0\r\n\r\n**Repro**\r\n\r\n[base.pptx](https://github.com/OfficeDev/Open-XML-SDK/files/8662785/base.pptx)\r\n\r\n```csharp\r\nusing DocumentFormat.OpenXml.Office2010.PowerPoint;\r\nusing DocumentFormat.OpenXml.Packaging;\r\n\r\nusing var fStream = File.OpenRead(@\"c:\\temp\\base.pptx\");\r\nvar mStream = new MemoryStream();\r\nfStream.CopyTo(mStream);\r\nfStream.Close();\r\n\r\nusing var doc = PresentationDocument.Open(mStream, true);\r\nvar sectionList = doc.PresentationPart!.Presentation.PresentationExtensionList?.Descendants<SectionList>().First();\r\n\r\nsectionList.Remove();\r\ndoc.Save();\r\n// doc.Close() // it works\r\n\r\nFile.WriteAllBytes(@\"c:\\temp\\edited.pptx\", mStream.ToArray());\r\n\r\n// ...\r\n``` \r\n\r\n**Observed**\r\n\r\nedited.pptx still has section.\r\n\r\n**Expected**\r\n\r\nedited.pptx doesn't have sections.\r\n\r\n"}],"ResultType":"GitHubEvent"}},"RunOn":"2023-07-13T03:30:25.2018326Z","RunDurationInMilliseconds":744}