{"Data":{"Sdk":{"Events":[{"Id":"51138970132","Type":"IssuesEvent","CreatedAt":"2025-06-20T09:34:15","Actor":"lindexi","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1940","RelatedDescription":"Opened issue \"The `DocumentFormat.OpenXml.Office2010.Drawing.TextMath` should not inherit OpenXmlLeafElement\" (#1940) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\n\nThe  `DocumentFormat.OpenXml.Office2010.Drawing.TextMath` (`a14:m`) is inherit OpenXmlLeafElement now. But as the document says, the  `DocumentFormat.OpenXml.Office2010.Drawing.TextMath` (`a14:m`)  will contain the OfficeMath element.\n\nThe sample OpenXML document:\n\n```xml\n              <a:p>\n                <a:r>\n                  <a:rPr lang=\"en-US\" altLang=\"zh-CN\" dirty=\"0\" />\n                  <a:t>123</a:t>\n                </a:r>\n                <a14:m>\n                  <m:oMath xmlns:m=\"http://schemas.openxmlformats.org/officeDocument/2006/math\">\n                    <m:r>\n                      <a:rPr lang=\"en-US\" altLang=\"zh-CN\" b=\"0\" i=\"1\" smtClean=\"0\">\n                        <a:latin typeface=\"Cambria Math\" panose=\"02040503050406030204\" pitchFamily=\"18\" charset=\"0\" />\n                      </a:rPr>\n                      <m:t>123</m:t>\n                    </m:r>\n                  </m:oMath>\n                </a14:m>\n                <a:endParaRPr lang=\"zh-CN\" altLang=\"en-US\" dirty=\"0\" />\n              </a:p>\n```\n\n**Screenshots**\nIf applicable, add screenshots to help explain your problem.\n\n**To Reproduce**\nNone.\n\n**Observed behavior**\n\nWe can not get the ChildElements from `DocumentFormat.OpenXml.Office2010.Drawing.TextMath`. And it will cause some unexpected behavior, such as https://github.com/dotnet/Open-XML-SDK/issues/1033\n\n**Expected behavior**\n\nThe `DocumentFormat.OpenXml.Office2010.Drawing.TextMath` should inherit OpenXmlCompositeElement type.\n\n**Desktop (please complete the following information):**\n - OS: [e.g. Windows]\n - Office version [e.g. 16.0.15427.20178]\n - .NET Target: (e.g. .NET Framework, .NET Core, UWP, Xamarin...)\n - DocumentFormat.OpenXml Version: (e.g. 2.11.0)\n\n**Additional context**\nAdd any other context about the problem here.\n"},{"Id":"51107002973","Type":"IssuesEvent","CreatedAt":"2025-06-19T13:34:13","Actor":"mkaszewiak","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1937","RelatedDescription":"Closed issue \"Bug with Open XML SDK\" (#1937) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\nImproper Handling of Indentation and Hierarchy in Word Document Extraction Using Open XML\n**Screenshots**\n\n<!-- Failed to upload \"SnipImage.JPG\" -->\n\n**To Reproduce**\nbelow is the code i am using \n ```csharp private static string ConvertParagraphToHtml(WordprocessingDocument doc, Paragraph paragraph)\n {\n     StringBuilder paraHtml = new StringBuilder();\n     bool inBold = false;\n     const float PointsPerInch = 72.0f;\n     const float TabWidthInInches = 0.5f;\n     const int TwipsPerPoint = 20; // 1 point = 20 twips\n     const string TabRepresentation = \"<t>\"; // Use <t> to represent a tab in HTML\n\n     string paragraphText = GetParagraphText(paragraph).TrimEnd('\\r', '\\n');\n     if (string.IsNullOrEmpty(paragraphText))\n     {\n         return \"\";\n     }\n\n     // Handle initial tabs before numbering\n     StringBuilder preNumberingTabs = new StringBuilder();\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         if (run.Elements<TabChar>().Any())\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n         else\n         {\n             // Stop collecting tabs once we hit non-tab content\n             if (!string.IsNullOrEmpty(run.InnerText))\n                 break;\n         }\n     }\n\n     // Handle indentation\n     ParagraphProperties paraProps = paragraph.GetFirstChild<ParagraphProperties>();\n     Indentation indentation = paraProps?.GetFirstChild<Indentation>();\n\n     float leftIndentPoints = indentation?.Left != null && int.TryParse(indentation.Left, out int leftTwips)\n         ? leftTwips / (float)TwipsPerPoint : 0f;\n     float firstLineIndentPoints = indentation?.FirstLine != null && int.TryParse(indentation.FirstLine, out int firstLineTwips)\n         ? firstLineTwips / (float)TwipsPerPoint : 0f;\n     float rightIndentPoints = indentation?.Right != null && int.TryParse(indentation.Right, out int rightTwips)\n         ? rightTwips / (float)TwipsPerPoint : 0f;\n\n     float leftIndentInches = leftIndentPoints / PointsPerInch;\n     if (leftIndentInches > 0)\n     {\n         var loopTimes = (int)(leftIndentInches / TabWidthInInches);\n         for (int i = 0; i < loopTimes; i++)\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n     }\n\n     // Append pre-numbering tabs and indentation\n     paraHtml.Append(preNumberingTabs.ToString());\n\n     // Handle list numbering\n     string listPrefix = \"\";\n     var numberingProperties = paragraph.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n     var numberingId = numberingProperties?.NumberingId?.Val?.Value;\n     var numberingLevel = numberingProperties?.NumberingLevelReference?.Val?.Value ?? 0;\n\n     if (numberingProperties != null && numberingId.HasValue)\n     {\n         try\n         {\n             var numberingPart = doc.MainDocumentPart?.NumberingDefinitionsPart;\n             var numbering = numberingPart?.Numbering;\n             var abstractNumId = numbering?.Elements<NumberingInstance>()\n                 .FirstOrDefault(n => n.NumberID?.Value == numberingId)?.AbstractNumId?.Val?.Value;\n             var abstractNum = numbering?.Elements<AbstractNum>()\n                 .FirstOrDefault(n => n.AbstractNumberId?.Value == abstractNumId);\n             var level = abstractNum?.Elements<Level>().FirstOrDefault(l => l.LevelIndex?.Value == numberingLevel);\n             if (level != null)\n             {\n                 int listItemCount = 0;\n                 var paragraphs = doc.MainDocumentPart?.Document.Body.Elements<Paragraph>();\n                 if (paragraphs != null)\n                 {\n                     foreach (var p in paragraphs)\n                     {\n                         var np = p.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n                         var pNumId = np?.NumberingId?.Val?.Value;\n                         var pLevel = np?.NumberingLevelReference?.Val?.Value ?? 0;\n                         if (pNumId == numberingId && pLevel == numberingLevel)\n                         {\n                             listItemCount++;\n                             if (p == paragraph)\n                                 break;\n                         }\n                     }\n                 }\n\n                 string listNumber = listItemCount.ToString();\n                 var numberFormatMap = new Dictionary<NumberFormatValues, string>\n         {\n             { NumberFormatValues.Decimal, \"decimal\" },\n             { NumberFormatValues.LowerLetter, \"lowerletter\" },\n             { NumberFormatValues.UpperLetter, \"upperletter\" },\n             { NumberFormatValues.LowerRoman, \"lowerroman\" },\n             { NumberFormatValues.UpperRoman, \"upperroman\" },\n             { NumberFormatValues.Bullet, \"bullet\" }\n         };\n                 var numberStyle = numberFormatMap.TryGetValue(level.NumberingFormat?.Val?.Value ?? NumberFormatValues.Decimal, out var style)\n                     ? style\n                     : \"decimal\";\n                 switch (numberStyle.ToLower())\n                 {\n                     case \"lowerletter\":\n                         listNumber = ((char)('a' + listItemCount - 1)).ToString();\n                         break;\n                     case \"upperletter\":\n                         listNumber = ((char)('A' + listItemCount - 1)).ToString();\n                         break;\n                     case \"lowerroman\":\n                         listNumber = ToRoman(listItemCount).ToLower();\n                         break;\n                     case \"upperroman\":\n                         listNumber = ToRoman(listItemCount).ToUpper();\n                         break;\n                     case \"bullet\":\n                         listNumber = level.LevelText?.Val?.Value ?? \"•\";\n                         break;\n                     default:\n                         listNumber = listItemCount.ToString(); // Decimal\n                         break;\n                 }\n\n                 string numberFormat = level.LevelText?.Val?.Value ?? \"%1.\";\n                 listPrefix = numberFormat.Replace(\"%1\", listNumber);\n                 // Add tab after number if not a bullet\n                 if (numberStyle.ToLower() != \"bullet\")\n                 {\n                     listPrefix += TabRepresentation;\n                 }\n             }\n         }\n         catch (Exception ex)\n         {\n             Console.WriteLine($\"Error processing list numbering: {ex.Message}\");\n             listPrefix = \"\"; // Fallback to empty prefix\n         }\n     }\n\n     // Append list prefix after tabs and indentation\n     paraHtml.Append(listPrefix);\n\n     // Process runs for bold formatting, text, and tabs\n     bool numberProcessed = string.IsNullOrEmpty(listPrefix); // Skip runs until numbering is processed\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         // Skip runs that are part of numbering if listPrefix was generated\n         if (!numberProcessed && run.InnerText == listPrefix.TrimEnd(TabRepresentation.ToCharArray()))\n         {\n             numberProcessed = true;\n             continue;\n         }\n\n         // Handle tab elements\n         if (run.Elements<TabChar>().Any())\n         {\n             paraHtml.Append(TabRepresentation);\n             continue;\n         }\n\n         string runText = run.InnerText ?? \"\";\n         bool isRunBold = run.RunProperties?.Bold != null;\n\n         if (string.IsNullOrEmpty(runText))\n             continue;\n\n         if (runText == \"\\n\")\n         {\n             paraHtml.Append(\"\\n\");\n         }\n         else if (runText == \"\\t\")\n         {\n             paraHtml.Append(TabRepresentation);\n         }\n         else\n         {\n             if (isRunBold && !inBold)\n             {\n                 paraHtml.Append(\"<b>\");\n                 inBold = true;\n             }\n             else if (!isRunBold && inBold)\n             {\n                 paraHtml.Append(\"</b>\");\n                 inBold = false;\n             }\n             paraHtml.Append(runText);\n         }\n     }\n\n     if (inBold)\n     {\n         paraHtml.Append(\"</b>\");\n     }\n\n     // Clean up HTML\n     paraHtml.Replace(\"{\", \"[\");\n     paraHtml.Replace(\"}\", \"]\");\n     paraHtml.Replace(\"<b>\\r</b>\", \"\");\n     paraHtml.Replace(\"\\r</b>\", \"</b>\");\n     paraHtml.Replace(\"\\r\", \"\");\n     paraHtml.Replace(\"<b></b>\", \"\");\n     paraHtml.Replace(\"<t>. <t>\", \".<t>\");\n     paraHtml.Replace(\"<t>.<t>\", \".<t>\");\n     paraHtml.Replace(\"(<t>\", \"(\");\n     paraHtml.Replace(\" <t>\", TabRepresentation); // Preserve tabs\n\n     Console.WriteLine($\"Converted HTML: {paraHtml.ToString()}\");\n     return paraHtml.ToString();\n }\n ```\n\n\n**Observed behavior**\nindentation mismatched\n\n**Expected behavior**\nI want indentation to display as per the source document \n\n**Desktop (please complete the following information):**\n - OS: [e.g. Windows]\n - Office version [e.g. 16.0.15427.20178]\n - .NET Target: 4.6.3\n - DocumentFormat.OpenXml Version: (e.g. 3.3..00)\n\n**Additional context**\nAdd any other context about the problem here.\n i dont have permisison to add files here"},{"Id":"51094897971","Type":"IssuesEvent","CreatedAt":"2025-06-19T08:43:03","Actor":"mkaszewiak","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1937","RelatedDescription":"Reopened issue \"Bug with Open XML SDK\" (#1937) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\nImproper Handling of Indentation and Hierarchy in Word Document Extraction Using Open XML\n**Screenshots**\n\n<!-- Failed to upload \"SnipImage.JPG\" -->\n\n**To Reproduce**\nbelow is the code i am using \n ```csharp private static string ConvertParagraphToHtml(WordprocessingDocument doc, Paragraph paragraph)\n {\n     StringBuilder paraHtml = new StringBuilder();\n     bool inBold = false;\n     const float PointsPerInch = 72.0f;\n     const float TabWidthInInches = 0.5f;\n     const int TwipsPerPoint = 20; // 1 point = 20 twips\n     const string TabRepresentation = \"<t>\"; // Use <t> to represent a tab in HTML\n\n     string paragraphText = GetParagraphText(paragraph).TrimEnd('\\r', '\\n');\n     if (string.IsNullOrEmpty(paragraphText))\n     {\n         return \"\";\n     }\n\n     // Handle initial tabs before numbering\n     StringBuilder preNumberingTabs = new StringBuilder();\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         if (run.Elements<TabChar>().Any())\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n         else\n         {\n             // Stop collecting tabs once we hit non-tab content\n             if (!string.IsNullOrEmpty(run.InnerText))\n                 break;\n         }\n     }\n\n     // Handle indentation\n     ParagraphProperties paraProps = paragraph.GetFirstChild<ParagraphProperties>();\n     Indentation indentation = paraProps?.GetFirstChild<Indentation>();\n\n     float leftIndentPoints = indentation?.Left != null && int.TryParse(indentation.Left, out int leftTwips)\n         ? leftTwips / (float)TwipsPerPoint : 0f;\n     float firstLineIndentPoints = indentation?.FirstLine != null && int.TryParse(indentation.FirstLine, out int firstLineTwips)\n         ? firstLineTwips / (float)TwipsPerPoint : 0f;\n     float rightIndentPoints = indentation?.Right != null && int.TryParse(indentation.Right, out int rightTwips)\n         ? rightTwips / (float)TwipsPerPoint : 0f;\n\n     float leftIndentInches = leftIndentPoints / PointsPerInch;\n     if (leftIndentInches > 0)\n     {\n         var loopTimes = (int)(leftIndentInches / TabWidthInInches);\n         for (int i = 0; i < loopTimes; i++)\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n     }\n\n     // Append pre-numbering tabs and indentation\n     paraHtml.Append(preNumberingTabs.ToString());\n\n     // Handle list numbering\n     string listPrefix = \"\";\n     var numberingProperties = paragraph.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n     var numberingId = numberingProperties?.NumberingId?.Val?.Value;\n     var numberingLevel = numberingProperties?.NumberingLevelReference?.Val?.Value ?? 0;\n\n     if (numberingProperties != null && numberingId.HasValue)\n     {\n         try\n         {\n             var numberingPart = doc.MainDocumentPart?.NumberingDefinitionsPart;\n             var numbering = numberingPart?.Numbering;\n             var abstractNumId = numbering?.Elements<NumberingInstance>()\n                 .FirstOrDefault(n => n.NumberID?.Value == numberingId)?.AbstractNumId?.Val?.Value;\n             var abstractNum = numbering?.Elements<AbstractNum>()\n                 .FirstOrDefault(n => n.AbstractNumberId?.Value == abstractNumId);\n             var level = abstractNum?.Elements<Level>().FirstOrDefault(l => l.LevelIndex?.Value == numberingLevel);\n             if (level != null)\n             {\n                 int listItemCount = 0;\n                 var paragraphs = doc.MainDocumentPart?.Document.Body.Elements<Paragraph>();\n                 if (paragraphs != null)\n                 {\n                     foreach (var p in paragraphs)\n                     {\n                         var np = p.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n                         var pNumId = np?.NumberingId?.Val?.Value;\n                         var pLevel = np?.NumberingLevelReference?.Val?.Value ?? 0;\n                         if (pNumId == numberingId && pLevel == numberingLevel)\n                         {\n                             listItemCount++;\n                             if (p == paragraph)\n                                 break;\n                         }\n                     }\n                 }\n\n                 string listNumber = listItemCount.ToString();\n                 var numberFormatMap = new Dictionary<NumberFormatValues, string>\n         {\n             { NumberFormatValues.Decimal, \"decimal\" },\n             { NumberFormatValues.LowerLetter, \"lowerletter\" },\n             { NumberFormatValues.UpperLetter, \"upperletter\" },\n             { NumberFormatValues.LowerRoman, \"lowerroman\" },\n             { NumberFormatValues.UpperRoman, \"upperroman\" },\n             { NumberFormatValues.Bullet, \"bullet\" }\n         };\n                 var numberStyle = numberFormatMap.TryGetValue(level.NumberingFormat?.Val?.Value ?? NumberFormatValues.Decimal, out var style)\n                     ? style\n                     : \"decimal\";\n                 switch (numberStyle.ToLower())\n                 {\n                     case \"lowerletter\":\n                         listNumber = ((char)('a' + listItemCount - 1)).ToString();\n                         break;\n                     case \"upperletter\":\n                         listNumber = ((char)('A' + listItemCount - 1)).ToString();\n                         break;\n                     case \"lowerroman\":\n                         listNumber = ToRoman(listItemCount).ToLower();\n                         break;\n                     case \"upperroman\":\n                         listNumber = ToRoman(listItemCount).ToUpper();\n                         break;\n                     case \"bullet\":\n                         listNumber = level.LevelText?.Val?.Value ?? \"•\";\n                         break;\n                     default:\n                         listNumber = listItemCount.ToString(); // Decimal\n                         break;\n                 }\n\n                 string numberFormat = level.LevelText?.Val?.Value ?? \"%1.\";\n                 listPrefix = numberFormat.Replace(\"%1\", listNumber);\n                 // Add tab after number if not a bullet\n                 if (numberStyle.ToLower() != \"bullet\")\n                 {\n                     listPrefix += TabRepresentation;\n                 }\n             }\n         }\n         catch (Exception ex)\n         {\n             Console.WriteLine($\"Error processing list numbering: {ex.Message}\");\n             listPrefix = \"\"; // Fallback to empty prefix\n         }\n     }\n\n     // Append list prefix after tabs and indentation\n     paraHtml.Append(listPrefix);\n\n     // Process runs for bold formatting, text, and tabs\n     bool numberProcessed = string.IsNullOrEmpty(listPrefix); // Skip runs until numbering is processed\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         // Skip runs that are part of numbering if listPrefix was generated\n         if (!numberProcessed && run.InnerText == listPrefix.TrimEnd(TabRepresentation.ToCharArray()))\n         {\n             numberProcessed = true;\n             continue;\n         }\n\n         // Handle tab elements\n         if (run.Elements<TabChar>().Any())\n         {\n             paraHtml.Append(TabRepresentation);\n             continue;\n         }\n\n         string runText = run.InnerText ?? \"\";\n         bool isRunBold = run.RunProperties?.Bold != null;\n\n         if (string.IsNullOrEmpty(runText))\n             continue;\n\n         if (runText == \"\\n\")\n         {\n             paraHtml.Append(\"\\n\");\n         }\n         else if (runText == \"\\t\")\n         {\n             paraHtml.Append(TabRepresentation);\n         }\n         else\n         {\n             if (isRunBold && !inBold)\n             {\n                 paraHtml.Append(\"<b>\");\n                 inBold = true;\n             }\n             else if (!isRunBold && inBold)\n             {\n                 paraHtml.Append(\"</b>\");\n                 inBold = false;\n             }\n             paraHtml.Append(runText);\n         }\n     }\n\n     if (inBold)\n     {\n         paraHtml.Append(\"</b>\");\n     }\n\n     // Clean up HTML\n     paraHtml.Replace(\"{\", \"[\");\n     paraHtml.Replace(\"}\", \"]\");\n     paraHtml.Replace(\"<b>\\r</b>\", \"\");\n     paraHtml.Replace(\"\\r</b>\", \"</b>\");\n     paraHtml.Replace(\"\\r\", \"\");\n     paraHtml.Replace(\"<b></b>\", \"\");\n     paraHtml.Replace(\"<t>. <t>\", \".<t>\");\n     paraHtml.Replace(\"<t>.<t>\", \".<t>\");\n     paraHtml.Replace(\"(<t>\", \"(\");\n     paraHtml.Replace(\" <t>\", TabRepresentation); // Preserve tabs\n\n     Console.WriteLine($\"Converted HTML: {paraHtml.ToString()}\");\n     return paraHtml.ToString();\n }\n ```\n\n\n**Observed behavior**\nindentation mismatched\n\n**Expected behavior**\nI want indentation to display as per the source document \n\n**Desktop (please complete the following information):**\n - OS: [e.g. Windows]\n - Office version [e.g. 16.0.15427.20178]\n - .NET Target: 4.6.3\n - DocumentFormat.OpenXml Version: (e.g. 3.3..00)\n\n**Additional context**\nAdd any other context about the problem here.\n i dont have permisison to add files here"},{"Id":"51063125910","Type":"IssuesEvent","CreatedAt":"2025-06-18T15:14:36","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1939","RelatedDescription":"Opened issue \"Remove DocumentFormat.OpenXml.Office.SpreadSheetML.Y2024.PivotDynamicArrays namespace\" (#1939) at dotnet/Open-XML-SDK","RelatedBody":"Remove DocumentFormat.OpenXml.Office.SpreadSheetML.Y2024.PivotDynamicArrays namespace and all related classes. They were added in error."},{"Id":"51027430874","Type":"IssuesEvent","CreatedAt":"2025-06-17T22:12:31","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/812","RelatedDescription":"Closed issue \"Memory problems when modifying slide containing lots of elements\" (#812) at dotnet/Open-XML-SDK","RelatedBody":"**Description**\r\n\r\nI have a presentation with a lot of vector graphics on the slides. I want to inspect the SlidePart of each Slide using the Descendants method and modify some elements. This loads the entire DOM of the slide in memory, which ends spending gigabytes of memory. Memory profiling shows that each slide allocates something along the lines of 200000 objects in memory.\r\n\r\nIt seems that there is no way to avoid loading the entire DOM to memory? I have experimented with using the OpenXmlReader to read the desired elements from the SlidePart, modify them accordingly, and then write them back using the OpenXmlWriter. \r\nThis avoid loading the DOM of all elements, but it is hard to get it right because the elements returned by the OpenXmlReader are different instances and are therefore detached from the SlidePart and Slide.\r\nThis makes subsequent modifications of elements of the SlidePart difficult.\r\n\r\nI think it is needed to have a way to easily modify elements without exhausting a lot of memory.\r\n\r\n**Information**\r\n\r\n- .NET Target: .NET Core 3.1\r\n- DocumentFormat.OpenXml Version: 2.11.3\r\n\r\n**Repro**\r\n\r\nCreate a presentation containing a slide with a lot of shapes with vector graphics and access the Slide property of the SlidePart. \r\n\r\n`     <p:sp>\r\n          <p:nvSpPr>\r\n            <p:cNvPr id=\"206\" name=\"Freeform 11\" />\r\n            <p:cNvSpPr>\r\n              <a:spLocks />\r\n            </p:cNvSpPr>\r\n            <p:nvPr />\r\n          </p:nvSpPr>\r\n          <p:spPr bwMode=\"auto\">\r\n            <a:xfrm>\r\n              <a:off x=\"7046\" y=\"2799\" />\r\n              <a:ext cx=\"6\" cy=\"21\" />\r\n            </a:xfrm>\r\n            <a:custGeom>\r\n              <a:avLst />\r\n              <a:gdLst>\r\n                <a:gd name=\"T0\" fmla=\"*/ 3 w 3\" />\r\n                <a:gd name=\"T1\" fmla=\"*/ 5 h 12\" />\r\n                <a:gd name=\"T2\" fmla=\"*/ 1 w 3\" />\r\n                <a:gd name=\"T3\" fmla=\"*/ 11 h 12\" />\r\n                <a:gd name=\"T4\" fmla=\"*/ 1 w 3\" />\r\n                <a:gd name=\"T5\" fmla=\"*/ 7 h 12\" />\r\n                <a:gd name=\"T6\" fmla=\"*/ 3 w 3\" />\r\n                <a:gd name=\"T7\" fmla=\"*/ 1 h 12\" />\r\n                <a:gd name=\"T8\" fmla=\"*/ 3 w 3\" />\r\n                <a:gd name=\"T9\" fmla=\"*/ 5 h 12\" />\r\n              </a:gdLst>\r\n              <a:ahLst />\r\n              <a:cxnLst>\r\n                <a:cxn ang=\"0\">\r\n                  <a:pos x=\"T0\" y=\"T1\" />\r\n                </a:cxn>\r\n                <a:cxn ang=\"0\">\r\n                  <a:pos x=\"T2\" y=\"T3\" />\r\n                </a:cxn>\r\n                <a:cxn ang=\"0\">\r\n                  <a:pos x=\"T4\" y=\"T5\" />\r\n                </a:cxn>\r\n                <a:cxn ang=\"0\">\r\n                  <a:pos x=\"T6\" y=\"T7\" />\r\n                </a:cxn>\r\n                <a:cxn ang=\"0\">\r\n                  <a:pos x=\"T8\" y=\"T9\" />\r\n                </a:cxn>\r\n              </a:cxnLst>\r\n              <a:rect l=\"0\" t=\"0\" r=\"r\" b=\"b\" />\r\n              <a:pathLst>\r\n                <a:path w=\"3\" h=\"12\">\r\n                  <a:moveTo>\r\n                    <a:pt x=\"3\" y=\"5\" />\r\n                  </a:moveTo>\r\n                  <a:cubicBezTo>\r\n                    <a:pt x=\"2\" y=\"8\" />\r\n                    <a:pt x=\"2\" y=\"11\" />\r\n                    <a:pt x=\"1\" y=\"11\" />\r\n                  </a:cubicBezTo>\r\n                  <a:cubicBezTo>\r\n                    <a:pt x=\"0\" y=\"12\" />\r\n                    <a:pt x=\"0\" y=\"10\" />\r\n                    <a:pt x=\"1\" y=\"7\" />\r\n                  </a:cubicBezTo>\r\n                  <a:cubicBezTo>\r\n                    <a:pt x=\"1\" y=\"4\" />\r\n                    <a:pt x=\"2\" y=\"1\" />\r\n                    <a:pt x=\"3\" y=\"1\" />\r\n                  </a:cubicBezTo>\r\n                  <a:cubicBezTo>\r\n                    <a:pt x=\"3\" y=\"0\" />\r\n                    <a:pt x=\"3\" y=\"2\" />\r\n                    <a:pt x=\"3\" y=\"5\" />\r\n                  </a:cubicBezTo>\r\n                  <a:close />\r\n                </a:path>\r\n              </a:pathLst>\r\n            </a:custGeom>\r\n            <a:grpFill />\r\n            <a:ln>\r\n              <a:noFill />\r\n            </a:ln>\r\n            <a:extLst>\r\n              <a:ext uri=\"{91240B29-F687-4F45-9708-019B960494DF}\">\r\n                <a14:hiddenLine xmlns:a14=\"http://schemas.microsoft.com/office/drawing/2010/main\" w=\"9525\">\r\n                  <a:solidFill>\r\n                    <a:srgbClr val=\"000000\" />\r\n                  </a:solidFill>\r\n                  <a:round />\r\n                  <a:headEnd />\r\n                  <a:tailEnd />\r\n                </a14:hiddenLine>\r\n              </a:ext>\r\n            </a:extLst>\r\n          </p:spPr>\r\n          <p:txBody>\r\n            <a:bodyPr vert=\"horz\" wrap=\"square\" lIns=\"91440\" tIns=\"0\" rIns=\"72000\" bIns=\"0\" numCol=\"1\" anchor=\"t\" anchorCtr=\"0\" compatLnSpc=\"1\">\r\n              <a:prstTxWarp prst=\"textNoShape\">\r\n                <a:avLst />\r\n              </a:prstTxWarp>\r\n            </a:bodyPr>\r\n            <a:lstStyle />\r\n            <a:p>\r\n              <a:endParaRPr lang=\"en-GB\">\r\n                <a:solidFill>\r\n                  <a:schemeClr val=\"tx2\" />\r\n                </a:solidFill>\r\n              </a:endParaRPr>\r\n            </a:p>\r\n          </p:txBody>\r\n        </p:sp>`\r\n\r\n**Observed**\r\n\r\nMemory exhaustion occours.\r\n\r\n**Expected**\r\n\r\nSome way to modify big presentations without loading everything to memory.\r\n"},{"Id":"51008319722","Type":"IssuesEvent","CreatedAt":"2025-06-17T14:03:16","Actor":"mkaszewiak","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1937","RelatedDescription":"Closed issue \"Bug with Open XML SDK\" (#1937) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\nImproper Handling of Indentation and Hierarchy in Word Document Extraction Using Open XML\n**Screenshots**\n\n<!-- Failed to upload \"SnipImage.JPG\" -->\n\n**To Reproduce**\nbelow is the code i am using \n ```csharp private static string ConvertParagraphToHtml(WordprocessingDocument doc, Paragraph paragraph)\n {\n     StringBuilder paraHtml = new StringBuilder();\n     bool inBold = false;\n     const float PointsPerInch = 72.0f;\n     const float TabWidthInInches = 0.5f;\n     const int TwipsPerPoint = 20; // 1 point = 20 twips\n     const string TabRepresentation = \"<t>\"; // Use <t> to represent a tab in HTML\n\n     string paragraphText = GetParagraphText(paragraph).TrimEnd('\\r', '\\n');\n     if (string.IsNullOrEmpty(paragraphText))\n     {\n         return \"\";\n     }\n\n     // Handle initial tabs before numbering\n     StringBuilder preNumberingTabs = new StringBuilder();\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         if (run.Elements<TabChar>().Any())\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n         else\n         {\n             // Stop collecting tabs once we hit non-tab content\n             if (!string.IsNullOrEmpty(run.InnerText))\n                 break;\n         }\n     }\n\n     // Handle indentation\n     ParagraphProperties paraProps = paragraph.GetFirstChild<ParagraphProperties>();\n     Indentation indentation = paraProps?.GetFirstChild<Indentation>();\n\n     float leftIndentPoints = indentation?.Left != null && int.TryParse(indentation.Left, out int leftTwips)\n         ? leftTwips / (float)TwipsPerPoint : 0f;\n     float firstLineIndentPoints = indentation?.FirstLine != null && int.TryParse(indentation.FirstLine, out int firstLineTwips)\n         ? firstLineTwips / (float)TwipsPerPoint : 0f;\n     float rightIndentPoints = indentation?.Right != null && int.TryParse(indentation.Right, out int rightTwips)\n         ? rightTwips / (float)TwipsPerPoint : 0f;\n\n     float leftIndentInches = leftIndentPoints / PointsPerInch;\n     if (leftIndentInches > 0)\n     {\n         var loopTimes = (int)(leftIndentInches / TabWidthInInches);\n         for (int i = 0; i < loopTimes; i++)\n         {\n             preNumberingTabs.Append(TabRepresentation);\n         }\n     }\n\n     // Append pre-numbering tabs and indentation\n     paraHtml.Append(preNumberingTabs.ToString());\n\n     // Handle list numbering\n     string listPrefix = \"\";\n     var numberingProperties = paragraph.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n     var numberingId = numberingProperties?.NumberingId?.Val?.Value;\n     var numberingLevel = numberingProperties?.NumberingLevelReference?.Val?.Value ?? 0;\n\n     if (numberingProperties != null && numberingId.HasValue)\n     {\n         try\n         {\n             var numberingPart = doc.MainDocumentPart?.NumberingDefinitionsPart;\n             var numbering = numberingPart?.Numbering;\n             var abstractNumId = numbering?.Elements<NumberingInstance>()\n                 .FirstOrDefault(n => n.NumberID?.Value == numberingId)?.AbstractNumId?.Val?.Value;\n             var abstractNum = numbering?.Elements<AbstractNum>()\n                 .FirstOrDefault(n => n.AbstractNumberId?.Value == abstractNumId);\n             var level = abstractNum?.Elements<Level>().FirstOrDefault(l => l.LevelIndex?.Value == numberingLevel);\n             if (level != null)\n             {\n                 int listItemCount = 0;\n                 var paragraphs = doc.MainDocumentPart?.Document.Body.Elements<Paragraph>();\n                 if (paragraphs != null)\n                 {\n                     foreach (var p in paragraphs)\n                     {\n                         var np = p.Elements<ParagraphProperties>().FirstOrDefault()?.NumberingProperties;\n                         var pNumId = np?.NumberingId?.Val?.Value;\n                         var pLevel = np?.NumberingLevelReference?.Val?.Value ?? 0;\n                         if (pNumId == numberingId && pLevel == numberingLevel)\n                         {\n                             listItemCount++;\n                             if (p == paragraph)\n                                 break;\n                         }\n                     }\n                 }\n\n                 string listNumber = listItemCount.ToString();\n                 var numberFormatMap = new Dictionary<NumberFormatValues, string>\n         {\n             { NumberFormatValues.Decimal, \"decimal\" },\n             { NumberFormatValues.LowerLetter, \"lowerletter\" },\n             { NumberFormatValues.UpperLetter, \"upperletter\" },\n             { NumberFormatValues.LowerRoman, \"lowerroman\" },\n             { NumberFormatValues.UpperRoman, \"upperroman\" },\n             { NumberFormatValues.Bullet, \"bullet\" }\n         };\n                 var numberStyle = numberFormatMap.TryGetValue(level.NumberingFormat?.Val?.Value ?? NumberFormatValues.Decimal, out var style)\n                     ? style\n                     : \"decimal\";\n                 switch (numberStyle.ToLower())\n                 {\n                     case \"lowerletter\":\n                         listNumber = ((char)('a' + listItemCount - 1)).ToString();\n                         break;\n                     case \"upperletter\":\n                         listNumber = ((char)('A' + listItemCount - 1)).ToString();\n                         break;\n                     case \"lowerroman\":\n                         listNumber = ToRoman(listItemCount).ToLower();\n                         break;\n                     case \"upperroman\":\n                         listNumber = ToRoman(listItemCount).ToUpper();\n                         break;\n                     case \"bullet\":\n                         listNumber = level.LevelText?.Val?.Value ?? \"•\";\n                         break;\n                     default:\n                         listNumber = listItemCount.ToString(); // Decimal\n                         break;\n                 }\n\n                 string numberFormat = level.LevelText?.Val?.Value ?? \"%1.\";\n                 listPrefix = numberFormat.Replace(\"%1\", listNumber);\n                 // Add tab after number if not a bullet\n                 if (numberStyle.ToLower() != \"bullet\")\n                 {\n                     listPrefix += TabRepresentation;\n                 }\n             }\n         }\n         catch (Exception ex)\n         {\n             Console.WriteLine($\"Error processing list numbering: {ex.Message}\");\n             listPrefix = \"\"; // Fallback to empty prefix\n         }\n     }\n\n     // Append list prefix after tabs and indentation\n     paraHtml.Append(listPrefix);\n\n     // Process runs for bold formatting, text, and tabs\n     bool numberProcessed = string.IsNullOrEmpty(listPrefix); // Skip runs until numbering is processed\n     foreach (Run run in paragraph.Elements<Run>())\n     {\n         // Skip runs that are part of numbering if listPrefix was generated\n         if (!numberProcessed && run.InnerText == listPrefix.TrimEnd(TabRepresentation.ToCharArray()))\n         {\n             numberProcessed = true;\n             continue;\n         }\n\n         // Handle tab elements\n         if (run.Elements<TabChar>().Any())\n         {\n             paraHtml.Append(TabRepresentation);\n             continue;\n         }\n\n         string runText = run.InnerText ?? \"\";\n         bool isRunBold = run.RunProperties?.Bold != null;\n\n         if (string.IsNullOrEmpty(runText))\n             continue;\n\n         if (runText == \"\\n\")\n         {\n             paraHtml.Append(\"\\n\");\n         }\n         else if (runText == \"\\t\")\n         {\n             paraHtml.Append(TabRepresentation);\n         }\n         else\n         {\n             if (isRunBold && !inBold)\n             {\n                 paraHtml.Append(\"<b>\");\n                 inBold = true;\n             }\n             else if (!isRunBold && inBold)\n             {\n                 paraHtml.Append(\"</b>\");\n                 inBold = false;\n             }\n             paraHtml.Append(runText);\n         }\n     }\n\n     if (inBold)\n     {\n         paraHtml.Append(\"</b>\");\n     }\n\n     // Clean up HTML\n     paraHtml.Replace(\"{\", \"[\");\n     paraHtml.Replace(\"}\", \"]\");\n     paraHtml.Replace(\"<b>\\r</b>\", \"\");\n     paraHtml.Replace(\"\\r</b>\", \"</b>\");\n     paraHtml.Replace(\"\\r\", \"\");\n     paraHtml.Replace(\"<b></b>\", \"\");\n     paraHtml.Replace(\"<t>. <t>\", \".<t>\");\n     paraHtml.Replace(\"<t>.<t>\", \".<t>\");\n     paraHtml.Replace(\"(<t>\", \"(\");\n     paraHtml.Replace(\" <t>\", TabRepresentation); // Preserve tabs\n\n     Console.WriteLine($\"Converted HTML: {paraHtml.ToString()}\");\n     return paraHtml.ToString();\n }\n ```\n\n\n**Observed behavior**\nindentation mismatched\n\n**Expected behavior**\nI want indentation to display as per the source document \n\n**Desktop (please complete the following information):**\n - OS: [e.g. Windows]\n - Office version [e.g. 16.0.15427.20178]\n - .NET Target: 4.6.3\n - DocumentFormat.OpenXml Version: (e.g. 3.3..00)\n\n**Additional context**\nAdd any other context about the problem here.\n i dont have permisison to add files here"}],"ResultType":"GitHubEvent"}},"RunOn":"2025-06-21T03:30:19.3945506Z","RunDurationInMilliseconds":579}