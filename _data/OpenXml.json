{"Data":{"Sdk":{"Events":[{"Id":"49431548394","Type":"IssuesEvent","CreatedAt":"2025-05-06T22:52:05","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1741","RelatedDescription":"Closed issue \"Bug in class DocumentFormat.OpenXml.Office2019.Drawing.Chart.BooleanFalse\" (#1741) at dotnet/Open-XML-SDK","RelatedBody":"**The class `DocumentFormat.OpenXml.Office2019.Drawing.Chart.BooleanFalse` creates xml different from that created by PowerPoint**  \r\n\r\n**Observed behavior**  \r\nWhen using the SDK, it generates xml that include the namespace as a prefix of the attribute `val`:\r\n```xml\r\n<c16r3:dispNaAsBlank c16r3:val=\"1\" />\r\n```\r\nI'd assume this is the correct xml, but ...\r\n\r\n**Expected behavior**  \r\nHere is the xml the PowerPoint application creates:\r\n```xml\r\n<c16r3:dispNaAsBlank val=\"1\" />\r\n```\r\nIt may be a bug in PowerPoint.\r\n\r\n**Context**  \r\nHere is the context in which the class `BooleanFalse` is used to generate xml:\r\n```csharp\r\nusing C = DocumentFormat.OpenXml.Drawing.Charts;\r\nusing C16R3 = DocumentFormat.OpenXml.Office2019.Drawing.Chart;\r\n\r\n// c:chart - c:extLst\r\nvar extLst = new C.ExtensionList();\r\nchart.Append(extLst);\r\n\r\n// c:chart - c:extLst - c:ext\r\nvar ext = new C.Extension() { Uri = \"{56B9EC1D-385E-4148-901F-78D8002777C0}\" };\r\next.AddNamespaceDeclaration(\"c16r3\", \"http://schemas.microsoft.com/office/drawing/2017/03/chart\");\r\nextLst.Append(ext);\r\n\r\n// c:chart - c:extLst - c:ext - c16r3:dataDisplayOptions16\r\nvar dataDisplayOptions16 = new C16R3.DataDisplayOptions16();\r\next.Append(dataDisplayOptions16);\r\n\r\n// c:chart - c:extLst - c:ext - c16r3:dataDisplayOptions16 - c16r3:dispNaAsBlank\r\nvar dispNaAsBlank = new C16R3.BooleanFalse() { Val = true };\r\ndataDisplayOptions16.Append(dispNaAsBlank);\r\n```\r\n\r\n**Notes**  \r\nWhat is your opinion on this issue? Is it a bug in PowerPoint or the SDK? Or god forbid, did I make a mistake?\r\n\r\n**Desktop Information:**  \r\n - Windows 10\r\n - Microsoft® PowerPoint® for Microsoft 365 MSO (Version 2404 Build 16.0.17531.20190) 64-bit \r\n - .NET 8.0\r\n - DocumentFormat.OpenXml Version: 3.0.1\r\n\r\n"},{"Id":"49426406234","Type":"IssuesEvent","CreatedAt":"2025-05-06T19:43:43","Actor":"jack-edwards-fs","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1662","RelatedDescription":"Closed issue \"Supplying a value for EmbedRegularFont.FontKey corrupts DOCX output\" (#1662) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nI am attempting to embed TTF fonts in a DOCX file.  In order to be compatible with a third-party library that is able to update the Table of Contents page, it appears I must also provide a value for the `EmbedRegularFont.FontKey` property.  However, supplying a value for the `FontKey` elicits an error from Microsoft Word and the embedded fonts are no longer presented in the application.  The Open XML SDK Productivity tool also elicits an error.\r\n\r\nAm I supplying erroneous values for `FontKey`?  Where would I find the correct values?\r\n\r\n**Screenshots**\r\nWord error:\r\n> Word found unreadable content in \"report.docx\". Do you want to recover the contents of this document? If you trust the source of this document, click Yes.\r\n\r\nWord error, after clicking \"Yes\":\r\n> Word experienced an error trying to open the file. Try these suggestions. * Check the file permissions for the document or drive. * Make sure there is sufficient free memory and disk space. * Open the file with the Text Recovery Converter.\r\n\r\nOpen XML SDK 2.5 Productivity Tool for Microsoft Office error:\r\n> Cannot open the file: Specified part does not exist in the package.\r\n\r\n**To Reproduce**\r\n// Please add a self-contained, minimum viable repro of the issue.\r\n// If you require external resources, please provide a gist or GitHub repro\r\n// An Xunit style test is preferred, but a console application would work too.\r\n\r\nSteps to reproduce the behavior:\r\n\r\nUn-comment the line (below) to set the `FontKey`.\r\n\r\n```cs\r\nprivate static async Task GenerateFontPartContent(FontPart fontPart, string path)\r\n{\r\n    var fontPath = Path.Join(assemblyLocation, \"Assets\", \"Fonts\", path);\r\n    await using FileStream fontData = new FileStream(fontPath, FileMode.Open, FileAccess.Read);\r\n    fontPart.FeedData(fontData);\r\n}\r\n\r\nFontTablePart fontTablePart = document.AddNewPart<FontTablePart>(\"rId10\");\r\n\r\nFontPart fontPart9 = fontTablePart.AddNewPart<FontPart>(\"application/vnd.openxmlformats-officedocument.obfuscatedFont\", \"rId9\");\r\n\r\nawait GenerateFontPartContent(fontPart9, \"Manrope-Regular.ttf\");\r\n\r\nFont font7 = new Font(){ Name = \"Manrope\" };\r\nFontCharSet fontCharSet7 = new FontCharSet(){ Val = \"01\" };\r\nFontFamily fontFamily7 = new FontFamily(){ Val = FontFamilyValues.Auto };\r\nPitch pitch7 = new Pitch(){ Val = FontPitchValues.Variable };\r\nEmbedRegularFont embedRegularFont = new EmbedRegularFont() { Id = \"rId9\" };\r\n// embedRegularFont.FontKey = \"{Manrope}\";\r\n\r\nfonts1.Append(font7);\r\n\r\nfontTablePart.Fonts = fonts1;\r\n```\r\n\r\n**Observed behavior**\r\nMicrosoft Word and the Productivity Tool report they cannot open the DOCX file.\r\n\r\nAfter Microsoft Word recovers the file, embedded fonts are no longer presented in the application.\r\n\r\n**Expected behavior**\r\nApplications should open the file without error.  Embedded fonts should continue to be presented.\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows 11\r\n - Office version: 16.0.17231.20194\r\n - .NET Target: .NET 8.0 ASP.NET\r\n - DocumentFormat.OpenXml Version: 3.0.1\r\n\r\n"},{"Id":"49419050545","Type":"IssuesEvent","CreatedAt":"2025-05-06T16:15:51","Actor":"mikeebowen","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1548","RelatedDescription":"Closed issue \"New APIs to facillitate getting started\" (#1548) at dotnet/Open-XML-SDK","RelatedBody":"This is a placeholder issue as we revamp some of the docs to identify APIs we should add to better handle common cases that are exposed by nullability analysis.  There appears to be a lot of boilerplate to build up a document that requires null checking and then adding parts, etc that we could probably add some helper methods to simplify things.\r\n\r\nFor example:\r\n\r\n```csharp\r\nSheets? sheets = workbookPart.Workbook.GetFirstChild<Sheets>();\r\n```\r\n\r\nthis could be null, so defensively, we would want something like:\r\n\r\n```csharp\r\nSheets sheets = workbookPart.Workbook.GetFirstChild<Sheets>() ?? workbookPart.Workbook.AppendChild(new Sheets());\r\n```\r\n\r\nThis becomes cumbersome, when we could add something similar to:\r\n\r\n```csharp\r\nSheets sheets = workbookPart.Workbook.GetFirstChildOrAdd<Sheets>();\r\n```\r\n\r\nAddtional APIs may be helpful here, and so I'm creating this issue to track some of these quality of life related APIs. I think we should also consider identifying patterns for analyzers to catch to move people to these better patterns as well"}],"ResultType":"GitHubEvent"}},"RunOn":"2025-05-09T03:30:21.386115Z","RunDurationInMilliseconds":632}