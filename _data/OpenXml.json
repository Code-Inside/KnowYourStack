{"Data":{"Sdk":{"Events":[{"Id":"30355482986","Type":"IssuesEvent","CreatedAt":"2023-07-11T23:05:09","Actor":"AlfredHellstern","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1490","RelatedDescription":"Opened issue \"CancellationToken in DocumentFormat.OpemXml.Packaging.SpreadsheetDocument.Open function\" (#1490) at dotnet/Open-XML-SDK","RelatedBody":"### Discussed in https://github.com/dotnet/Open-XML-SDK/discussions/1489\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **ahsanaman92** July  7, 2023</sup>\r\nVersion: DocumentFormat.OpenXml v2.20.0\r\n\r\nI am working on an issue where the customer has reported that it takes a while for the _DocumentFormat.OpemXml.Packaging.SpreadsheetDocument.Open_ function to determine a large Excel document (329 MB) is invalid over the network. Is there a plan to be able to pass a CancellationToken to the open function? \r\n\r\nThe function is passed a _System.IO.Stream input_ like this: using (SpreadsheetDocument Doc = SpreadsheetDocument.Open(input, false))</div>"},{"Id":"30355114772","Type":"IssuesEvent","CreatedAt":"2023-07-11T22:37:32","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1305","RelatedDescription":"Closed issue \"New ImagePart is created as .bin instead of real extension\" (#1305) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nI have asked the question on Stackoverflow:\r\nhttps://stackoverflow.com/questions/75100804/embedding-image-as-new-imagepart-creates-a-bin-file-using-open-xml-sdk\r\n\r\nI don't expect to get any answer there, and I am also increasingly curious whether, this is an implementation error but an issue in the SDK.\r\n\r\nIssue is, I create new embedded image in Excel and it is saved to ```/xl/media/image.[WhatEverExtensionItIs]```\r\nIf I create a new ImagePart with the SDK and feed it data like this:\r\n\r\n```\r\nImagePart new_ImagePart = worksheetPart.AddImagePart(ImagePartType.Tiff);\r\nstream.Position = 0;\r\nnew_ImagePart.FeedData(stream);\r\n```\r\n\r\nThen the file will be saved as ```/xl/media/image.bin```.\r\n\r\nThis behaviour it should not do. It should write the extension as .tiff, since this is the ```ImagePartType```, that I specify. Or secondly it should read the stream and identify it as .tiff through i.e. a magic number.\r\n\r\nIf you unzip the package and change the image extension to real extension, then the image will open perfectly and I have used a TIFF validator to confirm the image is well-formed. \r\n\r\nWhat do you think of this? Am I doing anything wrong in my implementation, or can we change the SDK to write real extension like Excel does?\r\n\r\n**Screenshots**\r\nIf applicable, add screenshots to help explain your problem.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Use the supplied code to stream any TIFF image (or change ImagePartType to any other image type) to a new ImagePart\r\n2. Unzip the spreadsheet and go to /xl/media/ to find the file as a .bin\r\n3. Change extension to .tiff and the image will open perfectly\r\n\r\n**Observed behavior**\r\nImagePart creates a new image with .bin extension\r\n\r\n**Expected behavior**\r\nImagePart should create a new image with extension based on ImagePartType.\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows 11\r\n - Office version: 2212\r\n - .NET Target: .Net latest version\r\n - DocumentFormat.OpenXml Version: 2.19"},{"Id":"30355084421","Type":"IssuesEvent","CreatedAt":"2023-07-11T22:35:22","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1305","RelatedDescription":"Reopened issue \"New ImagePart is created as .bin instead of real extension\" (#1305) at dotnet/Open-XML-SDK","RelatedBody":"**Describe the bug**\r\nI have asked the question on Stackoverflow:\r\nhttps://stackoverflow.com/questions/75100804/embedding-image-as-new-imagepart-creates-a-bin-file-using-open-xml-sdk\r\n\r\nI don't expect to get any answer there, and I am also increasingly curious whether, this is an implementation error but an issue in the SDK.\r\n\r\nIssue is, I create new embedded image in Excel and it is saved to ```/xl/media/image.[WhatEverExtensionItIs]```\r\nIf I create a new ImagePart with the SDK and feed it data like this:\r\n\r\n```\r\nImagePart new_ImagePart = worksheetPart.AddImagePart(ImagePartType.Tiff);\r\nstream.Position = 0;\r\nnew_ImagePart.FeedData(stream);\r\n```\r\n\r\nThen the file will be saved as ```/xl/media/image.bin```.\r\n\r\nThis behaviour it should not do. It should write the extension as .tiff, since this is the ```ImagePartType```, that I specify. Or secondly it should read the stream and identify it as .tiff through i.e. a magic number.\r\n\r\nIf you unzip the package and change the image extension to real extension, then the image will open perfectly and I have used a TIFF validator to confirm the image is well-formed. \r\n\r\nWhat do you think of this? Am I doing anything wrong in my implementation, or can we change the SDK to write real extension like Excel does?\r\n\r\n**Screenshots**\r\nIf applicable, add screenshots to help explain your problem.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Use the supplied code to stream any TIFF image (or change ImagePartType to any other image type) to a new ImagePart\r\n2. Unzip the spreadsheet and go to /xl/media/ to find the file as a .bin\r\n3. Change extension to .tiff and the image will open perfectly\r\n\r\n**Observed behavior**\r\nImagePart creates a new image with .bin extension\r\n\r\n**Expected behavior**\r\nImagePart should create a new image with extension based on ImagePartType.\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows 11\r\n - Office version: 2212\r\n - .NET Target: .Net latest version\r\n - DocumentFormat.OpenXml Version: 2.19"},{"Id":"30355009766","Type":"IssuesEvent","CreatedAt":"2023-07-11T22:30:03","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1147","RelatedDescription":"Reopened issue \"`PresentationDocument.Save()` doesn't apply changes\" (#1147) at dotnet/Open-XML-SDK","RelatedBody":"**Description**\r\n\r\n`PresentationDocument.Save()` doesn't apply changes that are deleting presentation sections. It works if I call `doc.Close()` _(check Repro)_, but I don't wanna close presentation before `mStream.ToArray()`.\r\n\r\nLooks like `PresentationDocument.Save()` doesn't flush changes to `mStream` stream.\r\n\r\n**Information**\r\n\r\n- .NET Target: .NET 6\r\n- DocumentFormat.OpenXml Version: 2.16.0\r\n\r\n**Repro**\r\n\r\n[base.pptx](https://github.com/OfficeDev/Open-XML-SDK/files/8662785/base.pptx)\r\n\r\n```csharp\r\nusing DocumentFormat.OpenXml.Office2010.PowerPoint;\r\nusing DocumentFormat.OpenXml.Packaging;\r\n\r\nusing var fStream = File.OpenRead(@\"c:\\temp\\base.pptx\");\r\nvar mStream = new MemoryStream();\r\nfStream.CopyTo(mStream);\r\nfStream.Close();\r\n\r\nusing var doc = PresentationDocument.Open(mStream, true);\r\nvar sectionList = doc.PresentationPart!.Presentation.PresentationExtensionList?.Descendants<SectionList>().First();\r\n\r\nsectionList.Remove();\r\ndoc.Save();\r\n// doc.Close() // it works\r\n\r\nFile.WriteAllBytes(@\"c:\\temp\\edited.pptx\", mStream.ToArray());\r\n\r\n// ...\r\n``` \r\n\r\n**Observed**\r\n\r\nedited.pptx still has section.\r\n\r\n**Expected**\r\n\r\nedited.pptx doesn't have sections.\r\n\r\n"},{"Id":"30295288781","Type":"IssuesEvent","CreatedAt":"2023-07-09T19:32:22","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/issues/1454","RelatedDescription":"Closed issue \"Performant way to compare OpenXmlElement\" (#1454) at dotnet/Open-XML-SDK","RelatedBody":"When comparing OpenXmlElement objects, there isn't an obvious performant way to do it.\r\nThe current top solution from [StackOverflow](https://stackoverflow.com/questions/21608492/comparing-two-xml-elements-in-openxml) does:\r\n\r\n```\r\nreturn font.OuterXml.Equals(existingFont.OuterXml);\r\n```\r\n\r\nPerformance wise this performs very poorly, due to two reasons:\r\n1. Lots of temporary allocations:\r\n1.1. StringWriter\r\n1.2. XmlDomTextWriter (which allocates a 6000 char buffer)\r\n1.3 Final string\r\n2. String comparison instead of comparing primitive types.\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\nDue to the amount of allocations, we are seeing tons of garbage collection happening when creating Excel sheets in our service.\r\nWhen creating the sheets we have attach styles for the sheet, but to avoid re-adding styles, we compare them to previously added styles.\r\n\r\n**Describe the solution you'd like**\r\nWould be nice if OpenXmlElement implemented IEquatable<T>.\r\nHowever, due to potential wishes for controlling ordering behaviour I could imagine someone wanting a more complex API, but I'm okay with any of them.\r\n\r\n**Describe alternatives you've considered**\r\nTried to implement a faster comparison based on writing to a stream and comparing the underlying bytes instead.\r\n\r\n```\r\nusing (var ms0 = new MemoryStream(256))\r\nusing (var ms1 = new MemoryStream(256))\r\nusing (XmlWriter writer = XmlWriter.Create(ms0, xwSettings))\r\nusing (XmlWriter writer2 = XmlWriter.Create(ms0, xwSettings))\r\n{\r\n    font.WriteTo(writer);\r\n    font.WriteTo(writer2);\r\n\r\n    writer.Flush();\r\n    writer2.Flush();\r\n\r\n    if (ms0.Position == ms1.Position)\r\n    {\r\n        byte[] buf1 = ms0.GetBuffer();\r\n        byte[] buf2 = ms1.GetBuffer();\r\n\r\n        buf1.AsSpan(0, (int)ms0.Position).SequenceEqual(ms1.GetBuffer().AsSpan(0, (int)ms1.Position));\r\n    }\r\n}\r\n```\r\n\r\nI have also tried to do the above, but reusing the XmlWriter and MemoryStream, which reduces the allocations and time significantly. However [StackOverflow](https://stackoverflow.com/questions/4919210/reusing-xmltextwriter-class) warns of reuse.\r\nHowever a slightly naive attempt to recurse the children and attributes show there is more to gain. It could be even faster if the GetAttributes didn't allocate a new list.\r\n\r\n**Additional context**\r\nBenchmarks:\r\n```\r\nBenchmarkDotNet=v0.13.5, OS=Windows 10 (10.0.19045.3086/22H2/2022Update)\r\nAMD Ryzen 7 5800X, 1 CPU, 16 logical and 8 physical cores\r\n.NET SDK=7.0.304\r\n  [Host] : .NET 6.0.18 (6.0.1823.26907), X64 RyuJIT AVX2\r\n\r\nServer=True  \r\n\r\n|          Method | N |       Mean |     Error |   StdDev |   Gen0 |   Gen1 | Allocated |\r\n|---------------- |-- |-----------:|----------:|---------:|-------:|-------:|----------:|\r\n|              MS | 1 | 4,455.6 ns |  57.62 ns | 51.08 ns | 0.9537 | 0.0381 |   16024 B |\r\n|           Reuse | 1 | 2,732.4 ns |  12.43 ns | 11.02 ns | 0.0076 |      - |     144 B |\r\n|        OuterXML | 1 | 5,784.4 ns | 100.72 ns | 98.92 ns | 1.7548 | 0.0839 |   29424 B |\r\n| RecursiveManual | 1 |   974.1 ns |   3.62 ns |  3.21 ns | 0.0648 |      - |    1104 B |\r\n```\r\n"},{"Id":"30295283777","Type":"PullRequestEvent","CreatedAt":"2023-07-09T19:31:34","Actor":"twsouthwick","Repository":"dotnet/Open-XML-SDK","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/Open-XML-SDK/pull/1476","RelatedDescription":"Merged pull request \"Introduce equality comparers for OpenXmlElement\" (#1476) at dotnet/Open-XML-SDK","RelatedBody":"Problem:\r\nThe current way to determine equality for two OpenXmlElements seems to\r\nbe x.OuterXml.Equals(y.OuterXml) (based on StackOverflow top answer).\r\n\r\nThis performs horribly due to allocation of strings and XmlWriter.\r\n\r\nSolution:\r\nThis PR introduces OpenXmlElementEqualityComparer which supports equality determination.\r\nFurthermore, the definition of equality is defined by OpenXmlElementEqualityOptions which allows for controlling how equality should be defined.\r\n\r\nBenchmark results comparing to x.OuterXml.Equals(y.OuterXml):\r\n```\r\nBenchmarkDotNet=v0.13.2, OS=Windows 10 (10.0.19045.3086)\r\nAMD Ryzen 7 5800X, 1 CPU, 16 logical and 8 physical cores\r\n.NET SDK=7.0.304\r\n  [Host] : .NET 7.0.7 (7.0.723.27404), X64 RyuJIT AVX2\r\n\r\nJob=InProcess  Toolchain=InProcessEmitToolchain\r\n\r\n|                       Method |              Mean |           Error |          StdDev |     Gen0 |     Gen1 |     Gen2 | Allocated |\r\n|----------------------------- |------------------:|----------------:|----------------:|---------:|---------:|---------:|----------:|\r\n|         OuterXmlLargeElement | 22,469,563.462 ns | 156,783.6460 ns | 130,921.4452 ns | 437.5000 | 281.2500 | 218.7500 | 7370176 B |\r\n|           EqualsLargeElement |  9,235,127.232 ns | 118,532.7404 ns | 105,076.1870 ns |        - |        - |        - |      10 B |\r\n| EqualsLargeElementSkipPrefix |  4,165,810.498 ns |  78,261.1757 ns |  76,862.9390 ns |        - |        - |        - |       5 B |\r\n|             UnparsedOuterXml |          3.296 ns |       0.0140 ns |       0.0131 ns |        - |        - |        - |         - |\r\n|               UnparsedEquals |          4.721 ns |       0.0149 ns |       0.0125 ns |        - |        - |        - |         - |\r\n|                SmallOuterXml |      3,616.694 ns |      52.6133 ns |      43.9345 ns |   1.7662 |   0.0877 |        - |   29584 B |\r\n|                  SmallEquals |        705.613 ns |       3.4249 ns |       3.2037 ns |   0.0010 |        - |        - |      24 B |\r\n|        SmallEqualsSkipPrefix |        376.926 ns |       3.3287 ns |       2.9508 ns |   0.0014 |        - |        - |      24 B |\r\n```"}],"ResultType":"GitHubEvent"}},"RunOn":"2023-07-12T03:30:24.1606861Z","RunDurationInMilliseconds":693}