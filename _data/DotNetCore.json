{"Data":{"Blog":{"FeedItems":[{"Title":"Migrating your existing .NET application to the cloud? Tell us about it!","PublishedOn":"2017-12-05T18:14:46+00:00","CommentsCount":0,"FacebookCount":0,"Summary":"Hi everyone! The .NET team is conducting a survey to¬†learn more about your approach for moving existing .NET applications to the cloud.¬† The survey should take less than 5 minutes to complete. Take...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/12/05/migrating-your-existing-net-application-to-the-cloud-tell-us-about-it/","RawContent":null},{"Title":"Announcing the Windows Compatibility Pack for .NET Core","PublishedOn":"2017-11-17T04:59:32+00:00","CommentsCount":73,"FacebookCount":0,"Summary":"Porting existing code to .NET Core used to be quite hard because the available API set was very small. In .NET Core 2.0, we already made this much easier, thanks to¬†.NET Standard 2.0. Today,...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack-for-net-core/","RawContent":null},{"Title":"UPDATE ‚Äì Microservices and Docker containers: Architecture, Patterns and Development guidance (Updated for .NET Core 2.0)","PublishedOn":"2017-11-16T22:00:06+00:00","CommentsCount":1,"FacebookCount":0,"Summary":"Nov. 15th 2017 update Earlier this year, we published this eBook/guide and sample application offering guidance for architecting microservices and Docker containers based applications. We have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/update-microservices-and-docker-containers-architecture-patterns-and-development-guidance-updated-for-net-core-2-0/","RawContent":null},{"Title":"UPDATE ‚Äì Web Applications with ASP.NET Core Architecture and Patterns guidance (Updated for ASP.NET Core 2)","PublishedOn":"2017-11-16T21:00:05+00:00","CommentsCount":3,"FacebookCount":0,"Summary":"Nov. 15th 2017 update Earlier this year, we published an eBook/Guide and sample application offering guidance named¬†Architecting Modern Web Applications with ASP.NET Core and Microsoft Azure. We have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/16/update-web-applications-with-asp-net-core-architecture-and-patterns-guidance-updated-for-asp-net-core-2/","RawContent":null},{"Title":"Introducing Tensor for multi-dimensional Machine Learning and AI data","PublishedOn":"2017-11-15T22:00:18+00:00","CommentsCount":10,"FacebookCount":0,"Summary":"Overview Tensor is an exchange type for homogenous multi-dimensional data for 1 to N dimensions. The motivation behind introducing Tensor&#60;T&#62; is to make it easy for Machine Learning library...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/introducing-tensor-for-multi-dimensional-machine-learning-and-ai-data/","RawContent":null},{"Title":"Introducing Nullable Reference Types in C#","PublishedOn":"2017-11-15T20:00:47+00:00","CommentsCount":234,"FacebookCount":0,"Summary":"Today we released a prototype of a C# feature called &#8220;nullable reference types&#8220;, which is intended to help you find and fix most of your null-related bugs before they blow up at runtime....","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/","RawContent":null},{"Title":"Announcing F# support for .NET Core and .NET Standard projects in Visual Studio","PublishedOn":"2017-11-15T19:00:49+00:00","CommentsCount":11,"FacebookCount":0,"Summary":"We&#8217;re pleased to announce that Visual Studio 2017 15.5 Preview 4 now supports F# projects targeting .NET Core, .NET Standard, and .NET Framework through the .NET Core SDK. Some of you have...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/announcing-f-support-for-net-core-and-net-standard-projects-in-visual-studio/","RawContent":null},{"Title":"Welcome to C# 7.2 and Span","PublishedOn":"2017-11-15T19:00:26+00:00","CommentsCount":29,"FacebookCount":0,"Summary":"C# 7.2 is the latest point release of C#, and adds a number of small but useful features. All the features are described in wonderful detail in the docs. Start with the overview, What&#8217;s new in...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/15/welcome-to-c-7-2-and-span/","RawContent":null},{"Title":".NET Core November 2017 Update","PublishedOn":"2017-11-15T05:25:23+00:00","CommentsCount":12,"FacebookCount":0,"Summary":"Today, we are releasing the .NET Core November Update. This includes .NET Core 1.0.8, 1.1.5 and 2.0.1 and .NET Core SDK 1.1.5 and 2.0.3. Details regarding the security issues addressed by this release...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-core-november-2017-update/","RawContent":null},{"Title":".NET Framework November 2017 Security and Quality Rollup","PublishedOn":"2017-11-15T03:54:36+00:00","CommentsCount":8,"FacebookCount":0,"Summary":"Today, we are releasing the November 2017 Security and Quality Rollup. Security This release contains no new security updates. The most recent .NET security updates were shipped with the September...","Href":"https://blogs.msdn.microsoft.com/dotnet/2017/11/14/net-framework-november-2017-security-and-quality-rollup/","RawContent":null}],"ResultType":"Feed"},"Home":{"Events":[{"Id":"6946829856","Type":"PullRequestEvent","CreatedAt":"2017-12-05T18:08:42","Actor":"heiligerdankgesang","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/92","RelatedDescription":"Opened pull request \"Remove contact email from system.drawing.md\" (#92) at dotnet/home","RelatedBody":"Contact email is outdated. Mono-project site's community section has better, more up-to-date information."},{"Id":"6934052963","Type":"PullRequestEvent","CreatedAt":"2017-12-02T15:19:09","Actor":"rprouse","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/91","RelatedDescription":"Opened pull request \"Add NUnit to the .NET Foundation Projects\" (#91) at dotnet/home","RelatedBody":""},{"Id":"6872255902","Type":"PullRequestEvent","CreatedAt":"2017-11-17T22:01:26","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/90","RelatedDescription":"Merged pull request \"Add BenchmarkDotNet to README.md and project.json\" (#90) at dotnet/home","RelatedBody":""},{"Id":"6872252909","Type":"PullRequestEvent","CreatedAt":"2017-11-17T22:00:44","Actor":"jongalloway","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Merged pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""},{"Id":"6868854916","Type":"PullRequestEvent","CreatedAt":"2017-11-17T09:04:03","Actor":"AndreyAkinshin","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/90","RelatedDescription":"Opened pull request \"Add BenchmarkDotNet to README.md and project.json\" (#90) at dotnet/home","RelatedBody":""},{"Id":"6816687850","Type":"IssuesEvent","CreatedAt":"2017-11-06T20:30:07","Actor":"Petermarcu","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/home/issues/88","RelatedDescription":"Closed issue \"File system watcher crash\" (#88) at dotnet/home","RelatedBody":"Not sure where to open this issue.\r\nI'm experiencing crashes since I migrated to .net core 2.0 while running my site.\r\nThe following is the exception and stack trace:\r\n```\r\nAn unhandled exception of type 'System.ArgumentException' occurred in System.Private.CoreLib.dll\r\nThe path is not of a legal form.\r\n\r\nSystem.Private.CoreLib.dll!System.IO.Path.GetFullPath(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.InMemoryDirectoryInfo(string rootDir, System.Collections.Generic.IEnumerable<string> files, bool normalized)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string rootDir, System.Collections.Generic.IEnumerable<string> files)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileSystemGlobbing.dll!Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher matcher, string file)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.ReportChangeForMatchedEntries(string path)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnFileSystemEntryChange(string fullPath)\tUnknown\tNo symbols loaded.\r\n \tMicrosoft.Extensions.FileProviders.Physical.dll!Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.OnRenamed(object sender, System.IO.RenamedEventArgs e)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.NotifyRenameEventArgs(System.IO.WatcherChangeTypes action, string name, string oldName)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ParseEventBufferAndNotifyForEach(byte[] buffer)\tUnknown\tNo symbols loaded.\r\n \tSystem.IO.FileSystem.Watcher.dll!System.IO.FileSystemWatcher.ReadDirectoryChangesCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* overlappedPointer)\tUnknown\tNo symbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP)\tUnknown\tNo symbols loaded.\r\n```\r\n\r\nI'm not sure how to fix this. I can reproduce it although it's not easy since I think it has to do with timing..."},{"Id":"6797468573","Type":"PullRequestEvent","CreatedAt":"2017-11-01T23:04:17","Actor":"bfistein","Repository":"dotnet/home","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/home/pull/89","RelatedDescription":"Opened pull request \"New logo and SSL certificate for Peachpie\" (#89) at dotnet/home","RelatedBody":""}],"ResultType":"GitHubEvent"},"Announcements":{"Events":[{"Id":"6948315401","Type":"IssuesEvent","CreatedAt":"2017-12-05T23:41:57","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/announcements/issues/50","RelatedDescription":"Closed issue \".Net Core ARM32 SDK availability\" (#50) at dotnet/announcements","RelatedBody":"Referencing #29.\r\n\r\nWill it be possible to : \r\n\r\na) Provide ARM32 builds for the SDK at its current state\r\nor\r\nb) Provide links on how to build the .Net Core SDK for ARM32?\r\n\r\nThe thing is I am planning to use it in a virtual environnement, through proot + qemu-arm-static. This way I would be able to build and, more importantly, run unit tests on ARM32. Another thing I am planning to do is to setup a build environnement on i686 through virtualisation as qemu doesn't seem to be able to emulate x86_64 on i686 (but arm32 does seem to work well enough).\r\n\r\nThank you in advance.\r\n\r\nSergio\r\n\r\n"},{"Id":"6944555922","Type":"IssuesEvent","CreatedAt":"2017-12-05T10:46:06","Actor":"tioduke","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/50","RelatedDescription":"Opened issue \".Net Core ARM32 SDK availability\" (#50) at dotnet/announcements","RelatedBody":"Will it be possible to : \r\n\r\na) Provide ARM32 builds for the SDK at its current state\r\nor\r\nb) Provide links on how to build the .Net Core SDK for ARM32?\r\n\r\nThe thing is I am planning to use it in a virtual environnement, through proot + qemu-arm-static. This way I would be able to build and, more importantly, run unit tests on ARM32. Another thing I am planning to do is to setup a build environnement on i686 through virtualisation as qemu doesn't seem to be able to emulate x86_64 on i686 (but arm32 does seem to work well enough).\r\n\r\nThank you in advance.\r\n\r\nSergio\r\n\r\n"},{"Id":"6886438076","Type":"IssuesEvent","CreatedAt":"2017-11-21T19:28:57","Actor":"richlander","Repository":"dotnet/announcements","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/announcements/issues/49","RelatedDescription":"Opened issue \".NET Core Alpine Image Ready for Testing\" (#49) at dotnet/announcements","RelatedBody":"# .NET Core Alpine Image Ready for Testing\r\n\r\nAn [Alpine](https://hub.docker.com/_/alpine/)-based Docker image is now available for .NET Core. Alpine is much smaller than Debian, which we have used for the .NET Core base image to date. There have been many requests for an Alpine image. We are pleased to make it available. Please check out [.NET Core Docker Alpine Production Sample (Preview)](https://github.com/dotnet/dotnet-docker-samples/blob/master/dotnetapp-prod-alpine-preview/README.md) to see examples of using this image.\r\n\r\nWe have added two new images:\r\n\r\n- `2.1-runtime-alpine`\r\n- `2.1-runtime-deps-alpine`\r\n\r\nAlpine support is part of the .NET Core 2.1 release. .NET Core 2.1 images are currently provided at the [microsoft/dotnet-nightly](https://hub.docker.com/r/microsoft/dotnet-nightly/) repo, including the new Alpine images. .NET Core 2.1 images will be promoted to the [microsoft/dotnet](https://hub.docker.com/r/microsoft/dotnet/) repo when .NET Core 2.1 is shipped as a Preview, expected to be early 2018.\r\n\r\n## Discussion\r\n\r\nPlease share your thoughts on this change and see what others are saying at:\r\n\r\n* [dotnet/dotnet-docker-nightly #500](https://github.com/dotnet/dotnet-docker-nightly/issues/500)\r\n\r\n## Details\r\n\r\n* [dotnet/dotnet-docker-nightly #480](https://github.com/dotnet/dotnet-docker-nightly/pull/480)\r\n* [dotnet/announcements #20](https://github.com/dotnet/announcements/issues/20)\r\n* [dotnet/dotnet-docker-samples #94](https://github.com/dotnet/dotnet-docker-samples/pull/94)\r\n\r\nThe primary goal of Alpine is very small deployments. We have been considering various design decisions to make .NET Core Alpine base images as small as possible to align with that. In this first iteration, we enabled [.NET Core 2.0 Globalization Invariant Mode](https://github.com/dotnet/announcements/issues/20) in order to reduce the default size of the image. This change reduced the image by ~30MB. You can see the reduction in size for .NET Core images relative to Debian in the following table.\r\n\r\n|2.1 Image|Debian|Alpine|\r\n|-----    |------|------|\r\n|`-deps`   |153MB (68MB compressed) |13.8 MB (6MB compressed)|\r\n|`-runtime`|222MB (96MB compressed) |82.5 (34MB compressed)|\r\n\r\nNote: The compressed size is what you will see in a [registry](https://hub.docker.com/r/microsoft/dotnet-nightly/tags/) and is the wire-size cost.\r\n\r\nWe are also considering saving more space by native-compiling fewer assemblies. .NET Core runtime assemblies are native-compiled with the [crossgen tool](https://github.com/dotnet/coreclr/blob/master/Documentation/building/crossgen.md) in the [Ready2Run format](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md). Native-compiled code delivers superior startup performance but at the cost of 2-3x larger files. We have the opportunity to compile less, skipping compiling assemblies in part or in whole. We believe that we can save at least another 10MB through compiling less without a material drop in performance. For scenarios that value size over startup or where wire cost is significant, it may be valuable to aggressively reduce the number/% of compilation.\r\n\r\nAlpine images are only available for .NET Core 2.1. At the current time, only Runtime images are available. We intend to offer SDK images at a later date.\r\n\r\nUse cases that cannot tolerate Globalization invariant mode can reset the `DOTNET_SYSTEM_GLOBALIZATION_INVARIANT` environment variable and install the ICU package. Please check out [.NET Core Docker Alpine Production Sample (Preview)](https://github.com/dotnet/dotnet-docker-samples/blob/master/dotnetapp-prod-alpine-preview/README.md) to see examples of using this image with and without Globalization Invariant Mode enabled.\r\n\r\n## Call to Action\r\n\r\nPlease test your workloads with the new Alpine image. In particular, we want to know if enabling .NET Core Globalization Invariant Mode is acceptable/appreciated.\r\n"}],"ResultType":"GitHubEvent"},"CoreCLR":{"Events":[{"Id":"7027581965","Type":"IssuesEvent","CreatedAt":"2017-12-24T23:26:58","Actor":"Dmitry-Me","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/15632","RelatedDescription":"Opened issue \"Use of delete[] inside ComCallWrapperTemplate::Cleanup() yields undefined behavior\" (#15632) at dotnet/coreclr","RelatedBody":"`ComCallWrapperTemplate::Cleanup()` invokes `delete[] this`. Here's how the object memory is allocated inside `ComCallWrapperTemplate::CreateTemplate()`:\r\n\r\n    pTemplate = (ComCallWrapperTemplate*)new BYTE[sizeof(ComCallWrapperTemplate) + numInterfaces * sizeof(SLOT)];\r\n\r\nWhen `delete[] this` is invoked `this` has type `ComCallWrapperTemplate*` and it's undefined behavior to use `delete[]` on a pointer which has type unrelated to the type used with `new[]`. `this` must be first cast to `BYTE*`."},{"Id":"7027571797","Type":"IssuesEvent","CreatedAt":"2017-12-24T23:14:08","Actor":"Dmitry-Me","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/issues/15631","RelatedDescription":"Opened issue \"Race condition in using InterlockedIncrement() in ShimProxyCallback::AddRef()\" (#15631) at dotnet/coreclr","RelatedBody":"This is most likely not dangerous but still it's a race condition. `ShimProxyCallback::AddRef()` calls `InterlockedIncrement()` and then directly accesses the variable just incremented again to use its value as return value. The value might have changed inbetween. The usual approach is to use `InterlockedIncrement()` return value instead."},{"Id":"7026985417","Type":"PullRequestEvent","CreatedAt":"2017-12-24T13:19:28","Actor":"dotnet-maestro-bot","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15630","RelatedDescription":"Opened pull request \"Update CoreClr to preview1-26024-03 (master)\" (#15630) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"},{"Id":"7026673192","Type":"PullRequestEvent","CreatedAt":"2017-12-24T08:02:04","Actor":"ahsonkhan","Repository":"dotnet/coreclr","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/coreclr/pull/15628","RelatedDescription":"Merged pull request \"Update CoreClr, CoreFx to preview1-26024-02, preview1-26024-01, respectively (master)\" (#15628) at dotnet/coreclr","RelatedBody":"/cc @dotnet/coreclr-auto-update-notify"}],"ResultType":"GitHubEvent"},"CLI":{"Events":[{"Id":"7026179007","Type":"PullRequestEvent","CreatedAt":"2017-12-23T22:17:49","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8292","RelatedDescription":"Opened pull request \"Update CoreSetup to preview1-26023-02 (master)\" (#8292) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"7026062843","Type":"IssuesEvent","CreatedAt":"2017-12-23T20:19:41","Actor":"ThadHouse","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8291","RelatedDescription":"Opened issue \"Better instructions for using preview SDK's from Visual Studio\" (#8291) at dotnet/cli","RelatedBody":"I wanted to test out some of the Span functionality, so I was attempting to install the newest preview SDK in order to do this. I installed the latest version of the preview SDK (2.2.0-preview1-007851 at the time of this issue), and made sure I was using Visual Studio 15.5.2. I also added the myget nuget package source to my solution. However, visual studio does not seem to properly be restoring everything. I get an error `Unable to find package Microsoft.NETCore.App with version (>= 2.2.0-preview1-007851)`, and then a whole bunch of errors saying the System namespace can not be found. I can't find any more instructions on how to make it easy to use preview SDK's from visual studios. Can I get some help with getting this working, and potentially some better instructions for future users who want to do this? Below I have put my csproj file.\r\n\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>netcoreapp2.0</TargetFramework>\r\n    <RuntimeFrameworkVersion>2.2.0-preview1-007851</RuntimeFrameworkVersion>\r\n    <LangVersion>7.2</LangVersion>\r\n  </PropertyGroup>\r\n  \r\n</Project>\r\n```\r\n\r\n"},{"Id":"7026059654","Type":"IssuesEvent","CreatedAt":"2017-12-23T20:16:29","Actor":"richlander","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8290","RelatedDescription":"Opened issue \".NET Core SDK doesn't run in globalization invariant mode\" (#8290) at dotnet/cli","RelatedBody":"I wasn't able to get the .NET Core SDK to run in globalization invariant mode with Alpine.\r\n\r\nSee https://github.com/dotnet/dotnet-docker-nightly/pull/508\r\n\r\nTo repro, remove the last three lines of the Dockerfile.\r\n\r\nSample you can use for testing is at https://github.com/dotnet/dotnet-docker-samples/tree/alpine/dotnetapp-prod"},{"Id":"7025997341","Type":"PullRequestEvent","CreatedAt":"2017-12-23T19:15:46","Actor":"johnbeisner","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8289","RelatedDescription":"Merged pull request \"Update CoreSetup to preview1-26023-01 (master)\" (#8289) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"7025953055","Type":"PullRequestEvent","CreatedAt":"2017-12-23T18:33:37","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8289","RelatedDescription":"Opened pull request \"Update CoreSetup to preview1-26023-01 (master)\" (#8289) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"7025797190","Type":"IssuesEvent","CreatedAt":"2017-12-23T16:14:45","Actor":"richlander","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/issues/8288","RelatedDescription":"Opened issue \"CLI first-run process creates repeating visual artifacts\" (#8288) at dotnet/cli","RelatedBody":"## Steps to reproduce\r\n\r\nBuild [SDK docker container](https://github.com/dotnet/dotnet-docker/tree/master/2.0/sdk/stretch/amd64).\r\n\r\n## Expected  behavior\r\n\r\nNo duplicating artifacts\r\n\r\n## Actual behavior\r\n\r\nA command is running to populate your local package cache to improve restore speed and enable offline access. This command takes up to one minute to complete and only runs once.\r\nDecompressing 0%...1%...2%...3%...4%...5%...6%...7%...8%...9%...10%...11%...12%...13%...14%...15%...16%...17%...18%...19%...20%...21%...22%...23%...24%...25%...26%...27%...28%...29%...30%...31%...32%...33%...34%...35%...36%...37%...38%...39%...40%...41%...42%...43%...44%...45%...46%...47%...48%...49%...50%...51%...52%...53%...54%...55%...56%...57%...58%...59%...60%...61%...62%...63%...64%...65%...66%...67%...68%...69%...70%...71%...72%...73%...74%...75%...76%...77%...78%...79%...80%...81%...82%...83%...84%...85%...86%...87%...88%...89%...90%...91%...92%...93%...94%...95%...96%...97%...98%...99%...100% 7108 ms\r\nExpanding 0%...1%...2%...3%...4%...5%...6%...7%...8%...9%...10%...11%...12%...13%...14%...15%...16%...17%...18%...19%...20%...21%...22%...23%...24%...25%...26%...27%...28%...29%...30%...31%...32%...33%...34%...35%...36%...37%...38%...39%...40%...41%...42%...43%...44%...45%...46%...47%...48%...49%...50%...51%...52%...53%...54%...55%...56%...57%...58%...59%...60%...61%...62%...63%...64%...65%...66%...67%...68%...69%...70%...71%...72%...73%...74%...75%...76%...77%...78%...79%...80%...81%...82%...83%...84%...85%...86%...87%...88%...89%...90%...91%...92%...93%...94%...95%...96%...97%...98%...99%...100% 16836 ms\r\n\r\n## Environment\r\n\r\nHappens with cmd.exe and bash when building container images with Docker.exe."},{"Id":"7024735529","Type":"PullRequestEvent","CreatedAt":"2017-12-22T23:15:20","Actor":"johnbeisner","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8287","RelatedDescription":"Merged pull request \"Update CoreSetup to preview1-26022-04 (master)\" (#8287) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"7024659621","Type":"PullRequestEvent","CreatedAt":"2017-12-22T22:34:25","Actor":"dotnet-bot","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/cli/pull/8287","RelatedDescription":"Opened pull request \"Update CoreSetup to preview1-26022-04 (master)\" (#8287) at dotnet/cli","RelatedBody":"/cc @dotnet/dotnet-cli"},{"Id":"7024582180","Type":"PullRequestEvent","CreatedAt":"2017-12-22T21:57:00","Actor":"johnbeisner","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8281","RelatedDescription":"Merged pull request \"Insert NuGet Build 4.6.0-preview2-4759 into cli\" (#8281) at dotnet/cli","RelatedBody":"Insert NuGet Build 4.6.0-preview2-4759 into cli master branch"},{"Id":"7024456474","Type":"PullRequestEvent","CreatedAt":"2017-12-22T21:03:06","Actor":"johnbeisner","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/8277","RelatedDescription":"Closed pull request \"Merge release/2.0.0 to release/2.1\" (#8277) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/2.1.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/2.1-20171221-080038\ngit reset --hard upstream/release/2.1\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/2.1-20171221-080038 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7024456328","Type":"PullRequestEvent","CreatedAt":"2017-12-22T21:03:01","Actor":"johnbeisner","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/8272","RelatedDescription":"Closed pull request \"Merge release/2.0.0 to release/2.1\" (#8272) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/2.1.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/2.1-20171220-080041\ngit reset --hard upstream/release/2.1\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/2.1-20171220-080041 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7024455717","Type":"PullRequestEvent","CreatedAt":"2017-12-22T21:02:46","Actor":"johnbeisner","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/cli/pull/8229","RelatedDescription":"Closed pull request \"Merge release/2.0.0 to release/2.1\" (#8229) at dotnet/cli","RelatedBody":"\nThis is an automatically generated pull request from release/2.0.0 into release/2.1.\n\n``` bash\ngit fetch --all\ngit checkout merges/release/2.0.0-to-release/2.1-20171213-080039\ngit reset --hard upstream/release/2.1\ngit merge upstream/release/2.0.0\n# Fix merge conflicts\ngit commit\ngit push merges/release/2.0.0-to-release/2.1-20171213-080039 --force\n```\n\nOnce all conflicts are resolved and all the tests pass, you are free to merge the pull request."},{"Id":"7024418751","Type":"PullRequestEvent","CreatedAt":"2017-12-22T20:47:34","Actor":"wli3","Repository":"dotnet/cli","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/cli/pull/8286","RelatedDescription":"Merged pull request \"Check null for getenv\" (#8286) at dotnet/cli","RelatedBody":"As you see, the implementation of the 3 OS to check PATH is different.\r\nThere is not too much to extract. And I tried to move the\r\n\"contains a folder path in env:path?\" to a method. But that\r\nmethod requires to pass in env:path, targetapath and path separator for\r\ndifferent OS. This method has low value. And people still must\r\nremember to use this method. So I just added simple null check to the\r\nplace I used GetEnvPath.\r\n"}],"ResultType":"GitHubEvent"},"Standard":{"Events":[{"Id":"7020301855","Type":"IssuesEvent","CreatedAt":"2017-12-21T20:59:25","Actor":"desmondgc","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/standard/issues/604","RelatedDescription":"Closed issue \"How to avoid incompatibilities between .NET Standard 2.0 and .NET Framework 4.6.1\" (#604) at dotnet/standard","RelatedBody":"I have a .NET Standard 2.0 class library that uses System.Net.Http.HttpClientHandler. The class library is referenced in multiple projects, including a WPF application targeting .NET Framework 4.6.1. I am trying to set the HttpClientHandler.MaxConnectionsPerServer property which causes a MissingMethodException on systems without .NET Framework 4.7.1 installed.\r\n\r\n```\r\nvar baseHandler = new HttpClientHandler\r\n{\r\n    AutomaticDecompression = System.Net.DecompressionMethods.GZip,\r\n    MaxConnectionsPerServer = 32\r\n};\r\n```\r\n\r\n```\r\nSystem.MissingMethodException: Method not found: 'Void System.Net.Http.HttpClientHandler.set_MaxConnectionsPerServer(Int32)'.\r\n```\r\n\r\nThis is expected - MaxConnectionsPerServer is one of the [APIs with known compatibility issues](https://github.com/dotnet/standard/blob/master/netstandard/src/ApiCompatBaseline.net461.txt).\r\n\r\nFirst workaround attempt - catch MissingMethodException:\r\n\r\n```\r\nvar baseHandler = new HttpClientHandler\r\n{\r\n    AutomaticDecompression = System.Net.DecompressionMethods.GZip,\r\n};\r\n\r\ntry\r\n{\r\n    baseHandler.MaxConnectionsPerServer = 32;\r\n}\r\ncatch (MissingMethodException)\r\n{\r\n    // Available since .NET Framework 4.7.1\r\n}\r\n```\r\n\r\nDoesn't work - the exception is still raised. Some SO posts suggest that it's generally not possible to catch MissingMethodException.\r\n\r\nSecond workaround attempt - reflection:\r\n\r\n```\r\nvar baseHandler = new HttpClientHandler\r\n{\r\n    AutomaticDecompression = System.Net.DecompressionMethods.GZip,\r\n};\r\n\r\nif (typeof(HttpClientHandler).GetProperty(\"MaxConnectionsPerServer\") != null)\r\n{\r\n    // Available since .NET Framework 4.7.1\r\n    baseHandler.MaxConnectionsPerServer = 32;\r\n}\r\n```\r\n\r\nDoesn't work - GetProperty doesn't return null.\r\n\r\nHow am I expected to avoid this scenario?"},{"Id":"7018954133","Type":"IssuesEvent","CreatedAt":"2017-12-21T15:32:21","Actor":"0xF6","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/612","RelatedDescription":"Opened issue \"Merge Library?\" (#612) at dotnet/standard","RelatedBody":"Now to merge.NET Standard libraries into one library?"},{"Id":"7016897774","Type":"IssuesEvent","CreatedAt":"2017-12-21T07:05:12","Actor":"viswa18","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/issues/611","RelatedDescription":"Opened issue \"System.Diagnostics.Process.Start(info) show icon in Mac\" (#611) at dotnet/standard","RelatedBody":"I am having a simple C++ command line app, which is starts from .NetStandard2.0 class library. Below is code snippet to start the process, but it show dock icon in mac. \r\n\r\n```\r\nSystem.Diagnostics.ProcessStartInfo info = new System.Diagnostics.ProcessStartInfo \r\n{\r\nFileName = helloworld\",\r\nRedirectStandardOutput = true,\r\nRedirectStandardError = true,\r\nUseShellExecute = false,\r\nCreateNoWindow = true,\r\nArguments = args,\r\nWindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden, \r\nErrorDialog = false,\r\n};\r\nSystem.Diagnostics.Process process = System.Diagnostics.Process.Start(info);\r\n```\r\nIs it possible to prevent the icon in dock for mac? "},{"Id":"7015432489","Type":"PullRequestEvent","CreatedAt":"2017-12-20T21:45:45","Actor":"dotnet-maestro-bot","Repository":"dotnet/standard","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/standard/pull/610","RelatedDescription":"Opened pull request \"Update BuildTools to prerelease-02320-01 (master)\" (#610) at dotnet/standard","RelatedBody":""}],"ResultType":"GitHubEvent"},"CoreFx":{"Events":[{"Id":"7027667875","Type":"PullRequestEvent","CreatedAt":"2017-12-25T01:13:19","Actor":"dotnet-maestro-bot","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/26046","RelatedDescription":"Opened pull request \"Update CoreClr, CoreFx, CoreSetup to preview1-26025-01, preview1-26024-02, preview1-26024-02, respectively (master)\" (#26046) at dotnet/corefx","RelatedBody":""},{"Id":"7027555088","Type":"IssuesEvent","CreatedAt":"2017-12-24T22:53:05","Actor":"realvictorprm","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/26045","RelatedDescription":"Opened issue \"Add another constructor to Span using IntPtr\" (#26045) at dotnet/corefx","RelatedBody":"Hello,\r\n\r\nin F# we cannot cast ptr's to void ptr's (the type `nativeptr<unit>` is disallowed due to `unit` isn't an unmanaged type). Therefor it's currently not possible for me to create a Span from stackallocated memory in F# üò¢ . \r\n\r\nEasiest solution short-term would be to add another constructor to the Span class which accepts an `IntPtr`. Long-term I try to solve the issue in F#, for reference see [this](https://github.com/Microsoft/visualfsharp/issues/4166) issue.\r\n\r\nIf there's something wrong with `IntPtr` please tell me, I might miss some reason for not using itü§î ?"},{"Id":"7027345654","Type":"PullRequestEvent","CreatedAt":"2017-12-24T18:51:24","Actor":"the-dwyer","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/pull/26044","RelatedDescription":"Opened pull request \"Increase code coverage for System.Net.Security\" (#26044) at dotnet/corefx","RelatedBody":"Hi,\r\n\r\nPursuant to issue #17099, I have added tests for a couple of classes.\r\n\r\nIf you have any questions or comments, please let me know.\r\n\r\nThanks,\r\n\r\nMichael"},{"Id":"7027217951","Type":"IssuesEvent","CreatedAt":"2017-12-24T16:41:44","Actor":"Maxim-Kornilov","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corefx/issues/26043","RelatedDescription":"Opened issue \"Unsubscribe from Console.CancelKeyPress hangs after Task.Delay was cancelled\" (#26043) at dotnet/corefx","RelatedBody":"This will happen only if all of these conditions are met:\r\n1) use Task.Delay\r\n2) token source was cancelled inside ConsoleCancelEventHandler;\r\n3) token source was cancelled with CancellationTokenSource.Cancel method;\r\n4) method marked as async and Task.Delay is awaited.\r\n\r\nBug is not reproduced if any of these conditions is violated:\r\n- **Condition ‚Ññ1 is violated:** Use any other task instead of `Task.Delay`\r\n[AsyncTaskCancel.cs](https://github.com/Maxim-Kornilov/CancelKeyPressBug/blob/master/CancelKeyPressBug/TestCases/AsyncTaskCancel.cs#L17)\r\n- **Condition ‚Ññ2 is violated:** Cancel outside `ConsoleCancelEventHandler`\r\n[AsyncDelayCancelOutsideHandler.cs](https://github.com/Maxim-Kornilov/CancelKeyPressBug/blob/master/CancelKeyPressBug/TestCases/AsyncDelayCancelOutsideHandler.cs#L20)\r\nBut it hangs inside `ConsoleCancelEventHandler` if I add `GetAwaiter().GetResult()` to `Task.Run(() => tokenSource.Cancel())`\r\n- **Condition ‚Ññ3 is violated:** Cancel using `CancelAfter`\r\n[AsyncDelayCancelAfter.cs](https://github.com/Maxim-Kornilov/CancelKeyPressBug/blob/master/CancelKeyPressBug/TestCases/AsyncDelayCancelAfter.cs#L20)\r\n- **Condition ‚Ññ4 is violated:** Use `GetAwaiter().GetResult()` for `Task.Delay`\r\n[SyncDelay.cs](https://github.com/Maxim-Kornilov/CancelKeyPressBug/blob/master/CancelKeyPressBug/TestCases/SyncDelay.cs#L15)\r\n\r\nThis bug is reproduced even if  I use `dotnet publish -c release -r win10-x86`. \r\n\r\nSimple test case or [GitHub repo with all test cases](https://github.com/Maxim-Kornilov/CancelKeyPressBug)\r\n```csharp\r\nprivate static async Task SimpleTestCase()\r\n{\r\n    var tokenSource = new CancellationTokenSource();\r\n    ConsoleCancelEventHandler cancelled = (s, e) =>\r\n    {\r\n        // Conditions #2 and #3\r\n        tokenSource.Cancel();\r\n        e.Cancel = true;\r\n    };\r\n    Console.CancelKeyPress += cancelled;\r\n\r\n    try\r\n    {\r\n        Console.WriteLine(\"Press Ctrl+C to continue\");\r\n        // Conditions #1 and #4\r\n        await Task.Delay(TimeSpan.FromHours(1.0), tokenSource.Token);  \r\n    }\r\n    catch (OperationCanceledException)\r\n    {\r\n        Console.WriteLine(\"Cancelled\");\r\n    }\r\n\r\n    Console.CancelKeyPress -= cancelled;\r\n}\r\n```\r\n\r\ndotnet info\r\n```\r\n–ü—Ä–æ–≥—Ä–∞–º–º—ã –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ .NET (2.0.2)\r\n\r\nProduct Information:\r\n Version:            2.0.2\r\n Commit SHA-1 hash:  a04b4bf512\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.16299\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.0.2\\\r\n\r\nMicrosoft .NET Core Shared Framework Host\r\n\r\n  Version  : 2.0.0\r\n  Build    : e8b8861ac7faf042c87a5c2f9f2d04c98b69f28d\r\n```\r\n\r\nI know that Task.Delay is part of coreclr and Console.CancelKeyPress is part of corefx. I dont't know what causes the issue, but I file it here because the Console.CancelKeyPress is the one that not working as expexted."},{"Id":"7027185687","Type":"PullRequestEvent","CreatedAt":"2017-12-24T16:11:15","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/26041","RelatedDescription":"Merged pull request \"Update CoreClr, CoreFx, CoreSetup to preview1-26024-02, preview1-26024-01, preview1-26023-02, respectively (master)\" (#26041) at dotnet/corefx","RelatedBody":""},{"Id":"7027182205","Type":"IssuesEvent","CreatedAt":"2017-12-24T16:08:15","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/25615","RelatedDescription":"Closed issue \"Move DangerousTryGetArray from a ReadOnlyMemory to MemoryMarshal\" (#25615) at dotnet/corefx","RelatedBody":"Leftover from the approved API proposal: https://github.com/dotnet/corefx/issues/23879#issuecomment-333306452\r\n\r\nRename the DangerousTryGetArray instance method on ReadOnlyMemory to TryGetArray and move it to the MemoryMarshal class.\r\n\r\n```C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class MemoryMarshal\r\n    {\r\n        public static bool TryGetArray<T>(ReadOnlyMemory<T> readOnlyMemory, out ArraySegment<T> arraySegment);\r\n    }\r\n}\r\n```\r\n\r\ncc @KrzysztofCwalina, @stephentoub"},{"Id":"7027182025","Type":"IssuesEvent","CreatedAt":"2017-12-24T16:08:06","Actor":"ahsonkhan","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corefx/issues/25412","RelatedDescription":"Closed issue \"Move (ReadOnly)Span.DangerousGetPinnableReference to MemoryMarshal\" (#25412) at dotnet/corefx","RelatedBody":"Separated from https://github.com/dotnet/corefx/issues/23879#issuecomment-341482899\r\n\r\nWe should also rename it as part of the move. Pinnable does not make sense if it is not going to be used for pinning. And Dangerous can be omitted too because of methods under `System.Runtime.InteropServices` are dangerous by convention.\r\n\r\nSo what about:\r\n\r\n```c#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class MemoryMarshal\r\n    {\r\n        public static readonly ref T GetReference<T>(in ReadOnlySpan<T> span);\r\n        public static ref T GetReference<T>(in Span<T> span);\r\n    }\r\n}\r\n```"},{"Id":"7027117747","Type":"PullRequestEvent","CreatedAt":"2017-12-24T15:12:32","Actor":"jkotas","Repository":"dotnet/corefx","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corefx/pull/25964","RelatedDescription":"Merged pull request \"Remove DangerousTryGetArray and hide DangerousGetPinnableReference\" (#25964) at dotnet/corefx","RelatedBody":"Fixes:\r\nhttps://github.com/dotnet/corefx/issues/25412\r\nhttps://github.com/dotnet/corefx/issues/25615\r\n\r\nAlso fixes https://github.com/dotnet/corefx/issues/23881\r\n\r\n**Depends on the following PR (hence blocked):** https://github.com/dotnet/coreclr/pull/15557\r\n\r\nFollowing the staging plan from here: https://github.com/dotnet/corefx/issues/23881#issuecomment-343767740\r\n\r\n- [x] Add MemoryExtensions.GetReference/TryGetArray\r\n- [x] Convert all uses of DangerousGetPinnableReference/DangerousTryGetArray in coreclr, corefx, corert, corefxlab, aspnet, ... to MemoryExtensions.GetReference\r\n- [x] Change DangerousGetPinnableReference to whatever we like to make it fit the pinning pattern and remove DangerousTryGetArray.\r\n\r\nDoing it this way will avoid the need for complex staging or things being on the floor for extensive periods of time.\r\n\r\ncc @jkotas, @stephentoub, @KrzysztofCwalina, @davidfowl "}],"ResultType":"GitHubEvent"},"Roslyn":{"Events":[{"Id":"7027530242","Type":"IssuesEvent","CreatedAt":"2017-12-24T22:21:53","Actor":"gafter","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/13284","RelatedDescription":"Closed issue \"Iterator Function return an Interface inheriting IEnumerable(Of T)\" (#13284) at dotnet/roslyn","RelatedBody":"Allow `Iterator Function` to return an interface that inherits from `IEnumerable(Of T)`\n\n```\n    Private Iterator Function _Ascending_(x As Integer, y As Integer) As IOrderedEnumerable(Of Integer)\n        Debug.Assert(x <= y)\n        For i = x To y\n            Yield i\n        Next\n    End Function\n```\n"},{"Id":"7027515169","Type":"IssuesEvent","CreatedAt":"2017-12-24T22:02:38","Actor":"paul1956","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23923","RelatedDescription":"Opened issue \"TryCast returns Warning BC4322 on String\" (#23923) at dotnet/roslyn","RelatedBody":"**Version Used**: \r\nVs 2017 15.5.2\r\n**Steps to Reproduce**:\r\n1. The description of TryCast says that it will not throw an exception, and this error only appears on the line where I am trying to assign the result to a string. String does implement IEnumerable(Of Char).\r\nBelow is not a complete implementation of this routine just enough to show the warning and several cases without the warning.\r\n```\r\n       Function IsEmpty(Of T)(ByVal lSource As IEnumerable(Of T)) As Boolean\r\n            Dim readOnlyCollection As IReadOnlyCollection(Of T) = TryCast(lSource, IReadOnlyCollection(Of T))\r\n            If readOnlyCollection IsNot Nothing Then\r\n                Return readOnlyCollection.Count = 0\r\n            End If\r\n\r\n            Dim genericCollection As ICollection(Of T) = TryCast(lSource, ICollection(Of T))\r\n            If genericCollection IsNot Nothing Then\r\n                Return genericCollection.Count = 0\r\n            End If\r\n\r\n            Dim collection As ICollection = TryCast(lSource, ICollection)\r\n            If collection IsNot Nothing Then\r\n                Return collection.Count = 0\r\n            End If\r\n\r\n           ' The following line gets Warning on iSource\r\n            Dim str As String = TryCast(**lSource**, String)\r\n            If str IsNot Nothing Then\r\n                Return str.Length = 0\r\n            End If\r\n            Return True\r\n        End Function\r\n```\r\n2.  With the code above there should be no warnings \r\n**Expected Behavior**:\r\nNo Warnings\r\n**Actual Behavior**:\r\nWarning\tBC42322\tRuntime errors might occur when converting 'IEnumerable(Of T)' to 'String'.\r\n"},{"Id":"7027436092","Type":"IssuesEvent","CreatedAt":"2017-12-24T20:33:59","Actor":"gafter","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/17369","RelatedDescription":"Closed issue \"OutOfMemoryException parsing string interpolation\" (#17369) at dotnet/roslyn","RelatedBody":"From https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?id=385179&_a=edit and https://developercommunity.visualstudio.com/content/problem/19285/outofmemoryexception.html\r\n\r\n\r\n\r\n> Visual Studio 2017 RC closed while i was typing some string interpolation on a fairly large code file. No popups, no warnings, just poof, gone.\r\n> \r\n> The file is ~5400 lines and contains a significant quantity of StringBuilder / string.Concat, and newly string interpolation to dynamically create a large number of text files based off input data.\r\n> \r\n> I also tried this in Visual Studio 2015 Update 3 and recieved a Hard Error popup window just before the application closed completely.\r\n\r\n``` none\r\n.Net Runtime Event Log entries:\r\nEventTime:2/13/2017 7:03:58 PM\r\nApplication: devenv.exe\r\nFramework Version: v4.0.30319\r\nDescription: The application requested process termination through System.Environment.FailFast(string message).\r\nMessage: System.OutOfMemoryException: Exception of type 'System.OutOfMemoryException' was thrown.\r\nat System.String.CtorCharArrayStartLength(Char[] value, Int32 startIndex, Int32 length)\r\nat Roslyn.Utilities.StringTable.Add(Char[] chars, Int32 start, Int32 len)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.GetText(Int32 position, Int32 length, Boolean intern)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanStringLiteral(TokenInfo& info, Boolean allowEscapes)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralContents(ArrayBuilder`1 interpolations)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralTop(ArrayBuilder`1 interpolations, TokenInfo& info, Boolean& closeQuoteMissing)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteralTop(ArrayBuilder`1 interpolations, Boolean isVerbatim, TokenInfo& info, SyntaxDiagnosticInfo& error, Boolean& closeQuoteMissing)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteral(Boolean isVerbatim, TokenInfo& info)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanSyntaxToken(TokenInfo& info)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexSyntaxToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.Lex(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.LexNewToken(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.ReadNewToken(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.ReadNodeOrToken(LexerMode mode, Boolean asToken)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddNewToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.FetchCurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.get_CurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseArgumentList(SyntaxToken& openToken, SeparatedSyntaxList`1& arguments, SyntaxToken& closeToken, SyntaxKind openKind, SyntaxKind closeKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseParenthesizedArgumentList()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParsePostFixExpression(ExpressionSyntax expr)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTerm(Precedence precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpressionCore(Precedence precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpression(Precedence precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean complexCheck)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(CSharpSyntaxNode& previousNode, SyntaxListBuilder`1 statements, Boolean stopOnSwitchSections)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean isMethodBody, Boolean isAccessorBody)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean complexCheck)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseElseClauseOpt()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(CSharpSyntaxNode& previousNode, SyntaxListBuilder`1 statements, Boolean stopOnSwitchSections)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean isMethodBody, Boolean isAccessorBody)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlockAndExpressionBodiesWithSemicolon(BlockSyntax& blockBody, ArrowExpressionClauseSyntax& expressionBody, SyntaxToken& semicolon, Boolean parseSemicolonAfterBlock, MessageID requestedExpressionBodyFeature)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMethodDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt, SyntaxToken identifier, TypeParameterListSyntax typeParameterList)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(SyntaxKind parentKind, String typeName)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseClassOrStructOrInterfaceDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTypeDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(SyntaxKind parentKind, String typeName)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes, SyntaxKind parentKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceDeclaration()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes, SyntaxKind parentKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnitCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseWithStackGuard[TNode](Func`1 parseFunc, Func`1 createEmptyNodeFunc)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnit()\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChanges(SourceText newText, IReadOnlyList`1 changes)\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText(SourceText newText)\r\nat Microsoft.CodeAnalysis.DocumentState.IncrementallyParse(TextAndVersion newTextAndVersion, TreeAndVersion oldTreeAndVersion, CancellationToken cancellationToken)\r\nat Microsoft.CodeAnalysis.DocumentState.d__15.MoveNext()\r\nStack:\r\nat System.Environment.FailFast(System.String, System.Exception)\r\nat Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)\r\nat Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1)\r\nat Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)\r\nat Microsoft.CodeAnalysis.DocumentState+d__15.MoveNext()\r\nat System.String.CtorCharArrayStartLength(Char[], Int32, Int32)\r\nat Roslyn.Utilities.StringTable.Add(Char[], Int32, Int32)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.GetText(Int32, Int32, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanStringLiteral(TokenInfo ByRef, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralContents(Microsoft.CodeAnalysis.ArrayBuilder`1)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralTop(Microsoft.CodeAnalysis.ArrayBuilder`1, TokenInfo ByRef, Boolean ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteralTop(Microsoft.CodeAnalysis.ArrayBuilder`1, Boolean, TokenInfo ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxDiagnosticInfo ByRef, Boolean ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteral(Boolean, TokenInfo ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanSyntaxToken(TokenInfo ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexSyntaxToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.Lex(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.LexNewToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.ReadNewToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.ReadNodeOrToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddNewToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.FetchCurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.get_CurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList`1 ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseParenthesizedArgumentList()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParsePostFixExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTerm(Precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpressionCore(Precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpression(Precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseElseClauseOpt()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlockAndExpressionBodiesWithSemicolon(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, Boolean, Microsoft.CodeAnalysis.CSharp.MessageID)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMethodDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind, System.String)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseClassOrStructOrInterfaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTypeDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind, System.String)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, NamespaceBodyBuilder ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceDeclaration()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, NamespaceBodyBuilder ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnitCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseWithStackGuard[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Func`1, System.Func`1)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnit()\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChanges(Microsoft.CodeAnalysis.Text.SourceText, System.Collections.Generic.IReadOnlyList`1)\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)\r\nat Microsoft.CodeAnalysis.DocumentState.IncrementallyParse(Microsoft.CodeAnalysis.TextAndVersion, Microsoft.CodeAnalysis.TreeAndVersion, System.Threading.CancellationToken)\r\nat Microsoft.CodeAnalysis.DocumentState+d__15.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetResult(System.__Canon)\r\nat System.Threading.Tasks.TaskCompletionSource`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetResult(System.__Canon)\r\nat Roslyn.Utilities.AsyncLazy`1+Request[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].CompleteFromTaskSynchronously(System.Threading.Tasks.Task`1)\r\nat Roslyn.Utilities.AsyncLazy`1+Request[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].CompleteFromTaskSynchronouslyStub(System.Object)\r\nat System.Threading.Tasks.Task.InnerInvoke()\r\nat System.Threading.Tasks.Task.Execute()\r\nat System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.ExecuteEntry(Boolean)\r\nat System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()\r\nat System.Threading.ThreadPoolWorkQueue.Dispatch()\r\nat System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n\r\nEventTime:2/13/2017 6:02:23 PM\r\nApplication: devenv.exe\r\nFramework Version: v4.0.30319\r\nDescription: The application requested process termination through System.Environment.FailFast(string message).\r\nMessage: System.OutOfMemoryException: Exception of type 'System.OutOfMemoryException' was thrown.\r\nat System.String.CtorCharArrayStartLength(Char[] value, Int32 startIndex, Int32 length)\r\nat Roslyn.Utilities.StringTable.Add(Char[] chars, Int32 start, Int32 len)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.GetText(Int32 position, Int32 length, Boolean intern)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanStringLiteral(TokenInfo& info, Boolean allowEscapes)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralContents(ArrayBuilder`1 interpolations)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralTop(ArrayBuilder`1 interpolations, TokenInfo& info, Boolean& closeQuoteMissing)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteralTop(ArrayBuilder`1 interpolations, Boolean isVerbatim, TokenInfo& info, SyntaxDiagnosticInfo& error, Boolean& closeQuoteMissing)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteral(Boolean isVerbatim, TokenInfo& info)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanSyntaxToken(TokenInfo& info)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexSyntaxToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.Lex(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.LexNewToken(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.ReadNewToken(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.ReadNodeOrToken(LexerMode mode, Boolean asToken)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddNewToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.FetchCurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseArgumentList(SyntaxToken& openToken, SeparatedSyntaxList`1& arguments, SyntaxToken& closeToken, SyntaxKind openKind, SyntaxKind closeKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseParenthesizedArgumentList()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParsePostFixExpression(ExpressionSyntax expr)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTerm(UInt32 precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpressionCore(UInt32 precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpression(UInt32 precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean complexCheck)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(CSharpSyntaxNode& previousNode, SyntaxListBuilder`1 statements, Boolean stopOnSwitchSections)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean isMethodBody, Boolean isAccessorBody)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean complexCheck)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(CSharpSyntaxNode& previousNode, SyntaxListBuilder`1 statements, Boolean stopOnSwitchSections)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean isMethodBody, Boolean isAccessorBody)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlockAndExpressionBodiesWithSemicolon(BlockSyntax& blockBody, ArrowExpressionClauseSyntax& expressionBody, SyntaxToken& semicolon)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMethodDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt, SyntaxToken identifier, TypeParameterListSyntax typeParameterList)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(SyntaxKind parentKind, String typeName)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseClassOrStructOrInterfaceDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTypeDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(SyntaxKind parentKind, String typeName)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes, SyntaxKind parentKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceDeclaration()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes, SyntaxKind parentKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnitCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseWithStackGuard[TNode](Func`1 parseFunc, Func`1 createEmptyNodeFunc)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnit()\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChanges(SourceText newText, IReadOnlyList`1 changes)\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText(SourceText newText)\r\nat Microsoft.CodeAnalysis.DocumentState.d__13.MoveNext()\r\nStack:\r\nat System.Environment.FailFast(System.String, System.Exception)\r\nat Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)\r\nat Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1)\r\nat Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)\r\nat Microsoft.CodeAnalysis.DocumentState+d__13.MoveNext()\r\nat System.String.CtorCharArrayStartLength(Char[], Int32, Int32)\r\nat Roslyn.Utilities.StringTable.Add(Char[], Int32, Int32)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.GetText(Int32, Int32, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanStringLiteral(TokenInfo ByRef, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralContents(Microsoft.CodeAnalysis.ArrayBuilder`1)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralTop(Microsoft.CodeAnalysis.ArrayBuilder`1, TokenInfo ByRef, Boolean ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteralTop(Microsoft.CodeAnalysis.ArrayBuilder`1, Boolean, TokenInfo ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxDiagnosticInfo ByRef, Boolean ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteral(Boolean, TokenInfo ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanSyntaxToken(TokenInfo ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexSyntaxToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.Lex(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.LexNewToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.ReadNewToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.ReadNodeOrToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddNewToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.FetchCurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SeparatedSyntaxList`1 ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseParenthesizedArgumentList()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParsePostFixExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTerm(UInt32)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpressionCore(UInt32)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpression(UInt32)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder`1, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder`1, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlockAndExpressionBodiesWithSemicolon(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind, System.String)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseClassOrStructOrInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTypeDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind, System.String)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, NamespaceBodyBuilder ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceDeclaration()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, NamespaceBodyBuilder ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnitCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseWithStackGuard[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Func`1, System.Func`1)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnit()\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChanges(Microsoft.CodeAnalysis.Text.SourceText, System.Collections.Generic.IReadOnlyList`1)\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)\r\nat Microsoft.CodeAnalysis.DocumentState+d__13.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetResult(System.__Canon)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetResult(System.__Canon)\r\nat Roslyn.Utilities.AsyncLazy`1+Request[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].CompleteFromTaskSynchronously(System.Threading.Tasks.Task`1)\r\nat Roslyn.Utilities.AsyncLazy`1+Request[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].CompleteFromTaskSynchronouslyStub(System.Object)\r\nat System.Threading.Tasks.Task.InnerInvoke()\r\nat System.Threading.Tasks.Task.Execute()\r\nat System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.ExecuteEntry(Boolean)\r\nat System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()\r\nat System.Threading.ThreadPoolWorkQueue.Dispatch()\r\nat System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n\r\nEventTime:2/13/2017 5:55:56 PM\r\nApplication: devenv.exe\r\nFramework Version: v4.0.30319\r\nDescription: The application requested process termination through System.Environment.FailFast(string message).\r\nMessage: System.OutOfMemoryException: Exception of type 'System.OutOfMemoryException' was thrown.\r\nat System.String.CtorCharArrayStartLength(Char[] value, Int32 startIndex, Int32 length)\r\nat Roslyn.Utilities.StringTable.Add(Char[] chars, Int32 start, Int32 len)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.GetText(Int32 position, Int32 length, Boolean intern)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanStringLiteral(TokenInfo& info, Boolean allowEscapes)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char endingChar, Boolean isHole, Int32& colonPosition)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralContents(ArrayBuilder`1 interpolations)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralTop(ArrayBuilder`1 interpolations, TokenInfo& info, Boolean& closeQuoteMissing)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteralTop(ArrayBuilder`1 interpolations, Boolean isVerbatim, TokenInfo& info, SyntaxDiagnosticInfo& error, Boolean& closeQuoteMissing)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteral(Boolean isVerbatim, TokenInfo& info)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanSyntaxToken(TokenInfo& info)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexSyntaxToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.Lex(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.LexNewToken(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.ReadNewToken(LexerMode mode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Reader.ReadNodeOrToken(LexerMode mode, Boolean asToken)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddNewToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.FetchCurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.get_CurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseArgumentList(SyntaxToken& openToken, SeparatedSyntaxList`1& arguments, SyntaxToken& closeToken, SyntaxKind openKind, SyntaxKind closeKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseParenthesizedArgumentList()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParsePostFixExpression(ExpressionSyntax expr)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTerm(Precedence precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpressionCore(Precedence precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpression(Precedence precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean complexCheck)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(CSharpSyntaxNode& previousNode, SyntaxListBuilder`1 statements, Boolean stopOnSwitchSections)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean isMethodBody, Boolean isAccessorBody)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean complexCheck)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseElseClauseOpt()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean allowAnyExpression)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(CSharpSyntaxNode& previousNode, SyntaxListBuilder`1 statements, Boolean stopOnSwitchSections)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean isMethodBody, Boolean isAccessorBody)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlockAndExpressionBodiesWithSemicolon(BlockSyntax& blockBody, ArrowExpressionClauseSyntax& expressionBody, SyntaxToken& semicolon, Boolean parseSemicolonAfterBlock, MessageID requestedExpressionBodyFeature)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMethodDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt, SyntaxToken identifier, TypeParameterListSyntax typeParameterList)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(SyntaxKind parentKind, String typeName)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseClassOrStructOrInterfaceDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTypeDeclaration(SyntaxListBuilder`1 attributes, SyntaxListBuilder modifiers)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(SyntaxKind parentKind, String typeName)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes, SyntaxKind parentKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceDeclaration()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes, SyntaxKind parentKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnitCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseWithStackGuard[TNode](Func`1 parseFunc, Func`1 createEmptyNodeFunc)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnit()\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChanges(SourceText newText, IReadOnlyList`1 changes)\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText(SourceText newText)\r\nat Microsoft.CodeAnalysis.DocumentState.IncrementallyParse(TextAndVersion newTextAndVersion, TreeAndVersion oldTreeAndVersion, CancellationToken cancellationToken)\r\nat Microsoft.CodeAnalysis.DocumentState.d__15.MoveNext()\r\nStack:\r\nat System.Environment.FailFast(System.String, System.Exception)\r\nat Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)\r\nat Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1)\r\nat Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)\r\nat Microsoft.CodeAnalysis.DocumentState+d__15.MoveNext()\r\nat System.String.CtorCharArrayStartLength(Char[], Int32, Int32)\r\nat Roslyn.Utilities.StringTable.Add(Char[], Int32, Int32)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.GetText(Int32, Int32, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanStringLiteral(TokenInfo ByRef, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Char, Boolean, Int32 ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralContents(Microsoft.CodeAnalysis.ArrayBuilder`1)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer+InterpolatedStringScanner.ScanInterpolatedStringLiteralTop(Microsoft.CodeAnalysis.ArrayBuilder`1, TokenInfo ByRef, Boolean ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteralTop(Microsoft.CodeAnalysis.ArrayBuilder`1, Boolean, TokenInfo ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxDiagnosticInfo ByRef, Boolean ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanInterpolatedStringLiteral(Boolean, TokenInfo ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanSyntaxToken(TokenInfo ByRef)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexSyntaxToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.Lex(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.LexNewToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.ReadNewToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender+Reader.ReadNodeOrToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddNewToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.FetchCurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.get_CurrentToken()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList`1 ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseParenthesizedArgumentList()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParsePostFixExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTerm(Precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpressionCore(Precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpression(Precedence)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseEmbeddedStatement(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseElseClauseOpt()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseIfStatement()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatements(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Boolean, Boolean)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlockAndExpressionBodiesWithSemicolon(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax ByRef, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, Boolean, Microsoft.CodeAnalysis.CSharp.MessageID)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMethodDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken, Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind, System.String)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseClassOrStructOrInterfaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTypeDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind, System.String)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, NamespaceBodyBuilder ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceDeclaration()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseNamespaceBody(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken ByRef, NamespaceBodyBuilder ByRef, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder ByRef, Microsoft.CodeAnalysis.CSharp.SyntaxKind)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnitCore()\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseWithStackGuard[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Func`1, System.Func`1)\r\nat Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseCompilationUnit()\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChanges(Microsoft.CodeAnalysis.Text.SourceText, System.Collections.Generic.IReadOnlyList`1)\r\nat Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)\r\nat Microsoft.CodeAnalysis.DocumentState.IncrementallyParse(Microsoft.CodeAnalysis.TextAndVersion, Microsoft.CodeAnalysis.TreeAndVersion, System.Threading.CancellationToken)\r\nat Microsoft.CodeAnalysis.DocumentState+d__15.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.DocumentState+d__15, Microsoft.CodeAnalysis.Workspaces, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](d__15 ByRef)\r\nat Microsoft.CodeAnalysis.DocumentState.IncrementallyParseTreeAsync(Roslyn.Utilities.ValueSource`1, Roslyn.Utilities.ValueSource`1, System.Threading.CancellationToken)\r\nat Microsoft.CodeAnalysis.DocumentState+<>c__DisplayClass14_0.b__0(System.Threading.CancellationToken)\r\nat Roslyn.Utilities.AsyncLazy`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].StartAsynchronousComputation(AsynchronousComputationToStart, Request, System.Threading.CancellationToken)\r\nat Roslyn.Utilities.AsyncLazy`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].GetValueAsync(System.Threading.CancellationToken)\r\nat Microsoft.CodeAnalysis.DocumentState+d__38.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.DocumentState+d__38, Microsoft.CodeAnalysis.Workspaces, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](d__38 ByRef)\r\nat Microsoft.CodeAnalysis.DocumentState.GetSyntaxTreeAsync(System.Threading.CancellationToken)\r\nat Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)\r\nat Microsoft.CodeAnalysis.Host.BackgroundParser+<>c__DisplayClass20_0.b__0()\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()\r\nat System.Threading.Tasks.Task.Execute()\r\nat System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.ExecuteEntry(Boolean)\r\nat System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()\r\nat System.Threading.ThreadPoolWorkQueue.Dispatch()\r\nat System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n\r\nEventTime:1/31/2017 5:17:24 PM\r\nApplication: devenv.exe\r\nFramework Version: v4.0.30319\r\nDescription: The application requested process termination through System.Environment.FailFast(string message).\r\nMessage: StreamJsonRpc.RemoteInvocationException: Value cannot be null.\r\nat System.Threading.Monitor.ReliableEnter(Object obj, Boolean& lockTaken)\r\nat Microsoft.CodeAnalysis.Remote.SnapshotService.Initialize(Int32 sessionId, Byte[] solutionChecksum)\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)\r\nat StreamJsonRpc.JsonRpc.d__56`1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.JsonRpcClient.d__3.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.JsonRpcSession.d__7.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.JsonRpcSession.d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.ServiceHubRemoteHostClient.d__7.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.CodeAnalysis.Remote.RemoteHostClient.d__6.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.RemoteHostClientServiceFactory.SolutionChecksumUpdater.d__14.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.RemoteHostClientServiceFactory.SolutionChecksumUpdater.d__8.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.CodeAnalysis.SolutionCrawler.IdleProcessor.d__12.MoveNext()\r\nStack:\r\nat System.Environment.FailFast(System.String, System.Exception)\r\nat Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)\r\nat Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1)\r\nat Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception)\r\nat Roslyn.Utilities.TaskExtensions.ReportFatalErrorWorker(System.Threading.Tasks.Task, System.Object)\r\nat System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke()\r\nat System.Threading.Tasks.Task.Execute()\r\nat System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.ExecuteEntry(Boolean)\r\nat System.Threading.Tasks.ThreadPoolTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task, Boolean)\r\nat System.Threading.Tasks.TaskScheduler.TryRunInline(System.Threading.Tasks.Task, Boolean)\r\nat System.Threading.Tasks.TaskContinuation.InlineIfPossibleOrElseQueue(System.Threading.Tasks.Task, Boolean)\r\nat System.Threading.Tasks.StandardTaskContinuation.Run(System.Threading.Tasks.Task, Boolean)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.Threading.Tasks.TaskExtensions+VoidResult, System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Threading.Tasks.UnwrapPromise`1[[System.Threading.Tasks.TaskExtensions+VoidResult, System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetFromTask(System.Threading.Tasks.Task, Boolean)\r\nat System.Threading.Tasks.UnwrapPromise`1[[System.Threading.Tasks.TaskExtensions+VoidResult, System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InvokeCore(System.Threading.Tasks.Task)\r\nat System.Threading.Tasks.UnwrapPromise`1[[System.Threading.Tasks.TaskExtensions+VoidResult, System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Invoke(System.Threading.Tasks.Task)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat Microsoft.CodeAnalysis.SolutionCrawler.IdleProcessor+d__12.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.RemoteHostClientServiceFactory+SolutionChecksumUpdater+d__8.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.RemoteHostClientServiceFactory+SolutionChecksumUpdater+d__14.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat Microsoft.CodeAnalysis.Remote.RemoteHostClient+d__6.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.ServiceHubRemoteHostClient+d__7.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.JsonRpcSession+d__5.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.JsonRpcSession+d__7.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat Microsoft.VisualStudio.LanguageServices.Remote.JsonRpcClient+d__3.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].SetException(System.Exception)\r\nat StreamJsonRpc.JsonRpc+d__56`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.InvokeMoveNext(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\nat System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.FinishContinuations()\r\nat System.Threading.Tasks.Task.FinishStageThree()\r\nat System.Threading.Tasks.Task.FinishStageTwo()\r\nat System.Threading.Tasks.Task.Finish(Boolean)\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Object)\r\nat System.Threading.Tasks.TaskCompletionSource`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TrySetException(System.Exception)\r\nat StreamJsonRpc.JsonRpc+<>c__DisplayClass56_1`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].b__0(StreamJsonRpc.JsonRpcMessage)\r\nat StreamJsonRpc.JsonRpc+d__62.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[StreamJsonRpc.JsonRpc+d__62, StreamJsonRpc, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]](d__62 ByRef)\r\nat StreamJsonRpc.JsonRpc.HandleRpcAsync(System.String)\r\nat StreamJsonRpc.JsonRpc+<>c__DisplayClass61_0+<b__0>d.MoveNext()\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[StreamJsonRpc.JsonRpc+<>c__DisplayClass61_0+<b__0>d, StreamJsonRpc, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]](<b__0>d ByRef)\r\nat StreamJsonRpc.JsonRpc+<>c__DisplayClass61_0.b__0()\r\nat System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()\r\nat System.Threading.Tasks.Task.Execute()\r\nat System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)\r\nat System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\nat System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)\r\nat System.Threading.Tasks.Task.ExecuteEntry(Boolean)\r\nat System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()\r\nat System.Threading.ThreadPoolWorkQueue.Dispatch()\r\nat System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n\r\nEventTime:1/3/2017 3:44:58 PM\r\nApplication: devenv.exe\r\nFramework Version: v4.0.30319\r\nDescription: The process was terminated due to an internal error in the .NET Runtime at IP 0F5C927A (0F5A0000) with exit code 80131506.\r\n```\r\n"},{"Id":"7026145417","Type":"IssuesEvent","CreatedAt":"2017-12-23T21:43:52","Actor":"MkazemAkhgary","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23922","RelatedDescription":"Opened issue \"Show array content via index in debugger\" (#23922) at dotnet/roslyn","RelatedBody":"\r\n![capture](https://user-images.githubusercontent.com/15255162/34322807-3a80aeb4-e847-11e7-9a88-33ca1b59c143.PNG)\r\n\r\nWhen I hover mouse over bracket, I would like to see item in that index instead of trying to seek in array and find item manually.  \r\n\r\nwhen I hover over `array` I can expand and see all items. when I hover over `End` I can see its content. but when I hover over brackets I see nothing. it seems good place to show item in that index (if index can be evaluated) when hovering over brackets."},{"Id":"7025306781","Type":"IssuesEvent","CreatedAt":"2017-12-23T08:15:47","Actor":"jcouv","Repository":"dotnet/roslyn","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/roslyn/issues/23915","RelatedDescription":"Closed issue \"Document tag <param name=> fails for named tuples\" (#23915) at dotnet/roslyn","RelatedBody":"In the snippet below, param name give &quot;Cannot resolve symbol&quot; for the named tuples names (current and previous).\r\n\r\n```csharp\r\n/// <summary>\r\n/// </summary>\r\n/// <param name=\"dataPoints\"></param>\r\n/// <param name=\"current\"></param>\r\n/// <param name=\"previous\"></param>\r\n/// <returns></returns>\r\npublic (List<float> current, List<float> previous) DivideByPhaseAsync(List<float> dataPoints)\r\n{\r\n\tvar current = new List<float>();\r\n\tvar previous = new List<float>();\r\n\treturn (current, previous);\r\n}\r\n```\r\n\r\n_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/171531/document-tag-fails-for-named-tuples.html\r\nVSTS ticketId: 542449_\r\n_These are the original issue comments:_\r\n(no comments)\r\n_These are the original issue solutions:_\r\n(no solutions)"}],"ResultType":"GitHubEvent"},"CoreRT":{"Events":[{"Id":"7027661455","Type":"PullRequestEvent","CreatedAt":"2017-12-25T01:06:53","Actor":"benaadams","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5153","RelatedDescription":"Opened pull request \"Reduce EC Save+Restore for Default context\" (#5153) at dotnet/corert","RelatedBody":"Matching change for shared code in https://github.com/dotnet/coreclr/pull/15629"},{"Id":"7027287246","Type":"PullRequestEvent","CreatedAt":"2017-12-24T17:50:11","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5150","RelatedDescription":"Merged pull request \"Fix marshaling of pointers marked with [Out]\" (#5150) at dotnet/corert","RelatedBody":"[Out] on pointers need to be ignored similar to how it is ignored on other blittable types"},{"Id":"7027065651","Type":"IssuesEvent","CreatedAt":"2017-12-24T14:28:38","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/corert/issues/5152","RelatedDescription":"Reopened issue \"Fix marshalling code to meet the CIL backwards branch constraint\" (#5152) at dotnet/corert","RelatedBody":"See #5149 - we can't use the validating IL emitter to generate marshalling code because the generated code fails to satisfy ECMA-335 III.1.7.5 on backwards branch constraints.\r\n"},{"Id":"7027065564","Type":"IssuesEvent","CreatedAt":"2017-12-24T14:28:35","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/5152","RelatedDescription":"Closed issue \"Fix marshalling code to meet the CIL backwards branch constraint\" (#5152) at dotnet/corert","RelatedBody":"See #5149 - we can't use the validating IL emitter to generate marshalling code because the generated code fails to satisfy ECMA-335 III.1.7.5 on backwards branch constraints.\r\n"},{"Id":"7027064703","Type":"PullRequestEvent","CreatedAt":"2017-12-24T14:27:48","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/corert/pull/5149","RelatedDescription":"Merged pull request \"Add algorithm to compute the MaxStack value\" (#5149) at dotnet/corert","RelatedBody":"This serves two purposes:\r\n\r\n- Compute MaxStack for generated IL. We were estimating the MaxStack by reporting the number of bytes of IL but this was inhibiting inlining in RyuJIT\r\n- Add code to validate stack balance for IL we generate. This lets us catch issues before they reach codegen. This should help productivity because it lets us avoid having to either build a checked RyuJIT to troubleshoot this, or debug the IL manually on paper.\r\n\r\nFixes #2119."},{"Id":"7027064701","Type":"IssuesEvent","CreatedAt":"2017-12-24T14:27:48","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/corert/issues/2119","RelatedDescription":"Closed issue \"ILEmitter should compute the maxstack value\" (#2119) at dotnet/corert","RelatedBody":"Maxstack is currently set to the number of bytes in the IL body of the method, but this number is unnecessarily big. RyuJIT makes e.g. inlining decisions using the value of maxstack. For well formed IL it is a trivial operation to compute maxstack.\r\n\r\nOnce we can compute stack height at arbitrary instructions, we can also use it to provide better asserts to validate the IL and improve developer productivity (validate that branches don't cause stack imbalance, method has a return value on the stack, etc.)."},{"Id":"7026978294","Type":"IssuesEvent","CreatedAt":"2017-12-24T13:12:49","Actor":"MichalStrehovsky","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/issues/5152","RelatedDescription":"Opened issue \"Fix marshalling code to meet the CIL backwards branch constraint\" (#5152) at dotnet/corert","RelatedBody":"See #5149 - we can't use the validating IL emitter to generate marshalling code because the generated code fails to satisfy ECMA-335 III.1.7.5 on backwards branch constraints.\r\n"},{"Id":"7026968716","Type":"PullRequestEvent","CreatedAt":"2017-12-24T13:03:32","Actor":"yaram","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5151","RelatedDescription":"Opened pull request \"Implement cpobj opcode for wasm\" (#5151) at dotnet/corert","RelatedBody":"Implements the ILToWebAssemblyImporter.ImportCpObj method using a call\r\nto an llvm.malloc.* intrinsic.\r\n\r\nFix #4548"},{"Id":"7026551616","Type":"PullRequestEvent","CreatedAt":"2017-12-24T05:43:33","Actor":"jkotas","Repository":"dotnet/corert","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/corert/pull/5150","RelatedDescription":"Opened pull request \"Fix marshaling of pointers marked with [Out]\" (#5150) at dotnet/corert","RelatedBody":"[Out] on pointers need to be ignored similar to how it is ignored on other blittable types"}],"ResultType":"GitHubEvent"},"SDK":{"Events":[{"Id":"7025969737","Type":"PullRequestEvent","CreatedAt":"2017-12-23T18:49:12","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"merged","RelatedUrl":"https://github.com/dotnet/sdk/pull/1831","RelatedDescription":"Merged pull request \"Insert NuGet Build 4.6.0-preview2-4759 into sdk\" (#1831) at dotnet/sdk","RelatedBody":"Insert NuGet Build 4.6.0-preview2-4759 into sdk master branch"},{"Id":"7024482097","Type":"PullRequestEvent","CreatedAt":"2017-12-22T21:13:52","Actor":"nugetlurker","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"opened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1831","RelatedDescription":"Opened pull request \"Insert NuGet Build 4.6.0-preview2-4759 into sdk\" (#1831) at dotnet/sdk","RelatedBody":"Insert NuGet Build 4.6.0-preview2-4759 into sdk master branch"},{"Id":"7024443991","Type":"PullRequestEvent","CreatedAt":"2017-12-22T20:57:50","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"reopened","RelatedUrl":"https://github.com/dotnet/sdk/pull/1753","RelatedDescription":null,"RelatedBody":"Insert NuGet Build 4.5.0-rtm-4651 into sdk release/15.5 branch"},{"Id":"7024440549","Type":"PullRequestEvent","CreatedAt":"2017-12-22T20:56:24","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/pull/1753","RelatedDescription":"Closed pull request \"Insert NuGet Build 4.5.0-rtm-4651 into sdk\" (#1753) at dotnet/sdk","RelatedBody":"Insert NuGet Build 4.5.0-rtm-4651 into sdk release/15.5 branch"},{"Id":"7024228195","Type":"PullRequestEvent","CreatedAt":"2017-12-22T19:36:32","Actor":"johnbeisner","Repository":"dotnet/sdk","Organization":"dotnet","RawContent":null,"RelatedAction":"closed","RelatedUrl":"https://github.com/dotnet/sdk/pull/1829","RelatedDescription":"Closed pull request \"Insert NuGet Build 4.6.0-preview2-4745 into sdk\" (#1829) at dotnet/sdk","RelatedBody":"Insert NuGet Build 4.6.0-preview2-4745 into sdk master branch"}],"ResultType":"GitHubEvent"},"Twitter":{"ResultType":"TwitterTimeline","Tweets":[{"Id":"944564608391577600","CreatedAt":"2017-12-23T13:45:26+00:00","UserScreenname":"dotnet","Text":"Join our Jeff Fritz - @csharpfritz and MVP @IrisClasson in about an hour for LIVE CODING and pair programming on‚Ä¶ https://t.co/kicrnl8tNJ","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":23,"FavoriteCount":11,"RawContent":null},{"Id":"943234846079496192","CreatedAt":"2017-12-19T21:41:26+00:00","UserScreenname":"dotnet","Text":"Join our Jeff Fritz (@csharpfritz) in a little more than 2 hours for LIVE CODING. He's working on an @aspnet Core p‚Ä¶ https://t.co/Xm2utapspg","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":36,"FavoriteCount":15,"RawContent":null},{"Id":"942039735144452097","CreatedAt":"2017-12-16T14:32:29+00:00","UserScreenname":"dotnet","Text":"Join our Jeff Fritz in 30 minutes for some LIVE CODING and answering your questions about .NET and Visual Studio.  https://t.co/UjBOoFqFp5","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":23,"FavoriteCount":18,"RawContent":null},{"Id":"941295101212549121","CreatedAt":"2017-12-14T13:13:35+00:00","UserScreenname":"dotnet","Text":"Join our Jeff Fritz at 10am ET for a LIVE CODING session.  He'll answer your questions about .NET, Visual Studio, a‚Ä¶ https://t.co/qJHWFDaUGf","Source":"<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>","RetweetCount":21,"FavoriteCount":14,"RawContent":null}]}},"RunOn":"2017-12-25T05:30:20.5863309Z","RunDurationInMilliseconds":7694}